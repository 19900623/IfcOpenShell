/********************************************************************************
 *                                                                              *
 * This file is part of IfcOpenShell.                                           *
 *                                                                              *
 * IfcOpenShell is free software: you can redistribute it and/or modify         *
 * it under the terms of the Lesser GNU General Public License as published by  *
 * the Free Software Foundation, either version 3.0 of the License, or          *
 * (at your option) any later version.                                          *
 *                                                                              *
 * IfcOpenShell is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
 * Lesser GNU General Public License for more details.                          *
 *                                                                              *
 * You should have received a copy of the Lesser GNU General Public License     *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.         *
 *                                                                              *
 ********************************************************************************/

/********************************************************************************
 *                                                                              *
 * This file has been generated from IFC4.exp. Do not make modifications        *
 * but instead modify the python script that has been used to generate this.    *
 *                                                                              *
 ********************************************************************************/

#ifdef USE_IFC4

#include "../ifcparse/Ifc4.h"
#include "../ifcparse/IfcSchema.h"
#include "../ifcparse/IfcException.h"
#include "../ifcparse/IfcWrite.h"

#include <map>

using namespace Ifc4;
using namespace IfcParse;
using namespace IfcWrite;

// External definitions
extern entity* IfcActionRequest_type;
extern entity* IfcActor_type;
extern entity* IfcActorRole_type;
extern entity* IfcActuator_type;
extern entity* IfcActuatorType_type;
extern entity* IfcAddress_type;
extern entity* IfcAdvancedBrep_type;
extern entity* IfcAdvancedBrepWithVoids_type;
extern entity* IfcAdvancedFace_type;
extern entity* IfcAirTerminal_type;
extern entity* IfcAirTerminalBox_type;
extern entity* IfcAirTerminalBoxType_type;
extern entity* IfcAirTerminalType_type;
extern entity* IfcAirToAirHeatRecovery_type;
extern entity* IfcAirToAirHeatRecoveryType_type;
extern entity* IfcAlarm_type;
extern entity* IfcAlarmType_type;
extern entity* IfcAnnotation_type;
extern entity* IfcAnnotationFillArea_type;
extern entity* IfcApplication_type;
extern entity* IfcAppliedValue_type;
extern entity* IfcApproval_type;
extern entity* IfcApprovalRelationship_type;
extern entity* IfcArbitraryClosedProfileDef_type;
extern entity* IfcArbitraryOpenProfileDef_type;
extern entity* IfcArbitraryProfileDefWithVoids_type;
extern entity* IfcAsset_type;
extern entity* IfcAsymmetricIShapeProfileDef_type;
extern entity* IfcAudioVisualAppliance_type;
extern entity* IfcAudioVisualApplianceType_type;
extern entity* IfcAxis1Placement_type;
extern entity* IfcAxis2Placement2D_type;
extern entity* IfcAxis2Placement3D_type;
extern entity* IfcBSplineCurve_type;
extern entity* IfcBSplineCurveWithKnots_type;
extern entity* IfcBSplineSurface_type;
extern entity* IfcBSplineSurfaceWithKnots_type;
extern entity* IfcBeam_type;
extern entity* IfcBeamStandardCase_type;
extern entity* IfcBeamType_type;
extern entity* IfcBlobTexture_type;
extern entity* IfcBlock_type;
extern entity* IfcBoiler_type;
extern entity* IfcBoilerType_type;
extern entity* IfcBooleanClippingResult_type;
extern entity* IfcBooleanResult_type;
extern entity* IfcBoundaryCondition_type;
extern entity* IfcBoundaryCurve_type;
extern entity* IfcBoundaryEdgeCondition_type;
extern entity* IfcBoundaryFaceCondition_type;
extern entity* IfcBoundaryNodeCondition_type;
extern entity* IfcBoundaryNodeConditionWarping_type;
extern entity* IfcBoundedCurve_type;
extern entity* IfcBoundedSurface_type;
extern entity* IfcBoundingBox_type;
extern entity* IfcBoxedHalfSpace_type;
extern entity* IfcBuilding_type;
extern entity* IfcBuildingElement_type;
extern entity* IfcBuildingElementPart_type;
extern entity* IfcBuildingElementPartType_type;
extern entity* IfcBuildingElementProxy_type;
extern entity* IfcBuildingElementProxyType_type;
extern entity* IfcBuildingElementType_type;
extern entity* IfcBuildingStorey_type;
extern entity* IfcBuildingSystem_type;
extern entity* IfcBurner_type;
extern entity* IfcBurnerType_type;
extern entity* IfcCShapeProfileDef_type;
extern entity* IfcCableCarrierFitting_type;
extern entity* IfcCableCarrierFittingType_type;
extern entity* IfcCableCarrierSegment_type;
extern entity* IfcCableCarrierSegmentType_type;
extern entity* IfcCableFitting_type;
extern entity* IfcCableFittingType_type;
extern entity* IfcCableSegment_type;
extern entity* IfcCableSegmentType_type;
extern entity* IfcCartesianPoint_type;
extern entity* IfcCartesianPointList_type;
extern entity* IfcCartesianPointList2D_type;
extern entity* IfcCartesianPointList3D_type;
extern entity* IfcCartesianTransformationOperator_type;
extern entity* IfcCartesianTransformationOperator2D_type;
extern entity* IfcCartesianTransformationOperator2DnonUniform_type;
extern entity* IfcCartesianTransformationOperator3D_type;
extern entity* IfcCartesianTransformationOperator3DnonUniform_type;
extern entity* IfcCenterLineProfileDef_type;
extern entity* IfcChiller_type;
extern entity* IfcChillerType_type;
extern entity* IfcChimney_type;
extern entity* IfcChimneyType_type;
extern entity* IfcCircle_type;
extern entity* IfcCircleHollowProfileDef_type;
extern entity* IfcCircleProfileDef_type;
extern entity* IfcCivilElement_type;
extern entity* IfcCivilElementType_type;
extern entity* IfcClassification_type;
extern entity* IfcClassificationReference_type;
extern entity* IfcClosedShell_type;
extern entity* IfcCoil_type;
extern entity* IfcCoilType_type;
extern entity* IfcColourRgb_type;
extern entity* IfcColourRgbList_type;
extern entity* IfcColourSpecification_type;
extern entity* IfcColumn_type;
extern entity* IfcColumnStandardCase_type;
extern entity* IfcColumnType_type;
extern entity* IfcCommunicationsAppliance_type;
extern entity* IfcCommunicationsApplianceType_type;
extern entity* IfcComplexProperty_type;
extern entity* IfcComplexPropertyTemplate_type;
extern entity* IfcCompositeCurve_type;
extern entity* IfcCompositeCurveOnSurface_type;
extern entity* IfcCompositeCurveSegment_type;
extern entity* IfcCompositeProfileDef_type;
extern entity* IfcCompressor_type;
extern entity* IfcCompressorType_type;
extern entity* IfcCondenser_type;
extern entity* IfcCondenserType_type;
extern entity* IfcConic_type;
extern entity* IfcConnectedFaceSet_type;
extern entity* IfcConnectionCurveGeometry_type;
extern entity* IfcConnectionGeometry_type;
extern entity* IfcConnectionPointEccentricity_type;
extern entity* IfcConnectionPointGeometry_type;
extern entity* IfcConnectionSurfaceGeometry_type;
extern entity* IfcConnectionVolumeGeometry_type;
extern entity* IfcConstraint_type;
extern entity* IfcConstructionEquipmentResource_type;
extern entity* IfcConstructionEquipmentResourceType_type;
extern entity* IfcConstructionMaterialResource_type;
extern entity* IfcConstructionMaterialResourceType_type;
extern entity* IfcConstructionProductResource_type;
extern entity* IfcConstructionProductResourceType_type;
extern entity* IfcConstructionResource_type;
extern entity* IfcConstructionResourceType_type;
extern entity* IfcContext_type;
extern entity* IfcContextDependentUnit_type;
extern entity* IfcControl_type;
extern entity* IfcController_type;
extern entity* IfcControllerType_type;
extern entity* IfcConversionBasedUnit_type;
extern entity* IfcConversionBasedUnitWithOffset_type;
extern entity* IfcCooledBeam_type;
extern entity* IfcCooledBeamType_type;
extern entity* IfcCoolingTower_type;
extern entity* IfcCoolingTowerType_type;
extern entity* IfcCoordinateOperation_type;
extern entity* IfcCoordinateReferenceSystem_type;
extern entity* IfcCostItem_type;
extern entity* IfcCostSchedule_type;
extern entity* IfcCostValue_type;
extern entity* IfcCovering_type;
extern entity* IfcCoveringType_type;
extern entity* IfcCrewResource_type;
extern entity* IfcCrewResourceType_type;
extern entity* IfcCsgPrimitive3D_type;
extern entity* IfcCsgSolid_type;
extern entity* IfcCurrencyRelationship_type;
extern entity* IfcCurtainWall_type;
extern entity* IfcCurtainWallType_type;
extern entity* IfcCurve_type;
extern entity* IfcCurveBoundedPlane_type;
extern entity* IfcCurveBoundedSurface_type;
extern entity* IfcCurveStyle_type;
extern entity* IfcCurveStyleFont_type;
extern entity* IfcCurveStyleFontAndScaling_type;
extern entity* IfcCurveStyleFontPattern_type;
extern entity* IfcCylindricalSurface_type;
extern entity* IfcDamper_type;
extern entity* IfcDamperType_type;
extern entity* IfcDerivedProfileDef_type;
extern entity* IfcDerivedUnit_type;
extern entity* IfcDerivedUnitElement_type;
extern entity* IfcDimensionalExponents_type;
extern entity* IfcDirection_type;
extern entity* IfcDiscreteAccessory_type;
extern entity* IfcDiscreteAccessoryType_type;
extern entity* IfcDistributionChamberElement_type;
extern entity* IfcDistributionChamberElementType_type;
extern entity* IfcDistributionCircuit_type;
extern entity* IfcDistributionControlElement_type;
extern entity* IfcDistributionControlElementType_type;
extern entity* IfcDistributionElement_type;
extern entity* IfcDistributionElementType_type;
extern entity* IfcDistributionFlowElement_type;
extern entity* IfcDistributionFlowElementType_type;
extern entity* IfcDistributionPort_type;
extern entity* IfcDistributionSystem_type;
extern entity* IfcDocumentInformation_type;
extern entity* IfcDocumentInformationRelationship_type;
extern entity* IfcDocumentReference_type;
extern entity* IfcDoor_type;
extern entity* IfcDoorLiningProperties_type;
extern entity* IfcDoorPanelProperties_type;
extern entity* IfcDoorStandardCase_type;
extern entity* IfcDoorStyle_type;
extern entity* IfcDoorType_type;
extern entity* IfcDraughtingPreDefinedColour_type;
extern entity* IfcDraughtingPreDefinedCurveFont_type;
extern entity* IfcDuctFitting_type;
extern entity* IfcDuctFittingType_type;
extern entity* IfcDuctSegment_type;
extern entity* IfcDuctSegmentType_type;
extern entity* IfcDuctSilencer_type;
extern entity* IfcDuctSilencerType_type;
extern entity* IfcEdge_type;
extern entity* IfcEdgeCurve_type;
extern entity* IfcEdgeLoop_type;
extern entity* IfcElectricAppliance_type;
extern entity* IfcElectricApplianceType_type;
extern entity* IfcElectricDistributionBoard_type;
extern entity* IfcElectricDistributionBoardType_type;
extern entity* IfcElectricFlowStorageDevice_type;
extern entity* IfcElectricFlowStorageDeviceType_type;
extern entity* IfcElectricGenerator_type;
extern entity* IfcElectricGeneratorType_type;
extern entity* IfcElectricMotor_type;
extern entity* IfcElectricMotorType_type;
extern entity* IfcElectricTimeControl_type;
extern entity* IfcElectricTimeControlType_type;
extern entity* IfcElement_type;
extern entity* IfcElementAssembly_type;
extern entity* IfcElementAssemblyType_type;
extern entity* IfcElementComponent_type;
extern entity* IfcElementComponentType_type;
extern entity* IfcElementQuantity_type;
extern entity* IfcElementType_type;
extern entity* IfcElementarySurface_type;
extern entity* IfcEllipse_type;
extern entity* IfcEllipseProfileDef_type;
extern entity* IfcEnergyConversionDevice_type;
extern entity* IfcEnergyConversionDeviceType_type;
extern entity* IfcEngine_type;
extern entity* IfcEngineType_type;
extern entity* IfcEvaporativeCooler_type;
extern entity* IfcEvaporativeCoolerType_type;
extern entity* IfcEvaporator_type;
extern entity* IfcEvaporatorType_type;
extern entity* IfcEvent_type;
extern entity* IfcEventTime_type;
extern entity* IfcEventType_type;
extern entity* IfcExtendedProperties_type;
extern entity* IfcExternalInformation_type;
extern entity* IfcExternalReference_type;
extern entity* IfcExternalReferenceRelationship_type;
extern entity* IfcExternalSpatialElement_type;
extern entity* IfcExternalSpatialStructureElement_type;
extern entity* IfcExternallyDefinedHatchStyle_type;
extern entity* IfcExternallyDefinedSurfaceStyle_type;
extern entity* IfcExternallyDefinedTextFont_type;
extern entity* IfcExtrudedAreaSolid_type;
extern entity* IfcExtrudedAreaSolidTapered_type;
extern entity* IfcFace_type;
extern entity* IfcFaceBasedSurfaceModel_type;
extern entity* IfcFaceBound_type;
extern entity* IfcFaceOuterBound_type;
extern entity* IfcFaceSurface_type;
extern entity* IfcFacetedBrep_type;
extern entity* IfcFacetedBrepWithVoids_type;
extern entity* IfcFailureConnectionCondition_type;
extern entity* IfcFan_type;
extern entity* IfcFanType_type;
extern entity* IfcFastener_type;
extern entity* IfcFastenerType_type;
extern entity* IfcFeatureElement_type;
extern entity* IfcFeatureElementAddition_type;
extern entity* IfcFeatureElementSubtraction_type;
extern entity* IfcFillAreaStyle_type;
extern entity* IfcFillAreaStyleHatching_type;
extern entity* IfcFillAreaStyleTiles_type;
extern entity* IfcFilter_type;
extern entity* IfcFilterType_type;
extern entity* IfcFireSuppressionTerminal_type;
extern entity* IfcFireSuppressionTerminalType_type;
extern entity* IfcFixedReferenceSweptAreaSolid_type;
extern entity* IfcFlowController_type;
extern entity* IfcFlowControllerType_type;
extern entity* IfcFlowFitting_type;
extern entity* IfcFlowFittingType_type;
extern entity* IfcFlowInstrument_type;
extern entity* IfcFlowInstrumentType_type;
extern entity* IfcFlowMeter_type;
extern entity* IfcFlowMeterType_type;
extern entity* IfcFlowMovingDevice_type;
extern entity* IfcFlowMovingDeviceType_type;
extern entity* IfcFlowSegment_type;
extern entity* IfcFlowSegmentType_type;
extern entity* IfcFlowStorageDevice_type;
extern entity* IfcFlowStorageDeviceType_type;
extern entity* IfcFlowTerminal_type;
extern entity* IfcFlowTerminalType_type;
extern entity* IfcFlowTreatmentDevice_type;
extern entity* IfcFlowTreatmentDeviceType_type;
extern entity* IfcFooting_type;
extern entity* IfcFootingType_type;
extern entity* IfcFurnishingElement_type;
extern entity* IfcFurnishingElementType_type;
extern entity* IfcFurniture_type;
extern entity* IfcFurnitureType_type;
extern entity* IfcGeographicElement_type;
extern entity* IfcGeographicElementType_type;
extern entity* IfcGeometricCurveSet_type;
extern entity* IfcGeometricRepresentationContext_type;
extern entity* IfcGeometricRepresentationItem_type;
extern entity* IfcGeometricRepresentationSubContext_type;
extern entity* IfcGeometricSet_type;
extern entity* IfcGrid_type;
extern entity* IfcGridAxis_type;
extern entity* IfcGridPlacement_type;
extern entity* IfcGroup_type;
extern entity* IfcHalfSpaceSolid_type;
extern entity* IfcHeatExchanger_type;
extern entity* IfcHeatExchangerType_type;
extern entity* IfcHumidifier_type;
extern entity* IfcHumidifierType_type;
extern entity* IfcIShapeProfileDef_type;
extern entity* IfcImageTexture_type;
extern entity* IfcIndexedColourMap_type;
extern entity* IfcIndexedPolyCurve_type;
extern entity* IfcIndexedTextureMap_type;
extern entity* IfcIndexedTriangleTextureMap_type;
extern entity* IfcInterceptor_type;
extern entity* IfcInterceptorType_type;
extern entity* IfcInventory_type;
extern entity* IfcIrregularTimeSeries_type;
extern entity* IfcIrregularTimeSeriesValue_type;
extern entity* IfcJunctionBox_type;
extern entity* IfcJunctionBoxType_type;
extern entity* IfcLShapeProfileDef_type;
extern entity* IfcLaborResource_type;
extern entity* IfcLaborResourceType_type;
extern entity* IfcLagTime_type;
extern entity* IfcLamp_type;
extern entity* IfcLampType_type;
extern entity* IfcLibraryInformation_type;
extern entity* IfcLibraryReference_type;
extern entity* IfcLightDistributionData_type;
extern entity* IfcLightFixture_type;
extern entity* IfcLightFixtureType_type;
extern entity* IfcLightIntensityDistribution_type;
extern entity* IfcLightSource_type;
extern entity* IfcLightSourceAmbient_type;
extern entity* IfcLightSourceDirectional_type;
extern entity* IfcLightSourceGoniometric_type;
extern entity* IfcLightSourcePositional_type;
extern entity* IfcLightSourceSpot_type;
extern entity* IfcLine_type;
extern entity* IfcLocalPlacement_type;
extern entity* IfcLoop_type;
extern entity* IfcManifoldSolidBrep_type;
extern entity* IfcMapConversion_type;
extern entity* IfcMappedItem_type;
extern entity* IfcMaterial_type;
extern entity* IfcMaterialClassificationRelationship_type;
extern entity* IfcMaterialConstituent_type;
extern entity* IfcMaterialConstituentSet_type;
extern entity* IfcMaterialDefinition_type;
extern entity* IfcMaterialDefinitionRepresentation_type;
extern entity* IfcMaterialLayer_type;
extern entity* IfcMaterialLayerSet_type;
extern entity* IfcMaterialLayerSetUsage_type;
extern entity* IfcMaterialLayerWithOffsets_type;
extern entity* IfcMaterialList_type;
extern entity* IfcMaterialProfile_type;
extern entity* IfcMaterialProfileSet_type;
extern entity* IfcMaterialProfileSetUsage_type;
extern entity* IfcMaterialProfileSetUsageTapering_type;
extern entity* IfcMaterialProfileWithOffsets_type;
extern entity* IfcMaterialProperties_type;
extern entity* IfcMaterialRelationship_type;
extern entity* IfcMaterialUsageDefinition_type;
extern entity* IfcMeasureWithUnit_type;
extern entity* IfcMechanicalFastener_type;
extern entity* IfcMechanicalFastenerType_type;
extern entity* IfcMedicalDevice_type;
extern entity* IfcMedicalDeviceType_type;
extern entity* IfcMember_type;
extern entity* IfcMemberStandardCase_type;
extern entity* IfcMemberType_type;
extern entity* IfcMetric_type;
extern entity* IfcMirroredProfileDef_type;
extern entity* IfcMonetaryUnit_type;
extern entity* IfcMotorConnection_type;
extern entity* IfcMotorConnectionType_type;
extern entity* IfcNamedUnit_type;
extern entity* IfcObject_type;
extern entity* IfcObjectDefinition_type;
extern entity* IfcObjectPlacement_type;
extern entity* IfcObjective_type;
extern entity* IfcOccupant_type;
extern entity* IfcOffsetCurve2D_type;
extern entity* IfcOffsetCurve3D_type;
extern entity* IfcOpenShell_type;
extern entity* IfcOpeningElement_type;
extern entity* IfcOpeningStandardCase_type;
extern entity* IfcOrganization_type;
extern entity* IfcOrganizationRelationship_type;
extern entity* IfcOrientedEdge_type;
extern entity* IfcOuterBoundaryCurve_type;
extern entity* IfcOutlet_type;
extern entity* IfcOutletType_type;
extern entity* IfcOwnerHistory_type;
extern entity* IfcParameterizedProfileDef_type;
extern entity* IfcPath_type;
extern entity* IfcPcurve_type;
extern entity* IfcPerformanceHistory_type;
extern entity* IfcPermeableCoveringProperties_type;
extern entity* IfcPermit_type;
extern entity* IfcPerson_type;
extern entity* IfcPersonAndOrganization_type;
extern entity* IfcPhysicalComplexQuantity_type;
extern entity* IfcPhysicalQuantity_type;
extern entity* IfcPhysicalSimpleQuantity_type;
extern entity* IfcPile_type;
extern entity* IfcPileType_type;
extern entity* IfcPipeFitting_type;
extern entity* IfcPipeFittingType_type;
extern entity* IfcPipeSegment_type;
extern entity* IfcPipeSegmentType_type;
extern entity* IfcPixelTexture_type;
extern entity* IfcPlacement_type;
extern entity* IfcPlanarBox_type;
extern entity* IfcPlanarExtent_type;
extern entity* IfcPlane_type;
extern entity* IfcPlate_type;
extern entity* IfcPlateStandardCase_type;
extern entity* IfcPlateType_type;
extern entity* IfcPoint_type;
extern entity* IfcPointOnCurve_type;
extern entity* IfcPointOnSurface_type;
extern entity* IfcPolyLoop_type;
extern entity* IfcPolygonalBoundedHalfSpace_type;
extern entity* IfcPolyline_type;
extern entity* IfcPort_type;
extern entity* IfcPostalAddress_type;
extern entity* IfcPreDefinedColour_type;
extern entity* IfcPreDefinedCurveFont_type;
extern entity* IfcPreDefinedItem_type;
extern entity* IfcPreDefinedProperties_type;
extern entity* IfcPreDefinedPropertySet_type;
extern entity* IfcPreDefinedTextFont_type;
extern entity* IfcPresentationItem_type;
extern entity* IfcPresentationLayerAssignment_type;
extern entity* IfcPresentationLayerWithStyle_type;
extern entity* IfcPresentationStyle_type;
extern entity* IfcPresentationStyleAssignment_type;
extern entity* IfcProcedure_type;
extern entity* IfcProcedureType_type;
extern entity* IfcProcess_type;
extern entity* IfcProduct_type;
extern entity* IfcProductDefinitionShape_type;
extern entity* IfcProductRepresentation_type;
extern entity* IfcProfileDef_type;
extern entity* IfcProfileProperties_type;
extern entity* IfcProject_type;
extern entity* IfcProjectLibrary_type;
extern entity* IfcProjectOrder_type;
extern entity* IfcProjectedCRS_type;
extern entity* IfcProjectionElement_type;
extern entity* IfcProperty_type;
extern entity* IfcPropertyAbstraction_type;
extern entity* IfcPropertyBoundedValue_type;
extern entity* IfcPropertyDefinition_type;
extern entity* IfcPropertyDependencyRelationship_type;
extern entity* IfcPropertyEnumeratedValue_type;
extern entity* IfcPropertyEnumeration_type;
extern entity* IfcPropertyListValue_type;
extern entity* IfcPropertyReferenceValue_type;
extern entity* IfcPropertySet_type;
extern entity* IfcPropertySetDefinition_type;
extern entity* IfcPropertySetTemplate_type;
extern entity* IfcPropertySingleValue_type;
extern entity* IfcPropertyTableValue_type;
extern entity* IfcPropertyTemplate_type;
extern entity* IfcPropertyTemplateDefinition_type;
extern entity* IfcProtectiveDevice_type;
extern entity* IfcProtectiveDeviceTrippingUnit_type;
extern entity* IfcProtectiveDeviceTrippingUnitType_type;
extern entity* IfcProtectiveDeviceType_type;
extern entity* IfcProxy_type;
extern entity* IfcPump_type;
extern entity* IfcPumpType_type;
extern entity* IfcQuantityArea_type;
extern entity* IfcQuantityCount_type;
extern entity* IfcQuantityLength_type;
extern entity* IfcQuantitySet_type;
extern entity* IfcQuantityTime_type;
extern entity* IfcQuantityVolume_type;
extern entity* IfcQuantityWeight_type;
extern entity* IfcRailing_type;
extern entity* IfcRailingType_type;
extern entity* IfcRamp_type;
extern entity* IfcRampFlight_type;
extern entity* IfcRampFlightType_type;
extern entity* IfcRampType_type;
extern entity* IfcRationalBSplineCurveWithKnots_type;
extern entity* IfcRationalBSplineSurfaceWithKnots_type;
extern entity* IfcRectangleHollowProfileDef_type;
extern entity* IfcRectangleProfileDef_type;
extern entity* IfcRectangularPyramid_type;
extern entity* IfcRectangularTrimmedSurface_type;
extern entity* IfcRecurrencePattern_type;
extern entity* IfcReference_type;
extern entity* IfcRegularTimeSeries_type;
extern entity* IfcReinforcementBarProperties_type;
extern entity* IfcReinforcementDefinitionProperties_type;
extern entity* IfcReinforcingBar_type;
extern entity* IfcReinforcingBarType_type;
extern entity* IfcReinforcingElement_type;
extern entity* IfcReinforcingElementType_type;
extern entity* IfcReinforcingMesh_type;
extern entity* IfcReinforcingMeshType_type;
extern entity* IfcRelAggregates_type;
extern entity* IfcRelAssigns_type;
extern entity* IfcRelAssignsToActor_type;
extern entity* IfcRelAssignsToControl_type;
extern entity* IfcRelAssignsToGroup_type;
extern entity* IfcRelAssignsToGroupByFactor_type;
extern entity* IfcRelAssignsToProcess_type;
extern entity* IfcRelAssignsToProduct_type;
extern entity* IfcRelAssignsToResource_type;
extern entity* IfcRelAssociates_type;
extern entity* IfcRelAssociatesApproval_type;
extern entity* IfcRelAssociatesClassification_type;
extern entity* IfcRelAssociatesConstraint_type;
extern entity* IfcRelAssociatesDocument_type;
extern entity* IfcRelAssociatesLibrary_type;
extern entity* IfcRelAssociatesMaterial_type;
extern entity* IfcRelConnects_type;
extern entity* IfcRelConnectsElements_type;
extern entity* IfcRelConnectsPathElements_type;
extern entity* IfcRelConnectsPortToElement_type;
extern entity* IfcRelConnectsPorts_type;
extern entity* IfcRelConnectsStructuralActivity_type;
extern entity* IfcRelConnectsStructuralMember_type;
extern entity* IfcRelConnectsWithEccentricity_type;
extern entity* IfcRelConnectsWithRealizingElements_type;
extern entity* IfcRelContainedInSpatialStructure_type;
extern entity* IfcRelCoversBldgElements_type;
extern entity* IfcRelCoversSpaces_type;
extern entity* IfcRelDeclares_type;
extern entity* IfcRelDecomposes_type;
extern entity* IfcRelDefines_type;
extern entity* IfcRelDefinesByObject_type;
extern entity* IfcRelDefinesByProperties_type;
extern entity* IfcRelDefinesByTemplate_type;
extern entity* IfcRelDefinesByType_type;
extern entity* IfcRelFillsElement_type;
extern entity* IfcRelFlowControlElements_type;
extern entity* IfcRelInterferesElements_type;
extern entity* IfcRelNests_type;
extern entity* IfcRelProjectsElement_type;
extern entity* IfcRelReferencedInSpatialStructure_type;
extern entity* IfcRelSequence_type;
extern entity* IfcRelServicesBuildings_type;
extern entity* IfcRelSpaceBoundary_type;
extern entity* IfcRelSpaceBoundary1stLevel_type;
extern entity* IfcRelSpaceBoundary2ndLevel_type;
extern entity* IfcRelVoidsElement_type;
extern entity* IfcRelationship_type;
extern entity* IfcReparametrisedCompositeCurveSegment_type;
extern entity* IfcRepresentation_type;
extern entity* IfcRepresentationContext_type;
extern entity* IfcRepresentationItem_type;
extern entity* IfcRepresentationMap_type;
extern entity* IfcResource_type;
extern entity* IfcResourceApprovalRelationship_type;
extern entity* IfcResourceConstraintRelationship_type;
extern entity* IfcResourceLevelRelationship_type;
extern entity* IfcResourceTime_type;
extern entity* IfcRevolvedAreaSolid_type;
extern entity* IfcRevolvedAreaSolidTapered_type;
extern entity* IfcRightCircularCone_type;
extern entity* IfcRightCircularCylinder_type;
extern entity* IfcRoof_type;
extern entity* IfcRoofType_type;
extern entity* IfcRoot_type;
extern entity* IfcRoundedRectangleProfileDef_type;
extern entity* IfcSIUnit_type;
extern entity* IfcSanitaryTerminal_type;
extern entity* IfcSanitaryTerminalType_type;
extern entity* IfcSchedulingTime_type;
extern entity* IfcSectionProperties_type;
extern entity* IfcSectionReinforcementProperties_type;
extern entity* IfcSectionedSpine_type;
extern entity* IfcSensor_type;
extern entity* IfcSensorType_type;
extern entity* IfcShadingDevice_type;
extern entity* IfcShadingDeviceType_type;
extern entity* IfcShapeAspect_type;
extern entity* IfcShapeModel_type;
extern entity* IfcShapeRepresentation_type;
extern entity* IfcShellBasedSurfaceModel_type;
extern entity* IfcSimpleProperty_type;
extern entity* IfcSimplePropertyTemplate_type;
extern entity* IfcSite_type;
extern entity* IfcSlab_type;
extern entity* IfcSlabElementedCase_type;
extern entity* IfcSlabStandardCase_type;
extern entity* IfcSlabType_type;
extern entity* IfcSlippageConnectionCondition_type;
extern entity* IfcSolarDevice_type;
extern entity* IfcSolarDeviceType_type;
extern entity* IfcSolidModel_type;
extern entity* IfcSpace_type;
extern entity* IfcSpaceHeater_type;
extern entity* IfcSpaceHeaterType_type;
extern entity* IfcSpaceType_type;
extern entity* IfcSpatialElement_type;
extern entity* IfcSpatialElementType_type;
extern entity* IfcSpatialStructureElement_type;
extern entity* IfcSpatialStructureElementType_type;
extern entity* IfcSpatialZone_type;
extern entity* IfcSpatialZoneType_type;
extern entity* IfcSphere_type;
extern entity* IfcStackTerminal_type;
extern entity* IfcStackTerminalType_type;
extern entity* IfcStair_type;
extern entity* IfcStairFlight_type;
extern entity* IfcStairFlightType_type;
extern entity* IfcStairType_type;
extern entity* IfcStructuralAction_type;
extern entity* IfcStructuralActivity_type;
extern entity* IfcStructuralAnalysisModel_type;
extern entity* IfcStructuralConnection_type;
extern entity* IfcStructuralConnectionCondition_type;
extern entity* IfcStructuralCurveAction_type;
extern entity* IfcStructuralCurveConnection_type;
extern entity* IfcStructuralCurveMember_type;
extern entity* IfcStructuralCurveMemberVarying_type;
extern entity* IfcStructuralCurveReaction_type;
extern entity* IfcStructuralItem_type;
extern entity* IfcStructuralLinearAction_type;
extern entity* IfcStructuralLoad_type;
extern entity* IfcStructuralLoadCase_type;
extern entity* IfcStructuralLoadConfiguration_type;
extern entity* IfcStructuralLoadGroup_type;
extern entity* IfcStructuralLoadLinearForce_type;
extern entity* IfcStructuralLoadOrResult_type;
extern entity* IfcStructuralLoadPlanarForce_type;
extern entity* IfcStructuralLoadSingleDisplacement_type;
extern entity* IfcStructuralLoadSingleDisplacementDistortion_type;
extern entity* IfcStructuralLoadSingleForce_type;
extern entity* IfcStructuralLoadSingleForceWarping_type;
extern entity* IfcStructuralLoadStatic_type;
extern entity* IfcStructuralLoadTemperature_type;
extern entity* IfcStructuralMember_type;
extern entity* IfcStructuralPlanarAction_type;
extern entity* IfcStructuralPointAction_type;
extern entity* IfcStructuralPointConnection_type;
extern entity* IfcStructuralPointReaction_type;
extern entity* IfcStructuralReaction_type;
extern entity* IfcStructuralResultGroup_type;
extern entity* IfcStructuralSurfaceAction_type;
extern entity* IfcStructuralSurfaceConnection_type;
extern entity* IfcStructuralSurfaceMember_type;
extern entity* IfcStructuralSurfaceMemberVarying_type;
extern entity* IfcStructuralSurfaceReaction_type;
extern entity* IfcStyleModel_type;
extern entity* IfcStyledItem_type;
extern entity* IfcStyledRepresentation_type;
extern entity* IfcSubContractResource_type;
extern entity* IfcSubContractResourceType_type;
extern entity* IfcSubedge_type;
extern entity* IfcSurface_type;
extern entity* IfcSurfaceCurveSweptAreaSolid_type;
extern entity* IfcSurfaceFeature_type;
extern entity* IfcSurfaceOfLinearExtrusion_type;
extern entity* IfcSurfaceOfRevolution_type;
extern entity* IfcSurfaceReinforcementArea_type;
extern entity* IfcSurfaceStyle_type;
extern entity* IfcSurfaceStyleLighting_type;
extern entity* IfcSurfaceStyleRefraction_type;
extern entity* IfcSurfaceStyleRendering_type;
extern entity* IfcSurfaceStyleShading_type;
extern entity* IfcSurfaceStyleWithTextures_type;
extern entity* IfcSurfaceTexture_type;
extern entity* IfcSweptAreaSolid_type;
extern entity* IfcSweptDiskSolid_type;
extern entity* IfcSweptDiskSolidPolygonal_type;
extern entity* IfcSweptSurface_type;
extern entity* IfcSwitchingDevice_type;
extern entity* IfcSwitchingDeviceType_type;
extern entity* IfcSystem_type;
extern entity* IfcSystemFurnitureElement_type;
extern entity* IfcSystemFurnitureElementType_type;
extern entity* IfcTShapeProfileDef_type;
extern entity* IfcTable_type;
extern entity* IfcTableColumn_type;
extern entity* IfcTableRow_type;
extern entity* IfcTank_type;
extern entity* IfcTankType_type;
extern entity* IfcTask_type;
extern entity* IfcTaskTime_type;
extern entity* IfcTaskTimeRecurring_type;
extern entity* IfcTaskType_type;
extern entity* IfcTelecomAddress_type;
extern entity* IfcTendon_type;
extern entity* IfcTendonAnchor_type;
extern entity* IfcTendonAnchorType_type;
extern entity* IfcTendonType_type;
extern entity* IfcTessellatedFaceSet_type;
extern entity* IfcTessellatedItem_type;
extern entity* IfcTextLiteral_type;
extern entity* IfcTextLiteralWithExtent_type;
extern entity* IfcTextStyle_type;
extern entity* IfcTextStyleFontModel_type;
extern entity* IfcTextStyleForDefinedFont_type;
extern entity* IfcTextStyleTextModel_type;
extern entity* IfcTextureCoordinate_type;
extern entity* IfcTextureCoordinateGenerator_type;
extern entity* IfcTextureMap_type;
extern entity* IfcTextureVertex_type;
extern entity* IfcTextureVertexList_type;
extern entity* IfcTimePeriod_type;
extern entity* IfcTimeSeries_type;
extern entity* IfcTimeSeriesValue_type;
extern entity* IfcTopologicalRepresentationItem_type;
extern entity* IfcTopologyRepresentation_type;
extern entity* IfcTransformer_type;
extern entity* IfcTransformerType_type;
extern entity* IfcTransportElement_type;
extern entity* IfcTransportElementType_type;
extern entity* IfcTrapeziumProfileDef_type;
extern entity* IfcTriangulatedFaceSet_type;
extern entity* IfcTrimmedCurve_type;
extern entity* IfcTubeBundle_type;
extern entity* IfcTubeBundleType_type;
extern entity* IfcTypeObject_type;
extern entity* IfcTypeProcess_type;
extern entity* IfcTypeProduct_type;
extern entity* IfcTypeResource_type;
extern entity* IfcUShapeProfileDef_type;
extern entity* IfcUnitAssignment_type;
extern entity* IfcUnitaryControlElement_type;
extern entity* IfcUnitaryControlElementType_type;
extern entity* IfcUnitaryEquipment_type;
extern entity* IfcUnitaryEquipmentType_type;
extern entity* IfcValve_type;
extern entity* IfcValveType_type;
extern entity* IfcVector_type;
extern entity* IfcVertex_type;
extern entity* IfcVertexLoop_type;
extern entity* IfcVertexPoint_type;
extern entity* IfcVibrationIsolator_type;
extern entity* IfcVibrationIsolatorType_type;
extern entity* IfcVirtualElement_type;
extern entity* IfcVirtualGridIntersection_type;
extern entity* IfcVoidingFeature_type;
extern entity* IfcWall_type;
extern entity* IfcWallElementedCase_type;
extern entity* IfcWallStandardCase_type;
extern entity* IfcWallType_type;
extern entity* IfcWasteTerminal_type;
extern entity* IfcWasteTerminalType_type;
extern entity* IfcWindow_type;
extern entity* IfcWindowLiningProperties_type;
extern entity* IfcWindowPanelProperties_type;
extern entity* IfcWindowStandardCase_type;
extern entity* IfcWindowStyle_type;
extern entity* IfcWindowType_type;
extern entity* IfcWorkCalendar_type;
extern entity* IfcWorkControl_type;
extern entity* IfcWorkPlan_type;
extern entity* IfcWorkSchedule_type;
extern entity* IfcWorkTime_type;
extern entity* IfcZShapeProfileDef_type;
extern entity* IfcZone_type;
extern type_declaration* IfcAbsorbedDoseMeasure_type;
extern type_declaration* IfcAccelerationMeasure_type;
extern type_declaration* IfcAmountOfSubstanceMeasure_type;
extern type_declaration* IfcAngularVelocityMeasure_type;
extern type_declaration* IfcArcIndex_type;
extern type_declaration* IfcAreaDensityMeasure_type;
extern type_declaration* IfcAreaMeasure_type;
extern type_declaration* IfcBinary_type;
extern type_declaration* IfcBoolean_type;
extern type_declaration* IfcBoxAlignment_type;
extern type_declaration* IfcCardinalPointReference_type;
extern type_declaration* IfcComplexNumber_type;
extern type_declaration* IfcCompoundPlaneAngleMeasure_type;
extern type_declaration* IfcContextDependentMeasure_type;
extern type_declaration* IfcCountMeasure_type;
extern type_declaration* IfcCurvatureMeasure_type;
extern type_declaration* IfcDate_type;
extern type_declaration* IfcDateTime_type;
extern type_declaration* IfcDayInMonthNumber_type;
extern type_declaration* IfcDayInWeekNumber_type;
extern type_declaration* IfcDescriptiveMeasure_type;
extern type_declaration* IfcDimensionCount_type;
extern type_declaration* IfcDoseEquivalentMeasure_type;
extern type_declaration* IfcDuration_type;
extern type_declaration* IfcDynamicViscosityMeasure_type;
extern type_declaration* IfcElectricCapacitanceMeasure_type;
extern type_declaration* IfcElectricChargeMeasure_type;
extern type_declaration* IfcElectricConductanceMeasure_type;
extern type_declaration* IfcElectricCurrentMeasure_type;
extern type_declaration* IfcElectricResistanceMeasure_type;
extern type_declaration* IfcElectricVoltageMeasure_type;
extern type_declaration* IfcEnergyMeasure_type;
extern type_declaration* IfcFontStyle_type;
extern type_declaration* IfcFontVariant_type;
extern type_declaration* IfcFontWeight_type;
extern type_declaration* IfcForceMeasure_type;
extern type_declaration* IfcFrequencyMeasure_type;
extern type_declaration* IfcGloballyUniqueId_type;
extern type_declaration* IfcHeatFluxDensityMeasure_type;
extern type_declaration* IfcHeatingValueMeasure_type;
extern type_declaration* IfcIdentifier_type;
extern type_declaration* IfcIlluminanceMeasure_type;
extern type_declaration* IfcInductanceMeasure_type;
extern type_declaration* IfcInteger_type;
extern type_declaration* IfcIntegerCountRateMeasure_type;
extern type_declaration* IfcIonConcentrationMeasure_type;
extern type_declaration* IfcIsothermalMoistureCapacityMeasure_type;
extern type_declaration* IfcKinematicViscosityMeasure_type;
extern type_declaration* IfcLabel_type;
extern type_declaration* IfcLanguageId_type;
extern type_declaration* IfcLengthMeasure_type;
extern type_declaration* IfcLineIndex_type;
extern type_declaration* IfcLinearForceMeasure_type;
extern type_declaration* IfcLinearMomentMeasure_type;
extern type_declaration* IfcLinearStiffnessMeasure_type;
extern type_declaration* IfcLinearVelocityMeasure_type;
extern type_declaration* IfcLogical_type;
extern type_declaration* IfcLuminousFluxMeasure_type;
extern type_declaration* IfcLuminousIntensityDistributionMeasure_type;
extern type_declaration* IfcLuminousIntensityMeasure_type;
extern type_declaration* IfcMagneticFluxDensityMeasure_type;
extern type_declaration* IfcMagneticFluxMeasure_type;
extern type_declaration* IfcMassDensityMeasure_type;
extern type_declaration* IfcMassFlowRateMeasure_type;
extern type_declaration* IfcMassMeasure_type;
extern type_declaration* IfcMassPerLengthMeasure_type;
extern type_declaration* IfcModulusOfElasticityMeasure_type;
extern type_declaration* IfcModulusOfLinearSubgradeReactionMeasure_type;
extern type_declaration* IfcModulusOfRotationalSubgradeReactionMeasure_type;
extern type_declaration* IfcModulusOfSubgradeReactionMeasure_type;
extern type_declaration* IfcMoistureDiffusivityMeasure_type;
extern type_declaration* IfcMolecularWeightMeasure_type;
extern type_declaration* IfcMomentOfInertiaMeasure_type;
extern type_declaration* IfcMonetaryMeasure_type;
extern type_declaration* IfcMonthInYearNumber_type;
extern type_declaration* IfcNonNegativeLengthMeasure_type;
extern type_declaration* IfcNormalisedRatioMeasure_type;
extern type_declaration* IfcNumericMeasure_type;
extern type_declaration* IfcPHMeasure_type;
extern type_declaration* IfcParameterValue_type;
extern type_declaration* IfcPlanarForceMeasure_type;
extern type_declaration* IfcPlaneAngleMeasure_type;
extern type_declaration* IfcPositiveInteger_type;
extern type_declaration* IfcPositiveLengthMeasure_type;
extern type_declaration* IfcPositivePlaneAngleMeasure_type;
extern type_declaration* IfcPositiveRatioMeasure_type;
extern type_declaration* IfcPowerMeasure_type;
extern type_declaration* IfcPresentableText_type;
extern type_declaration* IfcPressureMeasure_type;
extern type_declaration* IfcPropertySetDefinitionSet_type;
extern type_declaration* IfcRadioActivityMeasure_type;
extern type_declaration* IfcRatioMeasure_type;
extern type_declaration* IfcReal_type;
extern type_declaration* IfcRotationalFrequencyMeasure_type;
extern type_declaration* IfcRotationalMassMeasure_type;
extern type_declaration* IfcRotationalStiffnessMeasure_type;
extern type_declaration* IfcSectionModulusMeasure_type;
extern type_declaration* IfcSectionalAreaIntegralMeasure_type;
extern type_declaration* IfcShearModulusMeasure_type;
extern type_declaration* IfcSolidAngleMeasure_type;
extern type_declaration* IfcSoundPowerLevelMeasure_type;
extern type_declaration* IfcSoundPowerMeasure_type;
extern type_declaration* IfcSoundPressureLevelMeasure_type;
extern type_declaration* IfcSoundPressureMeasure_type;
extern type_declaration* IfcSpecificHeatCapacityMeasure_type;
extern type_declaration* IfcSpecularExponent_type;
extern type_declaration* IfcSpecularRoughness_type;
extern type_declaration* IfcStrippedOptional_type;
extern type_declaration* IfcTemperatureGradientMeasure_type;
extern type_declaration* IfcTemperatureRateOfChangeMeasure_type;
extern type_declaration* IfcText_type;
extern type_declaration* IfcTextAlignment_type;
extern type_declaration* IfcTextDecoration_type;
extern type_declaration* IfcTextFontName_type;
extern type_declaration* IfcTextTransformation_type;
extern type_declaration* IfcThermalAdmittanceMeasure_type;
extern type_declaration* IfcThermalConductivityMeasure_type;
extern type_declaration* IfcThermalExpansionCoefficientMeasure_type;
extern type_declaration* IfcThermalResistanceMeasure_type;
extern type_declaration* IfcThermalTransmittanceMeasure_type;
extern type_declaration* IfcThermodynamicTemperatureMeasure_type;
extern type_declaration* IfcTime_type;
extern type_declaration* IfcTimeMeasure_type;
extern type_declaration* IfcTimeStamp_type;
extern type_declaration* IfcTorqueMeasure_type;
extern type_declaration* IfcURIReference_type;
extern type_declaration* IfcVaporPermeabilityMeasure_type;
extern type_declaration* IfcVolumeMeasure_type;
extern type_declaration* IfcVolumetricFlowRateMeasure_type;
extern type_declaration* IfcWarpingConstantMeasure_type;
extern type_declaration* IfcWarpingMomentMeasure_type;

const std::string& Type::ToString(Enum v) {
    if (v < 0 || v >= 1165) throw IfcException("Unable to find find keyword in schema");
    static std::string names[] = { "IfcAbsorbedDoseMeasure", "IfcAccelerationMeasure", "IfcActionRequest", "IfcActionRequestTypeEnum", "IfcActionSourceTypeEnum", "IfcActionTypeEnum", "IfcActor", "IfcActorRole", "IfcActorSelect", "IfcActuator", "IfcActuatorType", "IfcActuatorTypeEnum", "IfcAddress", "IfcAddressTypeEnum", "IfcAdvancedBrep", "IfcAdvancedBrepWithVoids", "IfcAdvancedFace", "IfcAirTerminal", "IfcAirTerminalBox", "IfcAirTerminalBoxType", "IfcAirTerminalBoxTypeEnum", "IfcAirTerminalType", "IfcAirTerminalTypeEnum", "IfcAirToAirHeatRecovery", "IfcAirToAirHeatRecoveryType", "IfcAirToAirHeatRecoveryTypeEnum", "IfcAlarm", "IfcAlarmType", "IfcAlarmTypeEnum", "IfcAmountOfSubstanceMeasure", "IfcAnalysisModelTypeEnum", "IfcAnalysisTheoryTypeEnum", "IfcAngularVelocityMeasure", "IfcAnnotation", "IfcAnnotationFillArea", "IfcApplication", "IfcAppliedValue", "IfcAppliedValueSelect", "IfcApproval", "IfcApprovalRelationship", "IfcArbitraryClosedProfileDef", "IfcArbitraryOpenProfileDef", "IfcArbitraryProfileDefWithVoids", "IfcArcIndex", "IfcAreaDensityMeasure", "IfcAreaMeasure", "IfcArithmeticOperatorEnum", "IfcAssemblyPlaceEnum", "IfcAsset", "IfcAsymmetricIShapeProfileDef", "IfcAudioVisualAppliance", "IfcAudioVisualApplianceType", "IfcAudioVisualApplianceTypeEnum", "IfcAxis1Placement", "IfcAxis2Placement", "IfcAxis2Placement2D", "IfcAxis2Placement3D", "IfcBSplineCurve", "IfcBSplineCurveForm", "IfcBSplineCurveWithKnots", "IfcBSplineSurface", "IfcBSplineSurfaceForm", "IfcBSplineSurfaceWithKnots", "IfcBeam", "IfcBeamStandardCase", "IfcBeamType", "IfcBeamTypeEnum", "IfcBenchmarkEnum", "IfcBendingParameterSelect", "IfcBinary", "IfcBlobTexture", "IfcBlock", "IfcBoiler", "IfcBoilerType", "IfcBoilerTypeEnum", "IfcBoolean", "IfcBooleanClippingResult", "IfcBooleanOperand", "IfcBooleanOperator", "IfcBooleanResult", "IfcBoundaryCondition", "IfcBoundaryCurve", "IfcBoundaryEdgeCondition", "IfcBoundaryFaceCondition", "IfcBoundaryNodeCondition", "IfcBoundaryNodeConditionWarping", "IfcBoundedCurve", "IfcBoundedSurface", "IfcBoundingBox", "IfcBoxAlignment", "IfcBoxedHalfSpace", "IfcBuilding", "IfcBuildingElement", "IfcBuildingElementPart", "IfcBuildingElementPartType", "IfcBuildingElementPartTypeEnum", "IfcBuildingElementProxy", "IfcBuildingElementProxyType", "IfcBuildingElementProxyTypeEnum", "IfcBuildingElementType", "IfcBuildingStorey", "IfcBuildingSystem", "IfcBuildingSystemTypeEnum", "IfcBurner", "IfcBurnerType", "IfcBurnerTypeEnum", "IfcCShapeProfileDef", "IfcCableCarrierFitting", "IfcCableCarrierFittingType", "IfcCableCarrierFittingTypeEnum", "IfcCableCarrierSegment", "IfcCableCarrierSegmentType", "IfcCableCarrierSegmentTypeEnum", "IfcCableFitting", "IfcCableFittingType", "IfcCableFittingTypeEnum", "IfcCableSegment", "IfcCableSegmentType", "IfcCableSegmentTypeEnum", "IfcCardinalPointReference", "IfcCartesianPoint", "IfcCartesianPointList", "IfcCartesianPointList2D", "IfcCartesianPointList3D", "IfcCartesianTransformationOperator", "IfcCartesianTransformationOperator2D", "IfcCartesianTransformationOperator2DnonUniform", "IfcCartesianTransformationOperator3D", "IfcCartesianTransformationOperator3DnonUniform", "IfcCenterLineProfileDef", "IfcChangeActionEnum", "IfcChiller", "IfcChillerType", "IfcChillerTypeEnum", "IfcChimney", "IfcChimneyType", "IfcChimneyTypeEnum", "IfcCircle", "IfcCircleHollowProfileDef", "IfcCircleProfileDef", "IfcCivilElement", "IfcCivilElementType", "IfcClassification", "IfcClassificationReference", "IfcClassificationReferenceSelect", "IfcClassificationSelect", "IfcClosedShell", "IfcCoil", "IfcCoilType", "IfcCoilTypeEnum", "IfcColour", "IfcColourOrFactor", "IfcColourRgb", "IfcColourRgbList", "IfcColourSpecification", "IfcColumn", "IfcColumnStandardCase", "IfcColumnType", "IfcColumnTypeEnum", "IfcCommunicationsAppliance", "IfcCommunicationsApplianceType", "IfcCommunicationsApplianceTypeEnum", "IfcComplexNumber", "IfcComplexProperty", "IfcComplexPropertyTemplate", "IfcComplexPropertyTemplateTypeEnum", "IfcCompositeCurve", "IfcCompositeCurveOnSurface", "IfcCompositeCurveSegment", "IfcCompositeProfileDef", "IfcCompoundPlaneAngleMeasure", "IfcCompressor", "IfcCompressorType", "IfcCompressorTypeEnum", "IfcCondenser", "IfcCondenserType", "IfcCondenserTypeEnum", "IfcConic", "IfcConnectedFaceSet", "IfcConnectionCurveGeometry", "IfcConnectionGeometry", "IfcConnectionPointEccentricity", "IfcConnectionPointGeometry", "IfcConnectionSurfaceGeometry", "IfcConnectionTypeEnum", "IfcConnectionVolumeGeometry", "IfcConstraint", "IfcConstraintEnum", "IfcConstructionEquipmentResource", "IfcConstructionEquipmentResourceType", "IfcConstructionEquipmentResourceTypeEnum", "IfcConstructionMaterialResource", "IfcConstructionMaterialResourceType", "IfcConstructionMaterialResourceTypeEnum", "IfcConstructionProductResource", "IfcConstructionProductResourceType", "IfcConstructionProductResourceTypeEnum", "IfcConstructionResource", "IfcConstructionResourceType", "IfcContext", "IfcContextDependentMeasure", "IfcContextDependentUnit", "IfcControl", "IfcController", "IfcControllerType", "IfcControllerTypeEnum", "IfcConversionBasedUnit", "IfcConversionBasedUnitWithOffset", "IfcCooledBeam", "IfcCooledBeamType", "IfcCooledBeamTypeEnum", "IfcCoolingTower", "IfcCoolingTowerType", "IfcCoolingTowerTypeEnum", "IfcCoordinateOperation", "IfcCoordinateReferenceSystem", "IfcCoordinateReferenceSystemSelect", "IfcCostItem", "IfcCostItemTypeEnum", "IfcCostSchedule", "IfcCostScheduleTypeEnum", "IfcCostValue", "IfcCountMeasure", "IfcCovering", "IfcCoveringType", "IfcCoveringTypeEnum", "IfcCrewResource", "IfcCrewResourceType", "IfcCrewResourceTypeEnum", "IfcCsgPrimitive3D", "IfcCsgSelect", "IfcCsgSolid", "IfcCurrencyRelationship", "IfcCurtainWall", "IfcCurtainWallType", "IfcCurtainWallTypeEnum", "IfcCurvatureMeasure", "IfcCurve", "IfcCurveBoundedPlane", "IfcCurveBoundedSurface", "IfcCurveFontOrScaledCurveFontSelect", "IfcCurveInterpolationEnum", "IfcCurveOnSurface", "IfcCurveOrEdgeCurve", "IfcCurveStyle", "IfcCurveStyleFont", "IfcCurveStyleFontAndScaling", "IfcCurveStyleFontPattern", "IfcCurveStyleFontSelect", "IfcCylindricalSurface", "IfcDamper", "IfcDamperType", "IfcDamperTypeEnum", "IfcDataOriginEnum", "IfcDate", "IfcDateTime", "IfcDayInMonthNumber", "IfcDayInWeekNumber", "IfcDefinitionSelect", "IfcDerivedMeasureValue", "IfcDerivedProfileDef", "IfcDerivedUnit", "IfcDerivedUnitElement", "IfcDerivedUnitEnum", "IfcDescriptiveMeasure", "IfcDimensionCount", "IfcDimensionalExponents", "IfcDirection", "IfcDirectionSenseEnum", "IfcDiscreteAccessory", "IfcDiscreteAccessoryType", "IfcDiscreteAccessoryTypeEnum", "IfcDistributionChamberElement", "IfcDistributionChamberElementType", "IfcDistributionChamberElementTypeEnum", "IfcDistributionCircuit", "IfcDistributionControlElement", "IfcDistributionControlElementType", "IfcDistributionElement", "IfcDistributionElementType", "IfcDistributionFlowElement", "IfcDistributionFlowElementType", "IfcDistributionPort", "IfcDistributionPortTypeEnum", "IfcDistributionSystem", "IfcDistributionSystemEnum", "IfcDocumentConfidentialityEnum", "IfcDocumentInformation", "IfcDocumentInformationRelationship", "IfcDocumentReference", "IfcDocumentSelect", "IfcDocumentStatusEnum", "IfcDoor", "IfcDoorLiningProperties", "IfcDoorPanelOperationEnum", "IfcDoorPanelPositionEnum", "IfcDoorPanelProperties", "IfcDoorStandardCase", "IfcDoorStyle", "IfcDoorStyleConstructionEnum", "IfcDoorStyleOperationEnum", "IfcDoorType", "IfcDoorTypeEnum", "IfcDoorTypeOperationEnum", "IfcDoseEquivalentMeasure", "IfcDraughtingPreDefinedColour", "IfcDraughtingPreDefinedCurveFont", "IfcDuctFitting", "IfcDuctFittingType", "IfcDuctFittingTypeEnum", "IfcDuctSegment", "IfcDuctSegmentType", "IfcDuctSegmentTypeEnum", "IfcDuctSilencer", "IfcDuctSilencerType", "IfcDuctSilencerTypeEnum", "IfcDuration", "IfcDynamicViscosityMeasure", "IfcEdge", "IfcEdgeCurve", "IfcEdgeLoop", "IfcElectricAppliance", "IfcElectricApplianceType", "IfcElectricApplianceTypeEnum", "IfcElectricCapacitanceMeasure", "IfcElectricChargeMeasure", "IfcElectricConductanceMeasure", "IfcElectricCurrentMeasure", "IfcElectricDistributionBoard", "IfcElectricDistributionBoardType", "IfcElectricDistributionBoardTypeEnum", "IfcElectricFlowStorageDevice", "IfcElectricFlowStorageDeviceType", "IfcElectricFlowStorageDeviceTypeEnum", "IfcElectricGenerator", "IfcElectricGeneratorType", "IfcElectricGeneratorTypeEnum", "IfcElectricMotor", "IfcElectricMotorType", "IfcElectricMotorTypeEnum", "IfcElectricResistanceMeasure", "IfcElectricTimeControl", "IfcElectricTimeControlType", "IfcElectricTimeControlTypeEnum", "IfcElectricVoltageMeasure", "IfcElement", "IfcElementAssembly", "IfcElementAssemblyType", "IfcElementAssemblyTypeEnum", "IfcElementComponent", "IfcElementComponentType", "IfcElementCompositionEnum", "IfcElementQuantity", "IfcElementType", "IfcElementarySurface", "IfcEllipse", "IfcEllipseProfileDef", "IfcEnergyConversionDevice", "IfcEnergyConversionDeviceType", "IfcEnergyMeasure", "IfcEngine", "IfcEngineType", "IfcEngineTypeEnum", "IfcEvaporativeCooler", "IfcEvaporativeCoolerType", "IfcEvaporativeCoolerTypeEnum", "IfcEvaporator", "IfcEvaporatorType", "IfcEvaporatorTypeEnum", "IfcEvent", "IfcEventTime", "IfcEventTriggerTypeEnum", "IfcEventType", "IfcEventTypeEnum", "IfcExtendedProperties", "IfcExternalInformation", "IfcExternalReference", "IfcExternalReferenceRelationship", "IfcExternalSpatialElement", "IfcExternalSpatialElementTypeEnum", "IfcExternalSpatialStructureElement", "IfcExternallyDefinedHatchStyle", "IfcExternallyDefinedSurfaceStyle", "IfcExternallyDefinedTextFont", "IfcExtrudedAreaSolid", "IfcExtrudedAreaSolidTapered", "IfcFace", "IfcFaceBasedSurfaceModel", "IfcFaceBound", "IfcFaceOuterBound", "IfcFaceSurface", "IfcFacetedBrep", "IfcFacetedBrepWithVoids", "IfcFailureConnectionCondition", "IfcFan", "IfcFanType", "IfcFanTypeEnum", "IfcFastener", "IfcFastenerType", "IfcFastenerTypeEnum", "IfcFeatureElement", "IfcFeatureElementAddition", "IfcFeatureElementSubtraction", "IfcFillAreaStyle", "IfcFillAreaStyleHatching", "IfcFillAreaStyleTiles", "IfcFillStyleSelect", "IfcFilter", "IfcFilterType", "IfcFilterTypeEnum", "IfcFireSuppressionTerminal", "IfcFireSuppressionTerminalType", "IfcFireSuppressionTerminalTypeEnum", "IfcFixedReferenceSweptAreaSolid", "IfcFlowController", "IfcFlowControllerType", "IfcFlowDirectionEnum", "IfcFlowFitting", "IfcFlowFittingType", "IfcFlowInstrument", "IfcFlowInstrumentType", "IfcFlowInstrumentTypeEnum", "IfcFlowMeter", "IfcFlowMeterType", "IfcFlowMeterTypeEnum", "IfcFlowMovingDevice", "IfcFlowMovingDeviceType", "IfcFlowSegment", "IfcFlowSegmentType", "IfcFlowStorageDevice", "IfcFlowStorageDeviceType", "IfcFlowTerminal", "IfcFlowTerminalType", "IfcFlowTreatmentDevice", "IfcFlowTreatmentDeviceType", "IfcFontStyle", "IfcFontVariant", "IfcFontWeight", "IfcFooting", "IfcFootingType", "IfcFootingTypeEnum", "IfcForceMeasure", "IfcFrequencyMeasure", "IfcFurnishingElement", "IfcFurnishingElementType", "IfcFurniture", "IfcFurnitureType", "IfcFurnitureTypeEnum", "IfcGeographicElement", "IfcGeographicElementType", "IfcGeographicElementTypeEnum", "IfcGeometricCurveSet", "IfcGeometricProjectionEnum", "IfcGeometricRepresentationContext", "IfcGeometricRepresentationItem", "IfcGeometricRepresentationSubContext", "IfcGeometricSet", "IfcGeometricSetSelect", "IfcGlobalOrLocalEnum", "IfcGloballyUniqueId", "IfcGrid", "IfcGridAxis", "IfcGridPlacement", "IfcGridPlacementDirectionSelect", "IfcGridTypeEnum", "IfcGroup", "IfcHalfSpaceSolid", "IfcHatchLineDistanceSelect", "IfcHeatExchanger", "IfcHeatExchangerType", "IfcHeatExchangerTypeEnum", "IfcHeatFluxDensityMeasure", "IfcHeatingValueMeasure", "IfcHumidifier", "IfcHumidifierType", "IfcHumidifierTypeEnum", "IfcIShapeProfileDef", "IfcIdentifier", "IfcIlluminanceMeasure", "IfcImageTexture", "IfcIndexedColourMap", "IfcIndexedPolyCurve", "IfcIndexedTextureMap", "IfcIndexedTriangleTextureMap", "IfcInductanceMeasure", "IfcInteger", "IfcIntegerCountRateMeasure", "IfcInterceptor", "IfcInterceptorType", "IfcInterceptorTypeEnum", "IfcInternalOrExternalEnum", "IfcInventory", "IfcInventoryTypeEnum", "IfcIonConcentrationMeasure", "IfcIrregularTimeSeries", "IfcIrregularTimeSeriesValue", "IfcIsothermalMoistureCapacityMeasure", "IfcJunctionBox", "IfcJunctionBoxType", "IfcJunctionBoxTypeEnum", "IfcKinematicViscosityMeasure", "IfcKnotType", "IfcLShapeProfileDef", "IfcLabel", "IfcLaborResource", "IfcLaborResourceType", "IfcLaborResourceTypeEnum", "IfcLagTime", "IfcLamp", "IfcLampType", "IfcLampTypeEnum", "IfcLanguageId", "IfcLayerSetDirectionEnum", "IfcLayeredItem", "IfcLengthMeasure", "IfcLibraryInformation", "IfcLibraryReference", "IfcLibrarySelect", "IfcLightDistributionCurveEnum", "IfcLightDistributionData", "IfcLightDistributionDataSourceSelect", "IfcLightEmissionSourceEnum", "IfcLightFixture", "IfcLightFixtureType", "IfcLightFixtureTypeEnum", "IfcLightIntensityDistribution", "IfcLightSource", "IfcLightSourceAmbient", "IfcLightSourceDirectional", "IfcLightSourceGoniometric", "IfcLightSourcePositional", "IfcLightSourceSpot", "IfcLine", "IfcLineIndex", "IfcLinearForceMeasure", "IfcLinearMomentMeasure", "IfcLinearStiffnessMeasure", "IfcLinearVelocityMeasure", "IfcLoadGroupTypeEnum", "IfcLocalPlacement", "IfcLogical", "IfcLogicalOperatorEnum", "IfcLoop", "IfcLuminousFluxMeasure", "IfcLuminousIntensityDistributionMeasure", "IfcLuminousIntensityMeasure", "IfcMagneticFluxDensityMeasure", "IfcMagneticFluxMeasure", "IfcManifoldSolidBrep", "IfcMapConversion", "IfcMappedItem", "IfcMassDensityMeasure", "IfcMassFlowRateMeasure", "IfcMassMeasure", "IfcMassPerLengthMeasure", "IfcMaterial", "IfcMaterialClassificationRelationship", "IfcMaterialConstituent", "IfcMaterialConstituentSet", "IfcMaterialDefinition", "IfcMaterialDefinitionRepresentation", "IfcMaterialLayer", "IfcMaterialLayerSet", "IfcMaterialLayerSetUsage", "IfcMaterialLayerWithOffsets", "IfcMaterialList", "IfcMaterialProfile", "IfcMaterialProfileSet", "IfcMaterialProfileSetUsage", "IfcMaterialProfileSetUsageTapering", "IfcMaterialProfileWithOffsets", "IfcMaterialProperties", "IfcMaterialRelationship", "IfcMaterialSelect", "IfcMaterialUsageDefinition", "IfcMeasureValue", "IfcMeasureWithUnit", "IfcMechanicalFastener", "IfcMechanicalFastenerType", "IfcMechanicalFastenerTypeEnum", "IfcMedicalDevice", "IfcMedicalDeviceType", "IfcMedicalDeviceTypeEnum", "IfcMember", "IfcMemberStandardCase", "IfcMemberType", "IfcMemberTypeEnum", "IfcMetric", "IfcMetricValueSelect", "IfcMirroredProfileDef", "IfcModulusOfElasticityMeasure", "IfcModulusOfLinearSubgradeReactionMeasure", "IfcModulusOfRotationalSubgradeReactionMeasure", "IfcModulusOfRotationalSubgradeReactionSelect", "IfcModulusOfSubgradeReactionMeasure", "IfcModulusOfSubgradeReactionSelect", "IfcModulusOfTranslationalSubgradeReactionSelect", "IfcMoistureDiffusivityMeasure", "IfcMolecularWeightMeasure", "IfcMomentOfInertiaMeasure", "IfcMonetaryMeasure", "IfcMonetaryUnit", "IfcMonthInYearNumber", "IfcMotorConnection", "IfcMotorConnectionType", "IfcMotorConnectionTypeEnum", "IfcNamedUnit", "IfcNonNegativeLengthMeasure", "IfcNormalisedRatioMeasure", "IfcNullStyle", "IfcNumericMeasure", "IfcObject", "IfcObjectDefinition", "IfcObjectPlacement", "IfcObjectReferenceSelect", "IfcObjectTypeEnum", "IfcObjective", "IfcObjectiveEnum", "IfcOccupant", "IfcOccupantTypeEnum", "IfcOffsetCurve2D", "IfcOffsetCurve3D", "IfcOpenShell", "IfcOpeningElement", "IfcOpeningElementTypeEnum", "IfcOpeningStandardCase", "IfcOrganization", "IfcOrganizationRelationship", "IfcOrientedEdge", "IfcOuterBoundaryCurve", "IfcOutlet", "IfcOutletType", "IfcOutletTypeEnum", "IfcOwnerHistory", "IfcPHMeasure", "IfcParameterValue", "IfcParameterizedProfileDef", "IfcPath", "IfcPcurve", "IfcPerformanceHistory", "IfcPerformanceHistoryTypeEnum", "IfcPermeableCoveringOperationEnum", "IfcPermeableCoveringProperties", "IfcPermit", "IfcPermitTypeEnum", "IfcPerson", "IfcPersonAndOrganization", "IfcPhysicalComplexQuantity", "IfcPhysicalOrVirtualEnum", "IfcPhysicalQuantity", "IfcPhysicalSimpleQuantity", "IfcPile", "IfcPileConstructionEnum", "IfcPileType", "IfcPileTypeEnum", "IfcPipeFitting", "IfcPipeFittingType", "IfcPipeFittingTypeEnum", "IfcPipeSegment", "IfcPipeSegmentType", "IfcPipeSegmentTypeEnum", "IfcPixelTexture", "IfcPlacement", "IfcPlanarBox", "IfcPlanarExtent", "IfcPlanarForceMeasure", "IfcPlane", "IfcPlaneAngleMeasure", "IfcPlate", "IfcPlateStandardCase", "IfcPlateType", "IfcPlateTypeEnum", "IfcPoint", "IfcPointOnCurve", "IfcPointOnSurface", "IfcPointOrVertexPoint", "IfcPolyLoop", "IfcPolygonalBoundedHalfSpace", "IfcPolyline", "IfcPort", "IfcPositiveInteger", "IfcPositiveLengthMeasure", "IfcPositivePlaneAngleMeasure", "IfcPositiveRatioMeasure", "IfcPostalAddress", "IfcPowerMeasure", "IfcPreDefinedColour", "IfcPreDefinedCurveFont", "IfcPreDefinedItem", "IfcPreDefinedProperties", "IfcPreDefinedPropertySet", "IfcPreDefinedTextFont", "IfcPresentableText", "IfcPresentationItem", "IfcPresentationLayerAssignment", "IfcPresentationLayerWithStyle", "IfcPresentationStyle", "IfcPresentationStyleAssignment", "IfcPresentationStyleSelect", "IfcPressureMeasure", "IfcProcedure", "IfcProcedureType", "IfcProcedureTypeEnum", "IfcProcess", "IfcProcessSelect", "IfcProduct", "IfcProductDefinitionShape", "IfcProductRepresentation", "IfcProductRepresentationSelect", "IfcProductSelect", "IfcProfileDef", "IfcProfileProperties", "IfcProfileTypeEnum", "IfcProject", "IfcProjectLibrary", "IfcProjectOrder", "IfcProjectOrderTypeEnum", "IfcProjectedCRS", "IfcProjectedOrTrueLengthEnum", "IfcProjectionElement", "IfcProjectionElementTypeEnum", "IfcProperty", "IfcPropertyAbstraction", "IfcPropertyBoundedValue", "IfcPropertyDefinition", "IfcPropertyDependencyRelationship", "IfcPropertyEnumeratedValue", "IfcPropertyEnumeration", "IfcPropertyListValue", "IfcPropertyReferenceValue", "IfcPropertySet", "IfcPropertySetDefinition", "IfcPropertySetDefinitionSelect", "IfcPropertySetDefinitionSet", "IfcPropertySetTemplate", "IfcPropertySetTemplateTypeEnum", "IfcPropertySingleValue", "IfcPropertyTableValue", "IfcPropertyTemplate", "IfcPropertyTemplateDefinition", "IfcProtectiveDevice", "IfcProtectiveDeviceTrippingUnit", "IfcProtectiveDeviceTrippingUnitType", "IfcProtectiveDeviceTrippingUnitTypeEnum", "IfcProtectiveDeviceType", "IfcProtectiveDeviceTypeEnum", "IfcProxy", "IfcPump", "IfcPumpType", "IfcPumpTypeEnum", "IfcQuantityArea", "IfcQuantityCount", "IfcQuantityLength", "IfcQuantitySet", "IfcQuantityTime", "IfcQuantityVolume", "IfcQuantityWeight", "IfcRadioActivityMeasure", "IfcRailing", "IfcRailingType", "IfcRailingTypeEnum", "IfcRamp", "IfcRampFlight", "IfcRampFlightType", "IfcRampFlightTypeEnum", "IfcRampType", "IfcRampTypeEnum", "IfcRatioMeasure", "IfcRationalBSplineCurveWithKnots", "IfcRationalBSplineSurfaceWithKnots", "IfcReal", "IfcRectangleHollowProfileDef", "IfcRectangleProfileDef", "IfcRectangularPyramid", "IfcRectangularTrimmedSurface", "IfcRecurrencePattern", "IfcRecurrenceTypeEnum", "IfcReference", "IfcReflectanceMethodEnum", "IfcRegularTimeSeries", "IfcReinforcementBarProperties", "IfcReinforcementDefinitionProperties", "IfcReinforcingBar", "IfcReinforcingBarRoleEnum", "IfcReinforcingBarSurfaceEnum", "IfcReinforcingBarType", "IfcReinforcingBarTypeEnum", "IfcReinforcingElement", "IfcReinforcingElementType", "IfcReinforcingMesh", "IfcReinforcingMeshType", "IfcReinforcingMeshTypeEnum", "IfcRelAggregates", "IfcRelAssigns", "IfcRelAssignsToActor", "IfcRelAssignsToControl", "IfcRelAssignsToGroup", "IfcRelAssignsToGroupByFactor", "IfcRelAssignsToProcess", "IfcRelAssignsToProduct", "IfcRelAssignsToResource", "IfcRelAssociates", "IfcRelAssociatesApproval", "IfcRelAssociatesClassification", "IfcRelAssociatesConstraint", "IfcRelAssociatesDocument", "IfcRelAssociatesLibrary", "IfcRelAssociatesMaterial", "IfcRelConnects", "IfcRelConnectsElements", "IfcRelConnectsPathElements", "IfcRelConnectsPortToElement", "IfcRelConnectsPorts", "IfcRelConnectsStructuralActivity", "IfcRelConnectsStructuralMember", "IfcRelConnectsWithEccentricity", "IfcRelConnectsWithRealizingElements", "IfcRelContainedInSpatialStructure", "IfcRelCoversBldgElements", "IfcRelCoversSpaces", "IfcRelDeclares", "IfcRelDecomposes", "IfcRelDefines", "IfcRelDefinesByObject", "IfcRelDefinesByProperties", "IfcRelDefinesByTemplate", "IfcRelDefinesByType", "IfcRelFillsElement", "IfcRelFlowControlElements", "IfcRelInterferesElements", "IfcRelNests", "IfcRelProjectsElement", "IfcRelReferencedInSpatialStructure", "IfcRelSequence", "IfcRelServicesBuildings", "IfcRelSpaceBoundary", "IfcRelSpaceBoundary1stLevel", "IfcRelSpaceBoundary2ndLevel", "IfcRelVoidsElement", "IfcRelationship", "IfcReparametrisedCompositeCurveSegment", "IfcRepresentation", "IfcRepresentationContext", "IfcRepresentationItem", "IfcRepresentationMap", "IfcResource", "IfcResourceApprovalRelationship", "IfcResourceConstraintRelationship", "IfcResourceLevelRelationship", "IfcResourceObjectSelect", "IfcResourceSelect", "IfcResourceTime", "IfcRevolvedAreaSolid", "IfcRevolvedAreaSolidTapered", "IfcRightCircularCone", "IfcRightCircularCylinder", "IfcRoleEnum", "IfcRoof", "IfcRoofType", "IfcRoofTypeEnum", "IfcRoot", "IfcRotationalFrequencyMeasure", "IfcRotationalMassMeasure", "IfcRotationalStiffnessMeasure", "IfcRotationalStiffnessSelect", "IfcRoundedRectangleProfileDef", "IfcSIPrefix", "IfcSIUnit", "IfcSIUnitName", "IfcSanitaryTerminal", "IfcSanitaryTerminalType", "IfcSanitaryTerminalTypeEnum", "IfcSchedulingTime", "IfcSectionModulusMeasure", "IfcSectionProperties", "IfcSectionReinforcementProperties", "IfcSectionTypeEnum", "IfcSectionalAreaIntegralMeasure", "IfcSectionedSpine", "IfcSegmentIndexSelect", "IfcSensor", "IfcSensorType", "IfcSensorTypeEnum", "IfcSequenceEnum", "IfcShadingDevice", "IfcShadingDeviceType", "IfcShadingDeviceTypeEnum", "IfcShapeAspect", "IfcShapeModel", "IfcShapeRepresentation", "IfcShearModulusMeasure", "IfcShell", "IfcShellBasedSurfaceModel", "IfcSimpleProperty", "IfcSimplePropertyTemplate", "IfcSimplePropertyTemplateTypeEnum", "IfcSimpleValue", "IfcSite", "IfcSizeSelect", "IfcSlab", "IfcSlabElementedCase", "IfcSlabStandardCase", "IfcSlabType", "IfcSlabTypeEnum", "IfcSlippageConnectionCondition", "IfcSolarDevice", "IfcSolarDeviceType", "IfcSolarDeviceTypeEnum", "IfcSolidAngleMeasure", "IfcSolidModel", "IfcSolidOrShell", "IfcSoundPowerLevelMeasure", "IfcSoundPowerMeasure", "IfcSoundPressureLevelMeasure", "IfcSoundPressureMeasure", "IfcSpace", "IfcSpaceBoundarySelect", "IfcSpaceHeater", "IfcSpaceHeaterType", "IfcSpaceHeaterTypeEnum", "IfcSpaceType", "IfcSpaceTypeEnum", "IfcSpatialElement", "IfcSpatialElementType", "IfcSpatialStructureElement", "IfcSpatialStructureElementType", "IfcSpatialZone", "IfcSpatialZoneType", "IfcSpatialZoneTypeEnum", "IfcSpecificHeatCapacityMeasure", "IfcSpecularExponent", "IfcSpecularHighlightSelect", "IfcSpecularRoughness", "IfcSphere", "IfcStackTerminal", "IfcStackTerminalType", "IfcStackTerminalTypeEnum", "IfcStair", "IfcStairFlight", "IfcStairFlightType", "IfcStairFlightTypeEnum", "IfcStairType", "IfcStairTypeEnum", "IfcStateEnum", "IfcStrippedOptional", "IfcStructuralAction", "IfcStructuralActivity", "IfcStructuralActivityAssignmentSelect", "IfcStructuralAnalysisModel", "IfcStructuralConnection", "IfcStructuralConnectionCondition", "IfcStructuralCurveAction", "IfcStructuralCurveActivityTypeEnum", "IfcStructuralCurveConnection", "IfcStructuralCurveMember", "IfcStructuralCurveMemberTypeEnum", "IfcStructuralCurveMemberVarying", "IfcStructuralCurveReaction", "IfcStructuralItem", "IfcStructuralLinearAction", "IfcStructuralLoad", "IfcStructuralLoadCase", "IfcStructuralLoadConfiguration", "IfcStructuralLoadGroup", "IfcStructuralLoadLinearForce", "IfcStructuralLoadOrResult", "IfcStructuralLoadPlanarForce", "IfcStructuralLoadSingleDisplacement", "IfcStructuralLoadSingleDisplacementDistortion", "IfcStructuralLoadSingleForce", "IfcStructuralLoadSingleForceWarping", "IfcStructuralLoadStatic", "IfcStructuralLoadTemperature", "IfcStructuralMember", "IfcStructuralPlanarAction", "IfcStructuralPointAction", "IfcStructuralPointConnection", "IfcStructuralPointReaction", "IfcStructuralReaction", "IfcStructuralResultGroup", "IfcStructuralSurfaceAction", "IfcStructuralSurfaceActivityTypeEnum", "IfcStructuralSurfaceConnection", "IfcStructuralSurfaceMember", "IfcStructuralSurfaceMemberTypeEnum", "IfcStructuralSurfaceMemberVarying", "IfcStructuralSurfaceReaction", "IfcStyleAssignmentSelect", "IfcStyleModel", "IfcStyledItem", "IfcStyledRepresentation", "IfcSubContractResource", "IfcSubContractResourceType", "IfcSubContractResourceTypeEnum", "IfcSubedge", "IfcSurface", "IfcSurfaceCurveSweptAreaSolid", "IfcSurfaceFeature", "IfcSurfaceFeatureTypeEnum", "IfcSurfaceOfLinearExtrusion", "IfcSurfaceOfRevolution", "IfcSurfaceOrFaceSurface", "IfcSurfaceReinforcementArea", "IfcSurfaceSide", "IfcSurfaceStyle", "IfcSurfaceStyleElementSelect", "IfcSurfaceStyleLighting", "IfcSurfaceStyleRefraction", "IfcSurfaceStyleRendering", "IfcSurfaceStyleShading", "IfcSurfaceStyleWithTextures", "IfcSurfaceTexture", "IfcSweptAreaSolid", "IfcSweptDiskSolid", "IfcSweptDiskSolidPolygonal", "IfcSweptSurface", "IfcSwitchingDevice", "IfcSwitchingDeviceType", "IfcSwitchingDeviceTypeEnum", "IfcSystem", "IfcSystemFurnitureElement", "IfcSystemFurnitureElementType", "IfcSystemFurnitureElementTypeEnum", "IfcTShapeProfileDef", "IfcTable", "IfcTableColumn", "IfcTableRow", "IfcTank", "IfcTankType", "IfcTankTypeEnum", "IfcTask", "IfcTaskDurationEnum", "IfcTaskTime", "IfcTaskTimeRecurring", "IfcTaskType", "IfcTaskTypeEnum", "IfcTelecomAddress", "IfcTemperatureGradientMeasure", "IfcTemperatureRateOfChangeMeasure", "IfcTendon", "IfcTendonAnchor", "IfcTendonAnchorType", "IfcTendonAnchorTypeEnum", "IfcTendonType", "IfcTendonTypeEnum", "IfcTessellatedFaceSet", "IfcTessellatedItem", "IfcText", "IfcTextAlignment", "IfcTextDecoration", "IfcTextFontName", "IfcTextFontSelect", "IfcTextLiteral", "IfcTextLiteralWithExtent", "IfcTextPath", "IfcTextStyle", "IfcTextStyleFontModel", "IfcTextStyleForDefinedFont", "IfcTextStyleTextModel", "IfcTextTransformation", "IfcTextureCoordinate", "IfcTextureCoordinateGenerator", "IfcTextureMap", "IfcTextureVertex", "IfcTextureVertexList", "IfcThermalAdmittanceMeasure", "IfcThermalConductivityMeasure", "IfcThermalExpansionCoefficientMeasure", "IfcThermalResistanceMeasure", "IfcThermalTransmittanceMeasure", "IfcThermodynamicTemperatureMeasure", "IfcTime", "IfcTimeMeasure", "IfcTimeOrRatioSelect", "IfcTimePeriod", "IfcTimeSeries", "IfcTimeSeriesDataTypeEnum", "IfcTimeSeriesValue", "IfcTimeStamp", "IfcTopologicalRepresentationItem", "IfcTopologyRepresentation", "IfcTorqueMeasure", "IfcTransformer", "IfcTransformerType", "IfcTransformerTypeEnum", "IfcTransitionCode", "IfcTranslationalStiffnessSelect", "IfcTransportElement", "IfcTransportElementType", "IfcTransportElementTypeEnum", "IfcTrapeziumProfileDef", "IfcTriangulatedFaceSet", "IfcTrimmedCurve", "IfcTrimmingPreference", "IfcTrimmingSelect", "IfcTubeBundle", "IfcTubeBundleType", "IfcTubeBundleTypeEnum", "IfcTypeObject", "IfcTypeProcess", "IfcTypeProduct", "IfcTypeResource", "IfcURIReference", "IfcUShapeProfileDef", "IfcUnit", "IfcUnitAssignment", "IfcUnitEnum", "IfcUnitaryControlElement", "IfcUnitaryControlElementType", "IfcUnitaryControlElementTypeEnum", "IfcUnitaryEquipment", "IfcUnitaryEquipmentType", "IfcUnitaryEquipmentTypeEnum", "IfcValue", "IfcValve", "IfcValveType", "IfcValveTypeEnum", "IfcVaporPermeabilityMeasure", "IfcVector", "IfcVectorOrDirection", "IfcVertex", "IfcVertexLoop", "IfcVertexPoint", "IfcVibrationIsolator", "IfcVibrationIsolatorType", "IfcVibrationIsolatorTypeEnum", "IfcVirtualElement", "IfcVirtualGridIntersection", "IfcVoidingFeature", "IfcVoidingFeatureTypeEnum", "IfcVolumeMeasure", "IfcVolumetricFlowRateMeasure", "IfcWall", "IfcWallElementedCase", "IfcWallStandardCase", "IfcWallType", "IfcWallTypeEnum", "IfcWarpingConstantMeasure", "IfcWarpingMomentMeasure", "IfcWarpingStiffnessSelect", "IfcWasteTerminal", "IfcWasteTerminalType", "IfcWasteTerminalTypeEnum", "IfcWindow", "IfcWindowLiningProperties", "IfcWindowPanelOperationEnum", "IfcWindowPanelPositionEnum", "IfcWindowPanelProperties", "IfcWindowStandardCase", "IfcWindowStyle", "IfcWindowStyleConstructionEnum", "IfcWindowStyleOperationEnum", "IfcWindowType", "IfcWindowTypeEnum", "IfcWindowTypePartitioningEnum", "IfcWorkCalendar", "IfcWorkCalendarTypeEnum", "IfcWorkControl", "IfcWorkPlan", "IfcWorkPlanTypeEnum", "IfcWorkSchedule", "IfcWorkScheduleTypeEnum", "IfcWorkTime", "IfcZShapeProfileDef", "IfcZone" };
    return names[v];
}

static std::map<std::string,Type::Enum> string_map;
void Ifc4::InitStringMap() {
    string_map["IFCABSORBEDDOSEMEASURE"                         ] = Type::IfcAbsorbedDoseMeasure;
    string_map["IFCACCELERATIONMEASURE"                         ] = Type::IfcAccelerationMeasure;
    string_map["IFCACTIONREQUEST"                               ] = Type::IfcActionRequest;
    string_map["IFCACTIONREQUESTTYPEENUM"                       ] = Type::IfcActionRequestTypeEnum;
    string_map["IFCACTIONSOURCETYPEENUM"                        ] = Type::IfcActionSourceTypeEnum;
    string_map["IFCACTIONTYPEENUM"                              ] = Type::IfcActionTypeEnum;
    string_map["IFCACTOR"                                       ] = Type::IfcActor;
    string_map["IFCACTORROLE"                                   ] = Type::IfcActorRole;
    string_map["IFCACTORSELECT"                                 ] = Type::IfcActorSelect;
    string_map["IFCACTUATOR"                                    ] = Type::IfcActuator;
    string_map["IFCACTUATORTYPE"                                ] = Type::IfcActuatorType;
    string_map["IFCACTUATORTYPEENUM"                            ] = Type::IfcActuatorTypeEnum;
    string_map["IFCADDRESS"                                     ] = Type::IfcAddress;
    string_map["IFCADDRESSTYPEENUM"                             ] = Type::IfcAddressTypeEnum;
    string_map["IFCADVANCEDBREP"                                ] = Type::IfcAdvancedBrep;
    string_map["IFCADVANCEDBREPWITHVOIDS"                       ] = Type::IfcAdvancedBrepWithVoids;
    string_map["IFCADVANCEDFACE"                                ] = Type::IfcAdvancedFace;
    string_map["IFCAIRTERMINAL"                                 ] = Type::IfcAirTerminal;
    string_map["IFCAIRTERMINALBOX"                              ] = Type::IfcAirTerminalBox;
    string_map["IFCAIRTERMINALBOXTYPE"                          ] = Type::IfcAirTerminalBoxType;
    string_map["IFCAIRTERMINALBOXTYPEENUM"                      ] = Type::IfcAirTerminalBoxTypeEnum;
    string_map["IFCAIRTERMINALTYPE"                             ] = Type::IfcAirTerminalType;
    string_map["IFCAIRTERMINALTYPEENUM"                         ] = Type::IfcAirTerminalTypeEnum;
    string_map["IFCAIRTOAIRHEATRECOVERY"                        ] = Type::IfcAirToAirHeatRecovery;
    string_map["IFCAIRTOAIRHEATRECOVERYTYPE"                    ] = Type::IfcAirToAirHeatRecoveryType;
    string_map["IFCAIRTOAIRHEATRECOVERYTYPEENUM"                ] = Type::IfcAirToAirHeatRecoveryTypeEnum;
    string_map["IFCALARM"                                       ] = Type::IfcAlarm;
    string_map["IFCALARMTYPE"                                   ] = Type::IfcAlarmType;
    string_map["IFCALARMTYPEENUM"                               ] = Type::IfcAlarmTypeEnum;
    string_map["IFCAMOUNTOFSUBSTANCEMEASURE"                    ] = Type::IfcAmountOfSubstanceMeasure;
    string_map["IFCANALYSISMODELTYPEENUM"                       ] = Type::IfcAnalysisModelTypeEnum;
    string_map["IFCANALYSISTHEORYTYPEENUM"                      ] = Type::IfcAnalysisTheoryTypeEnum;
    string_map["IFCANGULARVELOCITYMEASURE"                      ] = Type::IfcAngularVelocityMeasure;
    string_map["IFCANNOTATION"                                  ] = Type::IfcAnnotation;
    string_map["IFCANNOTATIONFILLAREA"                          ] = Type::IfcAnnotationFillArea;
    string_map["IFCAPPLICATION"                                 ] = Type::IfcApplication;
    string_map["IFCAPPLIEDVALUE"                                ] = Type::IfcAppliedValue;
    string_map["IFCAPPLIEDVALUESELECT"                          ] = Type::IfcAppliedValueSelect;
    string_map["IFCAPPROVAL"                                    ] = Type::IfcApproval;
    string_map["IFCAPPROVALRELATIONSHIP"                        ] = Type::IfcApprovalRelationship;
    string_map["IFCARBITRARYCLOSEDPROFILEDEF"                   ] = Type::IfcArbitraryClosedProfileDef;
    string_map["IFCARBITRARYOPENPROFILEDEF"                     ] = Type::IfcArbitraryOpenProfileDef;
    string_map["IFCARBITRARYPROFILEDEFWITHVOIDS"                ] = Type::IfcArbitraryProfileDefWithVoids;
    string_map["IFCARCINDEX"                                    ] = Type::IfcArcIndex;
    string_map["IFCAREADENSITYMEASURE"                          ] = Type::IfcAreaDensityMeasure;
    string_map["IFCAREAMEASURE"                                 ] = Type::IfcAreaMeasure;
    string_map["IFCARITHMETICOPERATORENUM"                      ] = Type::IfcArithmeticOperatorEnum;
    string_map["IFCASSEMBLYPLACEENUM"                           ] = Type::IfcAssemblyPlaceEnum;
    string_map["IFCASSET"                                       ] = Type::IfcAsset;
    string_map["IFCASYMMETRICISHAPEPROFILEDEF"                  ] = Type::IfcAsymmetricIShapeProfileDef;
    string_map["IFCAUDIOVISUALAPPLIANCE"                        ] = Type::IfcAudioVisualAppliance;
    string_map["IFCAUDIOVISUALAPPLIANCETYPE"                    ] = Type::IfcAudioVisualApplianceType;
    string_map["IFCAUDIOVISUALAPPLIANCETYPEENUM"                ] = Type::IfcAudioVisualApplianceTypeEnum;
    string_map["IFCAXIS1PLACEMENT"                              ] = Type::IfcAxis1Placement;
    string_map["IFCAXIS2PLACEMENT"                              ] = Type::IfcAxis2Placement;
    string_map["IFCAXIS2PLACEMENT2D"                            ] = Type::IfcAxis2Placement2D;
    string_map["IFCAXIS2PLACEMENT3D"                            ] = Type::IfcAxis2Placement3D;
    string_map["IFCBSPLINECURVE"                                ] = Type::IfcBSplineCurve;
    string_map["IFCBSPLINECURVEFORM"                            ] = Type::IfcBSplineCurveForm;
    string_map["IFCBSPLINECURVEWITHKNOTS"                       ] = Type::IfcBSplineCurveWithKnots;
    string_map["IFCBSPLINESURFACE"                              ] = Type::IfcBSplineSurface;
    string_map["IFCBSPLINESURFACEFORM"                          ] = Type::IfcBSplineSurfaceForm;
    string_map["IFCBSPLINESURFACEWITHKNOTS"                     ] = Type::IfcBSplineSurfaceWithKnots;
    string_map["IFCBEAM"                                        ] = Type::IfcBeam;
    string_map["IFCBEAMSTANDARDCASE"                            ] = Type::IfcBeamStandardCase;
    string_map["IFCBEAMTYPE"                                    ] = Type::IfcBeamType;
    string_map["IFCBEAMTYPEENUM"                                ] = Type::IfcBeamTypeEnum;
    string_map["IFCBENCHMARKENUM"                               ] = Type::IfcBenchmarkEnum;
    string_map["IFCBENDINGPARAMETERSELECT"                      ] = Type::IfcBendingParameterSelect;
    string_map["IFCBINARY"                                      ] = Type::IfcBinary;
    string_map["IFCBLOBTEXTURE"                                 ] = Type::IfcBlobTexture;
    string_map["IFCBLOCK"                                       ] = Type::IfcBlock;
    string_map["IFCBOILER"                                      ] = Type::IfcBoiler;
    string_map["IFCBOILERTYPE"                                  ] = Type::IfcBoilerType;
    string_map["IFCBOILERTYPEENUM"                              ] = Type::IfcBoilerTypeEnum;
    string_map["IFCBOOLEAN"                                     ] = Type::IfcBoolean;
    string_map["IFCBOOLEANCLIPPINGRESULT"                       ] = Type::IfcBooleanClippingResult;
    string_map["IFCBOOLEANOPERAND"                              ] = Type::IfcBooleanOperand;
    string_map["IFCBOOLEANOPERATOR"                             ] = Type::IfcBooleanOperator;
    string_map["IFCBOOLEANRESULT"                               ] = Type::IfcBooleanResult;
    string_map["IFCBOUNDARYCONDITION"                           ] = Type::IfcBoundaryCondition;
    string_map["IFCBOUNDARYCURVE"                               ] = Type::IfcBoundaryCurve;
    string_map["IFCBOUNDARYEDGECONDITION"                       ] = Type::IfcBoundaryEdgeCondition;
    string_map["IFCBOUNDARYFACECONDITION"                       ] = Type::IfcBoundaryFaceCondition;
    string_map["IFCBOUNDARYNODECONDITION"                       ] = Type::IfcBoundaryNodeCondition;
    string_map["IFCBOUNDARYNODECONDITIONWARPING"                ] = Type::IfcBoundaryNodeConditionWarping;
    string_map["IFCBOUNDEDCURVE"                                ] = Type::IfcBoundedCurve;
    string_map["IFCBOUNDEDSURFACE"                              ] = Type::IfcBoundedSurface;
    string_map["IFCBOUNDINGBOX"                                 ] = Type::IfcBoundingBox;
    string_map["IFCBOXALIGNMENT"                                ] = Type::IfcBoxAlignment;
    string_map["IFCBOXEDHALFSPACE"                              ] = Type::IfcBoxedHalfSpace;
    string_map["IFCBUILDING"                                    ] = Type::IfcBuilding;
    string_map["IFCBUILDINGELEMENT"                             ] = Type::IfcBuildingElement;
    string_map["IFCBUILDINGELEMENTPART"                         ] = Type::IfcBuildingElementPart;
    string_map["IFCBUILDINGELEMENTPARTTYPE"                     ] = Type::IfcBuildingElementPartType;
    string_map["IFCBUILDINGELEMENTPARTTYPEENUM"                 ] = Type::IfcBuildingElementPartTypeEnum;
    string_map["IFCBUILDINGELEMENTPROXY"                        ] = Type::IfcBuildingElementProxy;
    string_map["IFCBUILDINGELEMENTPROXYTYPE"                    ] = Type::IfcBuildingElementProxyType;
    string_map["IFCBUILDINGELEMENTPROXYTYPEENUM"                ] = Type::IfcBuildingElementProxyTypeEnum;
    string_map["IFCBUILDINGELEMENTTYPE"                         ] = Type::IfcBuildingElementType;
    string_map["IFCBUILDINGSTOREY"                              ] = Type::IfcBuildingStorey;
    string_map["IFCBUILDINGSYSTEM"                              ] = Type::IfcBuildingSystem;
    string_map["IFCBUILDINGSYSTEMTYPEENUM"                      ] = Type::IfcBuildingSystemTypeEnum;
    string_map["IFCBURNER"                                      ] = Type::IfcBurner;
    string_map["IFCBURNERTYPE"                                  ] = Type::IfcBurnerType;
    string_map["IFCBURNERTYPEENUM"                              ] = Type::IfcBurnerTypeEnum;
    string_map["IFCCSHAPEPROFILEDEF"                            ] = Type::IfcCShapeProfileDef;
    string_map["IFCCABLECARRIERFITTING"                         ] = Type::IfcCableCarrierFitting;
    string_map["IFCCABLECARRIERFITTINGTYPE"                     ] = Type::IfcCableCarrierFittingType;
    string_map["IFCCABLECARRIERFITTINGTYPEENUM"                 ] = Type::IfcCableCarrierFittingTypeEnum;
    string_map["IFCCABLECARRIERSEGMENT"                         ] = Type::IfcCableCarrierSegment;
    string_map["IFCCABLECARRIERSEGMENTTYPE"                     ] = Type::IfcCableCarrierSegmentType;
    string_map["IFCCABLECARRIERSEGMENTTYPEENUM"                 ] = Type::IfcCableCarrierSegmentTypeEnum;
    string_map["IFCCABLEFITTING"                                ] = Type::IfcCableFitting;
    string_map["IFCCABLEFITTINGTYPE"                            ] = Type::IfcCableFittingType;
    string_map["IFCCABLEFITTINGTYPEENUM"                        ] = Type::IfcCableFittingTypeEnum;
    string_map["IFCCABLESEGMENT"                                ] = Type::IfcCableSegment;
    string_map["IFCCABLESEGMENTTYPE"                            ] = Type::IfcCableSegmentType;
    string_map["IFCCABLESEGMENTTYPEENUM"                        ] = Type::IfcCableSegmentTypeEnum;
    string_map["IFCCARDINALPOINTREFERENCE"                      ] = Type::IfcCardinalPointReference;
    string_map["IFCCARTESIANPOINT"                              ] = Type::IfcCartesianPoint;
    string_map["IFCCARTESIANPOINTLIST"                          ] = Type::IfcCartesianPointList;
    string_map["IFCCARTESIANPOINTLIST2D"                        ] = Type::IfcCartesianPointList2D;
    string_map["IFCCARTESIANPOINTLIST3D"                        ] = Type::IfcCartesianPointList3D;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR"             ] = Type::IfcCartesianTransformationOperator;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR2D"           ] = Type::IfcCartesianTransformationOperator2D;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM" ] = Type::IfcCartesianTransformationOperator2DnonUniform;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR3D"           ] = Type::IfcCartesianTransformationOperator3D;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM" ] = Type::IfcCartesianTransformationOperator3DnonUniform;
    string_map["IFCCENTERLINEPROFILEDEF"                        ] = Type::IfcCenterLineProfileDef;
    string_map["IFCCHANGEACTIONENUM"                            ] = Type::IfcChangeActionEnum;
    string_map["IFCCHILLER"                                     ] = Type::IfcChiller;
    string_map["IFCCHILLERTYPE"                                 ] = Type::IfcChillerType;
    string_map["IFCCHILLERTYPEENUM"                             ] = Type::IfcChillerTypeEnum;
    string_map["IFCCHIMNEY"                                     ] = Type::IfcChimney;
    string_map["IFCCHIMNEYTYPE"                                 ] = Type::IfcChimneyType;
    string_map["IFCCHIMNEYTYPEENUM"                             ] = Type::IfcChimneyTypeEnum;
    string_map["IFCCIRCLE"                                      ] = Type::IfcCircle;
    string_map["IFCCIRCLEHOLLOWPROFILEDEF"                      ] = Type::IfcCircleHollowProfileDef;
    string_map["IFCCIRCLEPROFILEDEF"                            ] = Type::IfcCircleProfileDef;
    string_map["IFCCIVILELEMENT"                                ] = Type::IfcCivilElement;
    string_map["IFCCIVILELEMENTTYPE"                            ] = Type::IfcCivilElementType;
    string_map["IFCCLASSIFICATION"                              ] = Type::IfcClassification;
    string_map["IFCCLASSIFICATIONREFERENCE"                     ] = Type::IfcClassificationReference;
    string_map["IFCCLASSIFICATIONREFERENCESELECT"               ] = Type::IfcClassificationReferenceSelect;
    string_map["IFCCLASSIFICATIONSELECT"                        ] = Type::IfcClassificationSelect;
    string_map["IFCCLOSEDSHELL"                                 ] = Type::IfcClosedShell;
    string_map["IFCCOIL"                                        ] = Type::IfcCoil;
    string_map["IFCCOILTYPE"                                    ] = Type::IfcCoilType;
    string_map["IFCCOILTYPEENUM"                                ] = Type::IfcCoilTypeEnum;
    string_map["IFCCOLOUR"                                      ] = Type::IfcColour;
    string_map["IFCCOLOURORFACTOR"                              ] = Type::IfcColourOrFactor;
    string_map["IFCCOLOURRGB"                                   ] = Type::IfcColourRgb;
    string_map["IFCCOLOURRGBLIST"                               ] = Type::IfcColourRgbList;
    string_map["IFCCOLOURSPECIFICATION"                         ] = Type::IfcColourSpecification;
    string_map["IFCCOLUMN"                                      ] = Type::IfcColumn;
    string_map["IFCCOLUMNSTANDARDCASE"                          ] = Type::IfcColumnStandardCase;
    string_map["IFCCOLUMNTYPE"                                  ] = Type::IfcColumnType;
    string_map["IFCCOLUMNTYPEENUM"                              ] = Type::IfcColumnTypeEnum;
    string_map["IFCCOMMUNICATIONSAPPLIANCE"                     ] = Type::IfcCommunicationsAppliance;
    string_map["IFCCOMMUNICATIONSAPPLIANCETYPE"                 ] = Type::IfcCommunicationsApplianceType;
    string_map["IFCCOMMUNICATIONSAPPLIANCETYPEENUM"             ] = Type::IfcCommunicationsApplianceTypeEnum;
    string_map["IFCCOMPLEXNUMBER"                               ] = Type::IfcComplexNumber;
    string_map["IFCCOMPLEXPROPERTY"                             ] = Type::IfcComplexProperty;
    string_map["IFCCOMPLEXPROPERTYTEMPLATE"                     ] = Type::IfcComplexPropertyTemplate;
    string_map["IFCCOMPLEXPROPERTYTEMPLATETYPEENUM"             ] = Type::IfcComplexPropertyTemplateTypeEnum;
    string_map["IFCCOMPOSITECURVE"                              ] = Type::IfcCompositeCurve;
    string_map["IFCCOMPOSITECURVEONSURFACE"                     ] = Type::IfcCompositeCurveOnSurface;
    string_map["IFCCOMPOSITECURVESEGMENT"                       ] = Type::IfcCompositeCurveSegment;
    string_map["IFCCOMPOSITEPROFILEDEF"                         ] = Type::IfcCompositeProfileDef;
    string_map["IFCCOMPOUNDPLANEANGLEMEASURE"                   ] = Type::IfcCompoundPlaneAngleMeasure;
    string_map["IFCCOMPRESSOR"                                  ] = Type::IfcCompressor;
    string_map["IFCCOMPRESSORTYPE"                              ] = Type::IfcCompressorType;
    string_map["IFCCOMPRESSORTYPEENUM"                          ] = Type::IfcCompressorTypeEnum;
    string_map["IFCCONDENSER"                                   ] = Type::IfcCondenser;
    string_map["IFCCONDENSERTYPE"                               ] = Type::IfcCondenserType;
    string_map["IFCCONDENSERTYPEENUM"                           ] = Type::IfcCondenserTypeEnum;
    string_map["IFCCONIC"                                       ] = Type::IfcConic;
    string_map["IFCCONNECTEDFACESET"                            ] = Type::IfcConnectedFaceSet;
    string_map["IFCCONNECTIONCURVEGEOMETRY"                     ] = Type::IfcConnectionCurveGeometry;
    string_map["IFCCONNECTIONGEOMETRY"                          ] = Type::IfcConnectionGeometry;
    string_map["IFCCONNECTIONPOINTECCENTRICITY"                 ] = Type::IfcConnectionPointEccentricity;
    string_map["IFCCONNECTIONPOINTGEOMETRY"                     ] = Type::IfcConnectionPointGeometry;
    string_map["IFCCONNECTIONSURFACEGEOMETRY"                   ] = Type::IfcConnectionSurfaceGeometry;
    string_map["IFCCONNECTIONTYPEENUM"                          ] = Type::IfcConnectionTypeEnum;
    string_map["IFCCONNECTIONVOLUMEGEOMETRY"                    ] = Type::IfcConnectionVolumeGeometry;
    string_map["IFCCONSTRAINT"                                  ] = Type::IfcConstraint;
    string_map["IFCCONSTRAINTENUM"                              ] = Type::IfcConstraintEnum;
    string_map["IFCCONSTRUCTIONEQUIPMENTRESOURCE"               ] = Type::IfcConstructionEquipmentResource;
    string_map["IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE"           ] = Type::IfcConstructionEquipmentResourceType;
    string_map["IFCCONSTRUCTIONEQUIPMENTRESOURCETYPEENUM"       ] = Type::IfcConstructionEquipmentResourceTypeEnum;
    string_map["IFCCONSTRUCTIONMATERIALRESOURCE"                ] = Type::IfcConstructionMaterialResource;
    string_map["IFCCONSTRUCTIONMATERIALRESOURCETYPE"            ] = Type::IfcConstructionMaterialResourceType;
    string_map["IFCCONSTRUCTIONMATERIALRESOURCETYPEENUM"        ] = Type::IfcConstructionMaterialResourceTypeEnum;
    string_map["IFCCONSTRUCTIONPRODUCTRESOURCE"                 ] = Type::IfcConstructionProductResource;
    string_map["IFCCONSTRUCTIONPRODUCTRESOURCETYPE"             ] = Type::IfcConstructionProductResourceType;
    string_map["IFCCONSTRUCTIONPRODUCTRESOURCETYPEENUM"         ] = Type::IfcConstructionProductResourceTypeEnum;
    string_map["IFCCONSTRUCTIONRESOURCE"                        ] = Type::IfcConstructionResource;
    string_map["IFCCONSTRUCTIONRESOURCETYPE"                    ] = Type::IfcConstructionResourceType;
    string_map["IFCCONTEXT"                                     ] = Type::IfcContext;
    string_map["IFCCONTEXTDEPENDENTMEASURE"                     ] = Type::IfcContextDependentMeasure;
    string_map["IFCCONTEXTDEPENDENTUNIT"                        ] = Type::IfcContextDependentUnit;
    string_map["IFCCONTROL"                                     ] = Type::IfcControl;
    string_map["IFCCONTROLLER"                                  ] = Type::IfcController;
    string_map["IFCCONTROLLERTYPE"                              ] = Type::IfcControllerType;
    string_map["IFCCONTROLLERTYPEENUM"                          ] = Type::IfcControllerTypeEnum;
    string_map["IFCCONVERSIONBASEDUNIT"                         ] = Type::IfcConversionBasedUnit;
    string_map["IFCCONVERSIONBASEDUNITWITHOFFSET"               ] = Type::IfcConversionBasedUnitWithOffset;
    string_map["IFCCOOLEDBEAM"                                  ] = Type::IfcCooledBeam;
    string_map["IFCCOOLEDBEAMTYPE"                              ] = Type::IfcCooledBeamType;
    string_map["IFCCOOLEDBEAMTYPEENUM"                          ] = Type::IfcCooledBeamTypeEnum;
    string_map["IFCCOOLINGTOWER"                                ] = Type::IfcCoolingTower;
    string_map["IFCCOOLINGTOWERTYPE"                            ] = Type::IfcCoolingTowerType;
    string_map["IFCCOOLINGTOWERTYPEENUM"                        ] = Type::IfcCoolingTowerTypeEnum;
    string_map["IFCCOORDINATEOPERATION"                         ] = Type::IfcCoordinateOperation;
    string_map["IFCCOORDINATEREFERENCESYSTEM"                   ] = Type::IfcCoordinateReferenceSystem;
    string_map["IFCCOORDINATEREFERENCESYSTEMSELECT"             ] = Type::IfcCoordinateReferenceSystemSelect;
    string_map["IFCCOSTITEM"                                    ] = Type::IfcCostItem;
    string_map["IFCCOSTITEMTYPEENUM"                            ] = Type::IfcCostItemTypeEnum;
    string_map["IFCCOSTSCHEDULE"                                ] = Type::IfcCostSchedule;
    string_map["IFCCOSTSCHEDULETYPEENUM"                        ] = Type::IfcCostScheduleTypeEnum;
    string_map["IFCCOSTVALUE"                                   ] = Type::IfcCostValue;
    string_map["IFCCOUNTMEASURE"                                ] = Type::IfcCountMeasure;
    string_map["IFCCOVERING"                                    ] = Type::IfcCovering;
    string_map["IFCCOVERINGTYPE"                                ] = Type::IfcCoveringType;
    string_map["IFCCOVERINGTYPEENUM"                            ] = Type::IfcCoveringTypeEnum;
    string_map["IFCCREWRESOURCE"                                ] = Type::IfcCrewResource;
    string_map["IFCCREWRESOURCETYPE"                            ] = Type::IfcCrewResourceType;
    string_map["IFCCREWRESOURCETYPEENUM"                        ] = Type::IfcCrewResourceTypeEnum;
    string_map["IFCCSGPRIMITIVE3D"                              ] = Type::IfcCsgPrimitive3D;
    string_map["IFCCSGSELECT"                                   ] = Type::IfcCsgSelect;
    string_map["IFCCSGSOLID"                                    ] = Type::IfcCsgSolid;
    string_map["IFCCURRENCYRELATIONSHIP"                        ] = Type::IfcCurrencyRelationship;
    string_map["IFCCURTAINWALL"                                 ] = Type::IfcCurtainWall;
    string_map["IFCCURTAINWALLTYPE"                             ] = Type::IfcCurtainWallType;
    string_map["IFCCURTAINWALLTYPEENUM"                         ] = Type::IfcCurtainWallTypeEnum;
    string_map["IFCCURVATUREMEASURE"                            ] = Type::IfcCurvatureMeasure;
    string_map["IFCCURVE"                                       ] = Type::IfcCurve;
    string_map["IFCCURVEBOUNDEDPLANE"                           ] = Type::IfcCurveBoundedPlane;
    string_map["IFCCURVEBOUNDEDSURFACE"                         ] = Type::IfcCurveBoundedSurface;
    string_map["IFCCURVEFONTORSCALEDCURVEFONTSELECT"            ] = Type::IfcCurveFontOrScaledCurveFontSelect;
    string_map["IFCCURVEINTERPOLATIONENUM"                      ] = Type::IfcCurveInterpolationEnum;
    string_map["IFCCURVEONSURFACE"                              ] = Type::IfcCurveOnSurface;
    string_map["IFCCURVEOREDGECURVE"                            ] = Type::IfcCurveOrEdgeCurve;
    string_map["IFCCURVESTYLE"                                  ] = Type::IfcCurveStyle;
    string_map["IFCCURVESTYLEFONT"                              ] = Type::IfcCurveStyleFont;
    string_map["IFCCURVESTYLEFONTANDSCALING"                    ] = Type::IfcCurveStyleFontAndScaling;
    string_map["IFCCURVESTYLEFONTPATTERN"                       ] = Type::IfcCurveStyleFontPattern;
    string_map["IFCCURVESTYLEFONTSELECT"                        ] = Type::IfcCurveStyleFontSelect;
    string_map["IFCCYLINDRICALSURFACE"                          ] = Type::IfcCylindricalSurface;
    string_map["IFCDAMPER"                                      ] = Type::IfcDamper;
    string_map["IFCDAMPERTYPE"                                  ] = Type::IfcDamperType;
    string_map["IFCDAMPERTYPEENUM"                              ] = Type::IfcDamperTypeEnum;
    string_map["IFCDATAORIGINENUM"                              ] = Type::IfcDataOriginEnum;
    string_map["IFCDATE"                                        ] = Type::IfcDate;
    string_map["IFCDATETIME"                                    ] = Type::IfcDateTime;
    string_map["IFCDAYINMONTHNUMBER"                            ] = Type::IfcDayInMonthNumber;
    string_map["IFCDAYINWEEKNUMBER"                             ] = Type::IfcDayInWeekNumber;
    string_map["IFCDEFINITIONSELECT"                            ] = Type::IfcDefinitionSelect;
    string_map["IFCDERIVEDMEASUREVALUE"                         ] = Type::IfcDerivedMeasureValue;
    string_map["IFCDERIVEDPROFILEDEF"                           ] = Type::IfcDerivedProfileDef;
    string_map["IFCDERIVEDUNIT"                                 ] = Type::IfcDerivedUnit;
    string_map["IFCDERIVEDUNITELEMENT"                          ] = Type::IfcDerivedUnitElement;
    string_map["IFCDERIVEDUNITENUM"                             ] = Type::IfcDerivedUnitEnum;
    string_map["IFCDESCRIPTIVEMEASURE"                          ] = Type::IfcDescriptiveMeasure;
    string_map["IFCDIMENSIONCOUNT"                              ] = Type::IfcDimensionCount;
    string_map["IFCDIMENSIONALEXPONENTS"                        ] = Type::IfcDimensionalExponents;
    string_map["IFCDIRECTION"                                   ] = Type::IfcDirection;
    string_map["IFCDIRECTIONSENSEENUM"                          ] = Type::IfcDirectionSenseEnum;
    string_map["IFCDISCRETEACCESSORY"                           ] = Type::IfcDiscreteAccessory;
    string_map["IFCDISCRETEACCESSORYTYPE"                       ] = Type::IfcDiscreteAccessoryType;
    string_map["IFCDISCRETEACCESSORYTYPEENUM"                   ] = Type::IfcDiscreteAccessoryTypeEnum;
    string_map["IFCDISTRIBUTIONCHAMBERELEMENT"                  ] = Type::IfcDistributionChamberElement;
    string_map["IFCDISTRIBUTIONCHAMBERELEMENTTYPE"              ] = Type::IfcDistributionChamberElementType;
    string_map["IFCDISTRIBUTIONCHAMBERELEMENTTYPEENUM"          ] = Type::IfcDistributionChamberElementTypeEnum;
    string_map["IFCDISTRIBUTIONCIRCUIT"                         ] = Type::IfcDistributionCircuit;
    string_map["IFCDISTRIBUTIONCONTROLELEMENT"                  ] = Type::IfcDistributionControlElement;
    string_map["IFCDISTRIBUTIONCONTROLELEMENTTYPE"              ] = Type::IfcDistributionControlElementType;
    string_map["IFCDISTRIBUTIONELEMENT"                         ] = Type::IfcDistributionElement;
    string_map["IFCDISTRIBUTIONELEMENTTYPE"                     ] = Type::IfcDistributionElementType;
    string_map["IFCDISTRIBUTIONFLOWELEMENT"                     ] = Type::IfcDistributionFlowElement;
    string_map["IFCDISTRIBUTIONFLOWELEMENTTYPE"                 ] = Type::IfcDistributionFlowElementType;
    string_map["IFCDISTRIBUTIONPORT"                            ] = Type::IfcDistributionPort;
    string_map["IFCDISTRIBUTIONPORTTYPEENUM"                    ] = Type::IfcDistributionPortTypeEnum;
    string_map["IFCDISTRIBUTIONSYSTEM"                          ] = Type::IfcDistributionSystem;
    string_map["IFCDISTRIBUTIONSYSTEMENUM"                      ] = Type::IfcDistributionSystemEnum;
    string_map["IFCDOCUMENTCONFIDENTIALITYENUM"                 ] = Type::IfcDocumentConfidentialityEnum;
    string_map["IFCDOCUMENTINFORMATION"                         ] = Type::IfcDocumentInformation;
    string_map["IFCDOCUMENTINFORMATIONRELATIONSHIP"             ] = Type::IfcDocumentInformationRelationship;
    string_map["IFCDOCUMENTREFERENCE"                           ] = Type::IfcDocumentReference;
    string_map["IFCDOCUMENTSELECT"                              ] = Type::IfcDocumentSelect;
    string_map["IFCDOCUMENTSTATUSENUM"                          ] = Type::IfcDocumentStatusEnum;
    string_map["IFCDOOR"                                        ] = Type::IfcDoor;
    string_map["IFCDOORLININGPROPERTIES"                        ] = Type::IfcDoorLiningProperties;
    string_map["IFCDOORPANELOPERATIONENUM"                      ] = Type::IfcDoorPanelOperationEnum;
    string_map["IFCDOORPANELPOSITIONENUM"                       ] = Type::IfcDoorPanelPositionEnum;
    string_map["IFCDOORPANELPROPERTIES"                         ] = Type::IfcDoorPanelProperties;
    string_map["IFCDOORSTANDARDCASE"                            ] = Type::IfcDoorStandardCase;
    string_map["IFCDOORSTYLE"                                   ] = Type::IfcDoorStyle;
    string_map["IFCDOORSTYLECONSTRUCTIONENUM"                   ] = Type::IfcDoorStyleConstructionEnum;
    string_map["IFCDOORSTYLEOPERATIONENUM"                      ] = Type::IfcDoorStyleOperationEnum;
    string_map["IFCDOORTYPE"                                    ] = Type::IfcDoorType;
    string_map["IFCDOORTYPEENUM"                                ] = Type::IfcDoorTypeEnum;
    string_map["IFCDOORTYPEOPERATIONENUM"                       ] = Type::IfcDoorTypeOperationEnum;
    string_map["IFCDOSEEQUIVALENTMEASURE"                       ] = Type::IfcDoseEquivalentMeasure;
    string_map["IFCDRAUGHTINGPREDEFINEDCOLOUR"                  ] = Type::IfcDraughtingPreDefinedColour;
    string_map["IFCDRAUGHTINGPREDEFINEDCURVEFONT"               ] = Type::IfcDraughtingPreDefinedCurveFont;
    string_map["IFCDUCTFITTING"                                 ] = Type::IfcDuctFitting;
    string_map["IFCDUCTFITTINGTYPE"                             ] = Type::IfcDuctFittingType;
    string_map["IFCDUCTFITTINGTYPEENUM"                         ] = Type::IfcDuctFittingTypeEnum;
    string_map["IFCDUCTSEGMENT"                                 ] = Type::IfcDuctSegment;
    string_map["IFCDUCTSEGMENTTYPE"                             ] = Type::IfcDuctSegmentType;
    string_map["IFCDUCTSEGMENTTYPEENUM"                         ] = Type::IfcDuctSegmentTypeEnum;
    string_map["IFCDUCTSILENCER"                                ] = Type::IfcDuctSilencer;
    string_map["IFCDUCTSILENCERTYPE"                            ] = Type::IfcDuctSilencerType;
    string_map["IFCDUCTSILENCERTYPEENUM"                        ] = Type::IfcDuctSilencerTypeEnum;
    string_map["IFCDURATION"                                    ] = Type::IfcDuration;
    string_map["IFCDYNAMICVISCOSITYMEASURE"                     ] = Type::IfcDynamicViscosityMeasure;
    string_map["IFCEDGE"                                        ] = Type::IfcEdge;
    string_map["IFCEDGECURVE"                                   ] = Type::IfcEdgeCurve;
    string_map["IFCEDGELOOP"                                    ] = Type::IfcEdgeLoop;
    string_map["IFCELECTRICAPPLIANCE"                           ] = Type::IfcElectricAppliance;
    string_map["IFCELECTRICAPPLIANCETYPE"                       ] = Type::IfcElectricApplianceType;
    string_map["IFCELECTRICAPPLIANCETYPEENUM"                   ] = Type::IfcElectricApplianceTypeEnum;
    string_map["IFCELECTRICCAPACITANCEMEASURE"                  ] = Type::IfcElectricCapacitanceMeasure;
    string_map["IFCELECTRICCHARGEMEASURE"                       ] = Type::IfcElectricChargeMeasure;
    string_map["IFCELECTRICCONDUCTANCEMEASURE"                  ] = Type::IfcElectricConductanceMeasure;
    string_map["IFCELECTRICCURRENTMEASURE"                      ] = Type::IfcElectricCurrentMeasure;
    string_map["IFCELECTRICDISTRIBUTIONBOARD"                   ] = Type::IfcElectricDistributionBoard;
    string_map["IFCELECTRICDISTRIBUTIONBOARDTYPE"               ] = Type::IfcElectricDistributionBoardType;
    string_map["IFCELECTRICDISTRIBUTIONBOARDTYPEENUM"           ] = Type::IfcElectricDistributionBoardTypeEnum;
    string_map["IFCELECTRICFLOWSTORAGEDEVICE"                   ] = Type::IfcElectricFlowStorageDevice;
    string_map["IFCELECTRICFLOWSTORAGEDEVICETYPE"               ] = Type::IfcElectricFlowStorageDeviceType;
    string_map["IFCELECTRICFLOWSTORAGEDEVICETYPEENUM"           ] = Type::IfcElectricFlowStorageDeviceTypeEnum;
    string_map["IFCELECTRICGENERATOR"                           ] = Type::IfcElectricGenerator;
    string_map["IFCELECTRICGENERATORTYPE"                       ] = Type::IfcElectricGeneratorType;
    string_map["IFCELECTRICGENERATORTYPEENUM"                   ] = Type::IfcElectricGeneratorTypeEnum;
    string_map["IFCELECTRICMOTOR"                               ] = Type::IfcElectricMotor;
    string_map["IFCELECTRICMOTORTYPE"                           ] = Type::IfcElectricMotorType;
    string_map["IFCELECTRICMOTORTYPEENUM"                       ] = Type::IfcElectricMotorTypeEnum;
    string_map["IFCELECTRICRESISTANCEMEASURE"                   ] = Type::IfcElectricResistanceMeasure;
    string_map["IFCELECTRICTIMECONTROL"                         ] = Type::IfcElectricTimeControl;
    string_map["IFCELECTRICTIMECONTROLTYPE"                     ] = Type::IfcElectricTimeControlType;
    string_map["IFCELECTRICTIMECONTROLTYPEENUM"                 ] = Type::IfcElectricTimeControlTypeEnum;
    string_map["IFCELECTRICVOLTAGEMEASURE"                      ] = Type::IfcElectricVoltageMeasure;
    string_map["IFCELEMENT"                                     ] = Type::IfcElement;
    string_map["IFCELEMENTASSEMBLY"                             ] = Type::IfcElementAssembly;
    string_map["IFCELEMENTASSEMBLYTYPE"                         ] = Type::IfcElementAssemblyType;
    string_map["IFCELEMENTASSEMBLYTYPEENUM"                     ] = Type::IfcElementAssemblyTypeEnum;
    string_map["IFCELEMENTCOMPONENT"                            ] = Type::IfcElementComponent;
    string_map["IFCELEMENTCOMPONENTTYPE"                        ] = Type::IfcElementComponentType;
    string_map["IFCELEMENTCOMPOSITIONENUM"                      ] = Type::IfcElementCompositionEnum;
    string_map["IFCELEMENTQUANTITY"                             ] = Type::IfcElementQuantity;
    string_map["IFCELEMENTTYPE"                                 ] = Type::IfcElementType;
    string_map["IFCELEMENTARYSURFACE"                           ] = Type::IfcElementarySurface;
    string_map["IFCELLIPSE"                                     ] = Type::IfcEllipse;
    string_map["IFCELLIPSEPROFILEDEF"                           ] = Type::IfcEllipseProfileDef;
    string_map["IFCENERGYCONVERSIONDEVICE"                      ] = Type::IfcEnergyConversionDevice;
    string_map["IFCENERGYCONVERSIONDEVICETYPE"                  ] = Type::IfcEnergyConversionDeviceType;
    string_map["IFCENERGYMEASURE"                               ] = Type::IfcEnergyMeasure;
    string_map["IFCENGINE"                                      ] = Type::IfcEngine;
    string_map["IFCENGINETYPE"                                  ] = Type::IfcEngineType;
    string_map["IFCENGINETYPEENUM"                              ] = Type::IfcEngineTypeEnum;
    string_map["IFCEVAPORATIVECOOLER"                           ] = Type::IfcEvaporativeCooler;
    string_map["IFCEVAPORATIVECOOLERTYPE"                       ] = Type::IfcEvaporativeCoolerType;
    string_map["IFCEVAPORATIVECOOLERTYPEENUM"                   ] = Type::IfcEvaporativeCoolerTypeEnum;
    string_map["IFCEVAPORATOR"                                  ] = Type::IfcEvaporator;
    string_map["IFCEVAPORATORTYPE"                              ] = Type::IfcEvaporatorType;
    string_map["IFCEVAPORATORTYPEENUM"                          ] = Type::IfcEvaporatorTypeEnum;
    string_map["IFCEVENT"                                       ] = Type::IfcEvent;
    string_map["IFCEVENTTIME"                                   ] = Type::IfcEventTime;
    string_map["IFCEVENTTRIGGERTYPEENUM"                        ] = Type::IfcEventTriggerTypeEnum;
    string_map["IFCEVENTTYPE"                                   ] = Type::IfcEventType;
    string_map["IFCEVENTTYPEENUM"                               ] = Type::IfcEventTypeEnum;
    string_map["IFCEXTENDEDPROPERTIES"                          ] = Type::IfcExtendedProperties;
    string_map["IFCEXTERNALINFORMATION"                         ] = Type::IfcExternalInformation;
    string_map["IFCEXTERNALREFERENCE"                           ] = Type::IfcExternalReference;
    string_map["IFCEXTERNALREFERENCERELATIONSHIP"               ] = Type::IfcExternalReferenceRelationship;
    string_map["IFCEXTERNALSPATIALELEMENT"                      ] = Type::IfcExternalSpatialElement;
    string_map["IFCEXTERNALSPATIALELEMENTTYPEENUM"              ] = Type::IfcExternalSpatialElementTypeEnum;
    string_map["IFCEXTERNALSPATIALSTRUCTUREELEMENT"             ] = Type::IfcExternalSpatialStructureElement;
    string_map["IFCEXTERNALLYDEFINEDHATCHSTYLE"                 ] = Type::IfcExternallyDefinedHatchStyle;
    string_map["IFCEXTERNALLYDEFINEDSURFACESTYLE"               ] = Type::IfcExternallyDefinedSurfaceStyle;
    string_map["IFCEXTERNALLYDEFINEDTEXTFONT"                   ] = Type::IfcExternallyDefinedTextFont;
    string_map["IFCEXTRUDEDAREASOLID"                           ] = Type::IfcExtrudedAreaSolid;
    string_map["IFCEXTRUDEDAREASOLIDTAPERED"                    ] = Type::IfcExtrudedAreaSolidTapered;
    string_map["IFCFACE"                                        ] = Type::IfcFace;
    string_map["IFCFACEBASEDSURFACEMODEL"                       ] = Type::IfcFaceBasedSurfaceModel;
    string_map["IFCFACEBOUND"                                   ] = Type::IfcFaceBound;
    string_map["IFCFACEOUTERBOUND"                              ] = Type::IfcFaceOuterBound;
    string_map["IFCFACESURFACE"                                 ] = Type::IfcFaceSurface;
    string_map["IFCFACETEDBREP"                                 ] = Type::IfcFacetedBrep;
    string_map["IFCFACETEDBREPWITHVOIDS"                        ] = Type::IfcFacetedBrepWithVoids;
    string_map["IFCFAILURECONNECTIONCONDITION"                  ] = Type::IfcFailureConnectionCondition;
    string_map["IFCFAN"                                         ] = Type::IfcFan;
    string_map["IFCFANTYPE"                                     ] = Type::IfcFanType;
    string_map["IFCFANTYPEENUM"                                 ] = Type::IfcFanTypeEnum;
    string_map["IFCFASTENER"                                    ] = Type::IfcFastener;
    string_map["IFCFASTENERTYPE"                                ] = Type::IfcFastenerType;
    string_map["IFCFASTENERTYPEENUM"                            ] = Type::IfcFastenerTypeEnum;
    string_map["IFCFEATUREELEMENT"                              ] = Type::IfcFeatureElement;
    string_map["IFCFEATUREELEMENTADDITION"                      ] = Type::IfcFeatureElementAddition;
    string_map["IFCFEATUREELEMENTSUBTRACTION"                   ] = Type::IfcFeatureElementSubtraction;
    string_map["IFCFILLAREASTYLE"                               ] = Type::IfcFillAreaStyle;
    string_map["IFCFILLAREASTYLEHATCHING"                       ] = Type::IfcFillAreaStyleHatching;
    string_map["IFCFILLAREASTYLETILES"                          ] = Type::IfcFillAreaStyleTiles;
    string_map["IFCFILLSTYLESELECT"                             ] = Type::IfcFillStyleSelect;
    string_map["IFCFILTER"                                      ] = Type::IfcFilter;
    string_map["IFCFILTERTYPE"                                  ] = Type::IfcFilterType;
    string_map["IFCFILTERTYPEENUM"                              ] = Type::IfcFilterTypeEnum;
    string_map["IFCFIRESUPPRESSIONTERMINAL"                     ] = Type::IfcFireSuppressionTerminal;
    string_map["IFCFIRESUPPRESSIONTERMINALTYPE"                 ] = Type::IfcFireSuppressionTerminalType;
    string_map["IFCFIRESUPPRESSIONTERMINALTYPEENUM"             ] = Type::IfcFireSuppressionTerminalTypeEnum;
    string_map["IFCFIXEDREFERENCESWEPTAREASOLID"                ] = Type::IfcFixedReferenceSweptAreaSolid;
    string_map["IFCFLOWCONTROLLER"                              ] = Type::IfcFlowController;
    string_map["IFCFLOWCONTROLLERTYPE"                          ] = Type::IfcFlowControllerType;
    string_map["IFCFLOWDIRECTIONENUM"                           ] = Type::IfcFlowDirectionEnum;
    string_map["IFCFLOWFITTING"                                 ] = Type::IfcFlowFitting;
    string_map["IFCFLOWFITTINGTYPE"                             ] = Type::IfcFlowFittingType;
    string_map["IFCFLOWINSTRUMENT"                              ] = Type::IfcFlowInstrument;
    string_map["IFCFLOWINSTRUMENTTYPE"                          ] = Type::IfcFlowInstrumentType;
    string_map["IFCFLOWINSTRUMENTTYPEENUM"                      ] = Type::IfcFlowInstrumentTypeEnum;
    string_map["IFCFLOWMETER"                                   ] = Type::IfcFlowMeter;
    string_map["IFCFLOWMETERTYPE"                               ] = Type::IfcFlowMeterType;
    string_map["IFCFLOWMETERTYPEENUM"                           ] = Type::IfcFlowMeterTypeEnum;
    string_map["IFCFLOWMOVINGDEVICE"                            ] = Type::IfcFlowMovingDevice;
    string_map["IFCFLOWMOVINGDEVICETYPE"                        ] = Type::IfcFlowMovingDeviceType;
    string_map["IFCFLOWSEGMENT"                                 ] = Type::IfcFlowSegment;
    string_map["IFCFLOWSEGMENTTYPE"                             ] = Type::IfcFlowSegmentType;
    string_map["IFCFLOWSTORAGEDEVICE"                           ] = Type::IfcFlowStorageDevice;
    string_map["IFCFLOWSTORAGEDEVICETYPE"                       ] = Type::IfcFlowStorageDeviceType;
    string_map["IFCFLOWTERMINAL"                                ] = Type::IfcFlowTerminal;
    string_map["IFCFLOWTERMINALTYPE"                            ] = Type::IfcFlowTerminalType;
    string_map["IFCFLOWTREATMENTDEVICE"                         ] = Type::IfcFlowTreatmentDevice;
    string_map["IFCFLOWTREATMENTDEVICETYPE"                     ] = Type::IfcFlowTreatmentDeviceType;
    string_map["IFCFONTSTYLE"                                   ] = Type::IfcFontStyle;
    string_map["IFCFONTVARIANT"                                 ] = Type::IfcFontVariant;
    string_map["IFCFONTWEIGHT"                                  ] = Type::IfcFontWeight;
    string_map["IFCFOOTING"                                     ] = Type::IfcFooting;
    string_map["IFCFOOTINGTYPE"                                 ] = Type::IfcFootingType;
    string_map["IFCFOOTINGTYPEENUM"                             ] = Type::IfcFootingTypeEnum;
    string_map["IFCFORCEMEASURE"                                ] = Type::IfcForceMeasure;
    string_map["IFCFREQUENCYMEASURE"                            ] = Type::IfcFrequencyMeasure;
    string_map["IFCFURNISHINGELEMENT"                           ] = Type::IfcFurnishingElement;
    string_map["IFCFURNISHINGELEMENTTYPE"                       ] = Type::IfcFurnishingElementType;
    string_map["IFCFURNITURE"                                   ] = Type::IfcFurniture;
    string_map["IFCFURNITURETYPE"                               ] = Type::IfcFurnitureType;
    string_map["IFCFURNITURETYPEENUM"                           ] = Type::IfcFurnitureTypeEnum;
    string_map["IFCGEOGRAPHICELEMENT"                           ] = Type::IfcGeographicElement;
    string_map["IFCGEOGRAPHICELEMENTTYPE"                       ] = Type::IfcGeographicElementType;
    string_map["IFCGEOGRAPHICELEMENTTYPEENUM"                   ] = Type::IfcGeographicElementTypeEnum;
    string_map["IFCGEOMETRICCURVESET"                           ] = Type::IfcGeometricCurveSet;
    string_map["IFCGEOMETRICPROJECTIONENUM"                     ] = Type::IfcGeometricProjectionEnum;
    string_map["IFCGEOMETRICREPRESENTATIONCONTEXT"              ] = Type::IfcGeometricRepresentationContext;
    string_map["IFCGEOMETRICREPRESENTATIONITEM"                 ] = Type::IfcGeometricRepresentationItem;
    string_map["IFCGEOMETRICREPRESENTATIONSUBCONTEXT"           ] = Type::IfcGeometricRepresentationSubContext;
    string_map["IFCGEOMETRICSET"                                ] = Type::IfcGeometricSet;
    string_map["IFCGEOMETRICSETSELECT"                          ] = Type::IfcGeometricSetSelect;
    string_map["IFCGLOBALORLOCALENUM"                           ] = Type::IfcGlobalOrLocalEnum;
    string_map["IFCGLOBALLYUNIQUEID"                            ] = Type::IfcGloballyUniqueId;
    string_map["IFCGRID"                                        ] = Type::IfcGrid;
    string_map["IFCGRIDAXIS"                                    ] = Type::IfcGridAxis;
    string_map["IFCGRIDPLACEMENT"                               ] = Type::IfcGridPlacement;
    string_map["IFCGRIDPLACEMENTDIRECTIONSELECT"                ] = Type::IfcGridPlacementDirectionSelect;
    string_map["IFCGRIDTYPEENUM"                                ] = Type::IfcGridTypeEnum;
    string_map["IFCGROUP"                                       ] = Type::IfcGroup;
    string_map["IFCHALFSPACESOLID"                              ] = Type::IfcHalfSpaceSolid;
    string_map["IFCHATCHLINEDISTANCESELECT"                     ] = Type::IfcHatchLineDistanceSelect;
    string_map["IFCHEATEXCHANGER"                               ] = Type::IfcHeatExchanger;
    string_map["IFCHEATEXCHANGERTYPE"                           ] = Type::IfcHeatExchangerType;
    string_map["IFCHEATEXCHANGERTYPEENUM"                       ] = Type::IfcHeatExchangerTypeEnum;
    string_map["IFCHEATFLUXDENSITYMEASURE"                      ] = Type::IfcHeatFluxDensityMeasure;
    string_map["IFCHEATINGVALUEMEASURE"                         ] = Type::IfcHeatingValueMeasure;
    string_map["IFCHUMIDIFIER"                                  ] = Type::IfcHumidifier;
    string_map["IFCHUMIDIFIERTYPE"                              ] = Type::IfcHumidifierType;
    string_map["IFCHUMIDIFIERTYPEENUM"                          ] = Type::IfcHumidifierTypeEnum;
    string_map["IFCISHAPEPROFILEDEF"                            ] = Type::IfcIShapeProfileDef;
    string_map["IFCIDENTIFIER"                                  ] = Type::IfcIdentifier;
    string_map["IFCILLUMINANCEMEASURE"                          ] = Type::IfcIlluminanceMeasure;
    string_map["IFCIMAGETEXTURE"                                ] = Type::IfcImageTexture;
    string_map["IFCINDEXEDCOLOURMAP"                            ] = Type::IfcIndexedColourMap;
    string_map["IFCINDEXEDPOLYCURVE"                            ] = Type::IfcIndexedPolyCurve;
    string_map["IFCINDEXEDTEXTUREMAP"                           ] = Type::IfcIndexedTextureMap;
    string_map["IFCINDEXEDTRIANGLETEXTUREMAP"                   ] = Type::IfcIndexedTriangleTextureMap;
    string_map["IFCINDUCTANCEMEASURE"                           ] = Type::IfcInductanceMeasure;
    string_map["IFCINTEGER"                                     ] = Type::IfcInteger;
    string_map["IFCINTEGERCOUNTRATEMEASURE"                     ] = Type::IfcIntegerCountRateMeasure;
    string_map["IFCINTERCEPTOR"                                 ] = Type::IfcInterceptor;
    string_map["IFCINTERCEPTORTYPE"                             ] = Type::IfcInterceptorType;
    string_map["IFCINTERCEPTORTYPEENUM"                         ] = Type::IfcInterceptorTypeEnum;
    string_map["IFCINTERNALOREXTERNALENUM"                      ] = Type::IfcInternalOrExternalEnum;
    string_map["IFCINVENTORY"                                   ] = Type::IfcInventory;
    string_map["IFCINVENTORYTYPEENUM"                           ] = Type::IfcInventoryTypeEnum;
    string_map["IFCIONCONCENTRATIONMEASURE"                     ] = Type::IfcIonConcentrationMeasure;
    string_map["IFCIRREGULARTIMESERIES"                         ] = Type::IfcIrregularTimeSeries;
    string_map["IFCIRREGULARTIMESERIESVALUE"                    ] = Type::IfcIrregularTimeSeriesValue;
    string_map["IFCISOTHERMALMOISTURECAPACITYMEASURE"           ] = Type::IfcIsothermalMoistureCapacityMeasure;
    string_map["IFCJUNCTIONBOX"                                 ] = Type::IfcJunctionBox;
    string_map["IFCJUNCTIONBOXTYPE"                             ] = Type::IfcJunctionBoxType;
    string_map["IFCJUNCTIONBOXTYPEENUM"                         ] = Type::IfcJunctionBoxTypeEnum;
    string_map["IFCKINEMATICVISCOSITYMEASURE"                   ] = Type::IfcKinematicViscosityMeasure;
    string_map["IFCKNOTTYPE"                                    ] = Type::IfcKnotType;
    string_map["IFCLSHAPEPROFILEDEF"                            ] = Type::IfcLShapeProfileDef;
    string_map["IFCLABEL"                                       ] = Type::IfcLabel;
    string_map["IFCLABORRESOURCE"                               ] = Type::IfcLaborResource;
    string_map["IFCLABORRESOURCETYPE"                           ] = Type::IfcLaborResourceType;
    string_map["IFCLABORRESOURCETYPEENUM"                       ] = Type::IfcLaborResourceTypeEnum;
    string_map["IFCLAGTIME"                                     ] = Type::IfcLagTime;
    string_map["IFCLAMP"                                        ] = Type::IfcLamp;
    string_map["IFCLAMPTYPE"                                    ] = Type::IfcLampType;
    string_map["IFCLAMPTYPEENUM"                                ] = Type::IfcLampTypeEnum;
    string_map["IFCLANGUAGEID"                                  ] = Type::IfcLanguageId;
    string_map["IFCLAYERSETDIRECTIONENUM"                       ] = Type::IfcLayerSetDirectionEnum;
    string_map["IFCLAYEREDITEM"                                 ] = Type::IfcLayeredItem;
    string_map["IFCLENGTHMEASURE"                               ] = Type::IfcLengthMeasure;
    string_map["IFCLIBRARYINFORMATION"                          ] = Type::IfcLibraryInformation;
    string_map["IFCLIBRARYREFERENCE"                            ] = Type::IfcLibraryReference;
    string_map["IFCLIBRARYSELECT"                               ] = Type::IfcLibrarySelect;
    string_map["IFCLIGHTDISTRIBUTIONCURVEENUM"                  ] = Type::IfcLightDistributionCurveEnum;
    string_map["IFCLIGHTDISTRIBUTIONDATA"                       ] = Type::IfcLightDistributionData;
    string_map["IFCLIGHTDISTRIBUTIONDATASOURCESELECT"           ] = Type::IfcLightDistributionDataSourceSelect;
    string_map["IFCLIGHTEMISSIONSOURCEENUM"                     ] = Type::IfcLightEmissionSourceEnum;
    string_map["IFCLIGHTFIXTURE"                                ] = Type::IfcLightFixture;
    string_map["IFCLIGHTFIXTURETYPE"                            ] = Type::IfcLightFixtureType;
    string_map["IFCLIGHTFIXTURETYPEENUM"                        ] = Type::IfcLightFixtureTypeEnum;
    string_map["IFCLIGHTINTENSITYDISTRIBUTION"                  ] = Type::IfcLightIntensityDistribution;
    string_map["IFCLIGHTSOURCE"                                 ] = Type::IfcLightSource;
    string_map["IFCLIGHTSOURCEAMBIENT"                          ] = Type::IfcLightSourceAmbient;
    string_map["IFCLIGHTSOURCEDIRECTIONAL"                      ] = Type::IfcLightSourceDirectional;
    string_map["IFCLIGHTSOURCEGONIOMETRIC"                      ] = Type::IfcLightSourceGoniometric;
    string_map["IFCLIGHTSOURCEPOSITIONAL"                       ] = Type::IfcLightSourcePositional;
    string_map["IFCLIGHTSOURCESPOT"                             ] = Type::IfcLightSourceSpot;
    string_map["IFCLINE"                                        ] = Type::IfcLine;
    string_map["IFCLINEINDEX"                                   ] = Type::IfcLineIndex;
    string_map["IFCLINEARFORCEMEASURE"                          ] = Type::IfcLinearForceMeasure;
    string_map["IFCLINEARMOMENTMEASURE"                         ] = Type::IfcLinearMomentMeasure;
    string_map["IFCLINEARSTIFFNESSMEASURE"                      ] = Type::IfcLinearStiffnessMeasure;
    string_map["IFCLINEARVELOCITYMEASURE"                       ] = Type::IfcLinearVelocityMeasure;
    string_map["IFCLOADGROUPTYPEENUM"                           ] = Type::IfcLoadGroupTypeEnum;
    string_map["IFCLOCALPLACEMENT"                              ] = Type::IfcLocalPlacement;
    string_map["IFCLOGICAL"                                     ] = Type::IfcLogical;
    string_map["IFCLOGICALOPERATORENUM"                         ] = Type::IfcLogicalOperatorEnum;
    string_map["IFCLOOP"                                        ] = Type::IfcLoop;
    string_map["IFCLUMINOUSFLUXMEASURE"                         ] = Type::IfcLuminousFluxMeasure;
    string_map["IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE"        ] = Type::IfcLuminousIntensityDistributionMeasure;
    string_map["IFCLUMINOUSINTENSITYMEASURE"                    ] = Type::IfcLuminousIntensityMeasure;
    string_map["IFCMAGNETICFLUXDENSITYMEASURE"                  ] = Type::IfcMagneticFluxDensityMeasure;
    string_map["IFCMAGNETICFLUXMEASURE"                         ] = Type::IfcMagneticFluxMeasure;
    string_map["IFCMANIFOLDSOLIDBREP"                           ] = Type::IfcManifoldSolidBrep;
    string_map["IFCMAPCONVERSION"                               ] = Type::IfcMapConversion;
    string_map["IFCMAPPEDITEM"                                  ] = Type::IfcMappedItem;
    string_map["IFCMASSDENSITYMEASURE"                          ] = Type::IfcMassDensityMeasure;
    string_map["IFCMASSFLOWRATEMEASURE"                         ] = Type::IfcMassFlowRateMeasure;
    string_map["IFCMASSMEASURE"                                 ] = Type::IfcMassMeasure;
    string_map["IFCMASSPERLENGTHMEASURE"                        ] = Type::IfcMassPerLengthMeasure;
    string_map["IFCMATERIAL"                                    ] = Type::IfcMaterial;
    string_map["IFCMATERIALCLASSIFICATIONRELATIONSHIP"          ] = Type::IfcMaterialClassificationRelationship;
    string_map["IFCMATERIALCONSTITUENT"                         ] = Type::IfcMaterialConstituent;
    string_map["IFCMATERIALCONSTITUENTSET"                      ] = Type::IfcMaterialConstituentSet;
    string_map["IFCMATERIALDEFINITION"                          ] = Type::IfcMaterialDefinition;
    string_map["IFCMATERIALDEFINITIONREPRESENTATION"            ] = Type::IfcMaterialDefinitionRepresentation;
    string_map["IFCMATERIALLAYER"                               ] = Type::IfcMaterialLayer;
    string_map["IFCMATERIALLAYERSET"                            ] = Type::IfcMaterialLayerSet;
    string_map["IFCMATERIALLAYERSETUSAGE"                       ] = Type::IfcMaterialLayerSetUsage;
    string_map["IFCMATERIALLAYERWITHOFFSETS"                    ] = Type::IfcMaterialLayerWithOffsets;
    string_map["IFCMATERIALLIST"                                ] = Type::IfcMaterialList;
    string_map["IFCMATERIALPROFILE"                             ] = Type::IfcMaterialProfile;
    string_map["IFCMATERIALPROFILESET"                          ] = Type::IfcMaterialProfileSet;
    string_map["IFCMATERIALPROFILESETUSAGE"                     ] = Type::IfcMaterialProfileSetUsage;
    string_map["IFCMATERIALPROFILESETUSAGETAPERING"             ] = Type::IfcMaterialProfileSetUsageTapering;
    string_map["IFCMATERIALPROFILEWITHOFFSETS"                  ] = Type::IfcMaterialProfileWithOffsets;
    string_map["IFCMATERIALPROPERTIES"                          ] = Type::IfcMaterialProperties;
    string_map["IFCMATERIALRELATIONSHIP"                        ] = Type::IfcMaterialRelationship;
    string_map["IFCMATERIALSELECT"                              ] = Type::IfcMaterialSelect;
    string_map["IFCMATERIALUSAGEDEFINITION"                     ] = Type::IfcMaterialUsageDefinition;
    string_map["IFCMEASUREVALUE"                                ] = Type::IfcMeasureValue;
    string_map["IFCMEASUREWITHUNIT"                             ] = Type::IfcMeasureWithUnit;
    string_map["IFCMECHANICALFASTENER"                          ] = Type::IfcMechanicalFastener;
    string_map["IFCMECHANICALFASTENERTYPE"                      ] = Type::IfcMechanicalFastenerType;
    string_map["IFCMECHANICALFASTENERTYPEENUM"                  ] = Type::IfcMechanicalFastenerTypeEnum;
    string_map["IFCMEDICALDEVICE"                               ] = Type::IfcMedicalDevice;
    string_map["IFCMEDICALDEVICETYPE"                           ] = Type::IfcMedicalDeviceType;
    string_map["IFCMEDICALDEVICETYPEENUM"                       ] = Type::IfcMedicalDeviceTypeEnum;
    string_map["IFCMEMBER"                                      ] = Type::IfcMember;
    string_map["IFCMEMBERSTANDARDCASE"                          ] = Type::IfcMemberStandardCase;
    string_map["IFCMEMBERTYPE"                                  ] = Type::IfcMemberType;
    string_map["IFCMEMBERTYPEENUM"                              ] = Type::IfcMemberTypeEnum;
    string_map["IFCMETRIC"                                      ] = Type::IfcMetric;
    string_map["IFCMETRICVALUESELECT"                           ] = Type::IfcMetricValueSelect;
    string_map["IFCMIRROREDPROFILEDEF"                          ] = Type::IfcMirroredProfileDef;
    string_map["IFCMODULUSOFELASTICITYMEASURE"                  ] = Type::IfcModulusOfElasticityMeasure;
    string_map["IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE"      ] = Type::IfcModulusOfLinearSubgradeReactionMeasure;
    string_map["IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE"  ] = Type::IfcModulusOfRotationalSubgradeReactionMeasure;
    string_map["IFCMODULUSOFROTATIONALSUBGRADEREACTIONSELECT"   ] = Type::IfcModulusOfRotationalSubgradeReactionSelect;
    string_map["IFCMODULUSOFSUBGRADEREACTIONMEASURE"            ] = Type::IfcModulusOfSubgradeReactionMeasure;
    string_map["IFCMODULUSOFSUBGRADEREACTIONSELECT"             ] = Type::IfcModulusOfSubgradeReactionSelect;
    string_map["IFCMODULUSOFTRANSLATIONALSUBGRADEREACTIONSELECT"] = Type::IfcModulusOfTranslationalSubgradeReactionSelect;
    string_map["IFCMOISTUREDIFFUSIVITYMEASURE"                  ] = Type::IfcMoistureDiffusivityMeasure;
    string_map["IFCMOLECULARWEIGHTMEASURE"                      ] = Type::IfcMolecularWeightMeasure;
    string_map["IFCMOMENTOFINERTIAMEASURE"                      ] = Type::IfcMomentOfInertiaMeasure;
    string_map["IFCMONETARYMEASURE"                             ] = Type::IfcMonetaryMeasure;
    string_map["IFCMONETARYUNIT"                                ] = Type::IfcMonetaryUnit;
    string_map["IFCMONTHINYEARNUMBER"                           ] = Type::IfcMonthInYearNumber;
    string_map["IFCMOTORCONNECTION"                             ] = Type::IfcMotorConnection;
    string_map["IFCMOTORCONNECTIONTYPE"                         ] = Type::IfcMotorConnectionType;
    string_map["IFCMOTORCONNECTIONTYPEENUM"                     ] = Type::IfcMotorConnectionTypeEnum;
    string_map["IFCNAMEDUNIT"                                   ] = Type::IfcNamedUnit;
    string_map["IFCNONNEGATIVELENGTHMEASURE"                    ] = Type::IfcNonNegativeLengthMeasure;
    string_map["IFCNORMALISEDRATIOMEASURE"                      ] = Type::IfcNormalisedRatioMeasure;
    string_map["IFCNULLSTYLE"                                   ] = Type::IfcNullStyle;
    string_map["IFCNUMERICMEASURE"                              ] = Type::IfcNumericMeasure;
    string_map["IFCOBJECT"                                      ] = Type::IfcObject;
    string_map["IFCOBJECTDEFINITION"                            ] = Type::IfcObjectDefinition;
    string_map["IFCOBJECTPLACEMENT"                             ] = Type::IfcObjectPlacement;
    string_map["IFCOBJECTREFERENCESELECT"                       ] = Type::IfcObjectReferenceSelect;
    string_map["IFCOBJECTTYPEENUM"                              ] = Type::IfcObjectTypeEnum;
    string_map["IFCOBJECTIVE"                                   ] = Type::IfcObjective;
    string_map["IFCOBJECTIVEENUM"                               ] = Type::IfcObjectiveEnum;
    string_map["IFCOCCUPANT"                                    ] = Type::IfcOccupant;
    string_map["IFCOCCUPANTTYPEENUM"                            ] = Type::IfcOccupantTypeEnum;
    string_map["IFCOFFSETCURVE2D"                               ] = Type::IfcOffsetCurve2D;
    string_map["IFCOFFSETCURVE3D"                               ] = Type::IfcOffsetCurve3D;
    string_map["IFCOPENSHELL"                                   ] = Type::IfcOpenShell;
    string_map["IFCOPENINGELEMENT"                              ] = Type::IfcOpeningElement;
    string_map["IFCOPENINGELEMENTTYPEENUM"                      ] = Type::IfcOpeningElementTypeEnum;
    string_map["IFCOPENINGSTANDARDCASE"                         ] = Type::IfcOpeningStandardCase;
    string_map["IFCORGANIZATION"                                ] = Type::IfcOrganization;
    string_map["IFCORGANIZATIONRELATIONSHIP"                    ] = Type::IfcOrganizationRelationship;
    string_map["IFCORIENTEDEDGE"                                ] = Type::IfcOrientedEdge;
    string_map["IFCOUTERBOUNDARYCURVE"                          ] = Type::IfcOuterBoundaryCurve;
    string_map["IFCOUTLET"                                      ] = Type::IfcOutlet;
    string_map["IFCOUTLETTYPE"                                  ] = Type::IfcOutletType;
    string_map["IFCOUTLETTYPEENUM"                              ] = Type::IfcOutletTypeEnum;
    string_map["IFCOWNERHISTORY"                                ] = Type::IfcOwnerHistory;
    string_map["IFCPHMEASURE"                                   ] = Type::IfcPHMeasure;
    string_map["IFCPARAMETERVALUE"                              ] = Type::IfcParameterValue;
    string_map["IFCPARAMETERIZEDPROFILEDEF"                     ] = Type::IfcParameterizedProfileDef;
    string_map["IFCPATH"                                        ] = Type::IfcPath;
    string_map["IFCPCURVE"                                      ] = Type::IfcPcurve;
    string_map["IFCPERFORMANCEHISTORY"                          ] = Type::IfcPerformanceHistory;
    string_map["IFCPERFORMANCEHISTORYTYPEENUM"                  ] = Type::IfcPerformanceHistoryTypeEnum;
    string_map["IFCPERMEABLECOVERINGOPERATIONENUM"              ] = Type::IfcPermeableCoveringOperationEnum;
    string_map["IFCPERMEABLECOVERINGPROPERTIES"                 ] = Type::IfcPermeableCoveringProperties;
    string_map["IFCPERMIT"                                      ] = Type::IfcPermit;
    string_map["IFCPERMITTYPEENUM"                              ] = Type::IfcPermitTypeEnum;
    string_map["IFCPERSON"                                      ] = Type::IfcPerson;
    string_map["IFCPERSONANDORGANIZATION"                       ] = Type::IfcPersonAndOrganization;
    string_map["IFCPHYSICALCOMPLEXQUANTITY"                     ] = Type::IfcPhysicalComplexQuantity;
    string_map["IFCPHYSICALORVIRTUALENUM"                       ] = Type::IfcPhysicalOrVirtualEnum;
    string_map["IFCPHYSICALQUANTITY"                            ] = Type::IfcPhysicalQuantity;
    string_map["IFCPHYSICALSIMPLEQUANTITY"                      ] = Type::IfcPhysicalSimpleQuantity;
    string_map["IFCPILE"                                        ] = Type::IfcPile;
    string_map["IFCPILECONSTRUCTIONENUM"                        ] = Type::IfcPileConstructionEnum;
    string_map["IFCPILETYPE"                                    ] = Type::IfcPileType;
    string_map["IFCPILETYPEENUM"                                ] = Type::IfcPileTypeEnum;
    string_map["IFCPIPEFITTING"                                 ] = Type::IfcPipeFitting;
    string_map["IFCPIPEFITTINGTYPE"                             ] = Type::IfcPipeFittingType;
    string_map["IFCPIPEFITTINGTYPEENUM"                         ] = Type::IfcPipeFittingTypeEnum;
    string_map["IFCPIPESEGMENT"                                 ] = Type::IfcPipeSegment;
    string_map["IFCPIPESEGMENTTYPE"                             ] = Type::IfcPipeSegmentType;
    string_map["IFCPIPESEGMENTTYPEENUM"                         ] = Type::IfcPipeSegmentTypeEnum;
    string_map["IFCPIXELTEXTURE"                                ] = Type::IfcPixelTexture;
    string_map["IFCPLACEMENT"                                   ] = Type::IfcPlacement;
    string_map["IFCPLANARBOX"                                   ] = Type::IfcPlanarBox;
    string_map["IFCPLANAREXTENT"                                ] = Type::IfcPlanarExtent;
    string_map["IFCPLANARFORCEMEASURE"                          ] = Type::IfcPlanarForceMeasure;
    string_map["IFCPLANE"                                       ] = Type::IfcPlane;
    string_map["IFCPLANEANGLEMEASURE"                           ] = Type::IfcPlaneAngleMeasure;
    string_map["IFCPLATE"                                       ] = Type::IfcPlate;
    string_map["IFCPLATESTANDARDCASE"                           ] = Type::IfcPlateStandardCase;
    string_map["IFCPLATETYPE"                                   ] = Type::IfcPlateType;
    string_map["IFCPLATETYPEENUM"                               ] = Type::IfcPlateTypeEnum;
    string_map["IFCPOINT"                                       ] = Type::IfcPoint;
    string_map["IFCPOINTONCURVE"                                ] = Type::IfcPointOnCurve;
    string_map["IFCPOINTONSURFACE"                              ] = Type::IfcPointOnSurface;
    string_map["IFCPOINTORVERTEXPOINT"                          ] = Type::IfcPointOrVertexPoint;
    string_map["IFCPOLYLOOP"                                    ] = Type::IfcPolyLoop;
    string_map["IFCPOLYGONALBOUNDEDHALFSPACE"                   ] = Type::IfcPolygonalBoundedHalfSpace;
    string_map["IFCPOLYLINE"                                    ] = Type::IfcPolyline;
    string_map["IFCPORT"                                        ] = Type::IfcPort;
    string_map["IFCPOSITIVEINTEGER"                             ] = Type::IfcPositiveInteger;
    string_map["IFCPOSITIVELENGTHMEASURE"                       ] = Type::IfcPositiveLengthMeasure;
    string_map["IFCPOSITIVEPLANEANGLEMEASURE"                   ] = Type::IfcPositivePlaneAngleMeasure;
    string_map["IFCPOSITIVERATIOMEASURE"                        ] = Type::IfcPositiveRatioMeasure;
    string_map["IFCPOSTALADDRESS"                               ] = Type::IfcPostalAddress;
    string_map["IFCPOWERMEASURE"                                ] = Type::IfcPowerMeasure;
    string_map["IFCPREDEFINEDCOLOUR"                            ] = Type::IfcPreDefinedColour;
    string_map["IFCPREDEFINEDCURVEFONT"                         ] = Type::IfcPreDefinedCurveFont;
    string_map["IFCPREDEFINEDITEM"                              ] = Type::IfcPreDefinedItem;
    string_map["IFCPREDEFINEDPROPERTIES"                        ] = Type::IfcPreDefinedProperties;
    string_map["IFCPREDEFINEDPROPERTYSET"                       ] = Type::IfcPreDefinedPropertySet;
    string_map["IFCPREDEFINEDTEXTFONT"                          ] = Type::IfcPreDefinedTextFont;
    string_map["IFCPRESENTABLETEXT"                             ] = Type::IfcPresentableText;
    string_map["IFCPRESENTATIONITEM"                            ] = Type::IfcPresentationItem;
    string_map["IFCPRESENTATIONLAYERASSIGNMENT"                 ] = Type::IfcPresentationLayerAssignment;
    string_map["IFCPRESENTATIONLAYERWITHSTYLE"                  ] = Type::IfcPresentationLayerWithStyle;
    string_map["IFCPRESENTATIONSTYLE"                           ] = Type::IfcPresentationStyle;
    string_map["IFCPRESENTATIONSTYLEASSIGNMENT"                 ] = Type::IfcPresentationStyleAssignment;
    string_map["IFCPRESENTATIONSTYLESELECT"                     ] = Type::IfcPresentationStyleSelect;
    string_map["IFCPRESSUREMEASURE"                             ] = Type::IfcPressureMeasure;
    string_map["IFCPROCEDURE"                                   ] = Type::IfcProcedure;
    string_map["IFCPROCEDURETYPE"                               ] = Type::IfcProcedureType;
    string_map["IFCPROCEDURETYPEENUM"                           ] = Type::IfcProcedureTypeEnum;
    string_map["IFCPROCESS"                                     ] = Type::IfcProcess;
    string_map["IFCPROCESSSELECT"                               ] = Type::IfcProcessSelect;
    string_map["IFCPRODUCT"                                     ] = Type::IfcProduct;
    string_map["IFCPRODUCTDEFINITIONSHAPE"                      ] = Type::IfcProductDefinitionShape;
    string_map["IFCPRODUCTREPRESENTATION"                       ] = Type::IfcProductRepresentation;
    string_map["IFCPRODUCTREPRESENTATIONSELECT"                 ] = Type::IfcProductRepresentationSelect;
    string_map["IFCPRODUCTSELECT"                               ] = Type::IfcProductSelect;
    string_map["IFCPROFILEDEF"                                  ] = Type::IfcProfileDef;
    string_map["IFCPROFILEPROPERTIES"                           ] = Type::IfcProfileProperties;
    string_map["IFCPROFILETYPEENUM"                             ] = Type::IfcProfileTypeEnum;
    string_map["IFCPROJECT"                                     ] = Type::IfcProject;
    string_map["IFCPROJECTLIBRARY"                              ] = Type::IfcProjectLibrary;
    string_map["IFCPROJECTORDER"                                ] = Type::IfcProjectOrder;
    string_map["IFCPROJECTORDERTYPEENUM"                        ] = Type::IfcProjectOrderTypeEnum;
    string_map["IFCPROJECTEDCRS"                                ] = Type::IfcProjectedCRS;
    string_map["IFCPROJECTEDORTRUELENGTHENUM"                   ] = Type::IfcProjectedOrTrueLengthEnum;
    string_map["IFCPROJECTIONELEMENT"                           ] = Type::IfcProjectionElement;
    string_map["IFCPROJECTIONELEMENTTYPEENUM"                   ] = Type::IfcProjectionElementTypeEnum;
    string_map["IFCPROPERTY"                                    ] = Type::IfcProperty;
    string_map["IFCPROPERTYABSTRACTION"                         ] = Type::IfcPropertyAbstraction;
    string_map["IFCPROPERTYBOUNDEDVALUE"                        ] = Type::IfcPropertyBoundedValue;
    string_map["IFCPROPERTYDEFINITION"                          ] = Type::IfcPropertyDefinition;
    string_map["IFCPROPERTYDEPENDENCYRELATIONSHIP"              ] = Type::IfcPropertyDependencyRelationship;
    string_map["IFCPROPERTYENUMERATEDVALUE"                     ] = Type::IfcPropertyEnumeratedValue;
    string_map["IFCPROPERTYENUMERATION"                         ] = Type::IfcPropertyEnumeration;
    string_map["IFCPROPERTYLISTVALUE"                           ] = Type::IfcPropertyListValue;
    string_map["IFCPROPERTYREFERENCEVALUE"                      ] = Type::IfcPropertyReferenceValue;
    string_map["IFCPROPERTYSET"                                 ] = Type::IfcPropertySet;
    string_map["IFCPROPERTYSETDEFINITION"                       ] = Type::IfcPropertySetDefinition;
    string_map["IFCPROPERTYSETDEFINITIONSELECT"                 ] = Type::IfcPropertySetDefinitionSelect;
    string_map["IFCPROPERTYSETDEFINITIONSET"                    ] = Type::IfcPropertySetDefinitionSet;
    string_map["IFCPROPERTYSETTEMPLATE"                         ] = Type::IfcPropertySetTemplate;
    string_map["IFCPROPERTYSETTEMPLATETYPEENUM"                 ] = Type::IfcPropertySetTemplateTypeEnum;
    string_map["IFCPROPERTYSINGLEVALUE"                         ] = Type::IfcPropertySingleValue;
    string_map["IFCPROPERTYTABLEVALUE"                          ] = Type::IfcPropertyTableValue;
    string_map["IFCPROPERTYTEMPLATE"                            ] = Type::IfcPropertyTemplate;
    string_map["IFCPROPERTYTEMPLATEDEFINITION"                  ] = Type::IfcPropertyTemplateDefinition;
    string_map["IFCPROTECTIVEDEVICE"                            ] = Type::IfcProtectiveDevice;
    string_map["IFCPROTECTIVEDEVICETRIPPINGUNIT"                ] = Type::IfcProtectiveDeviceTrippingUnit;
    string_map["IFCPROTECTIVEDEVICETRIPPINGUNITTYPE"            ] = Type::IfcProtectiveDeviceTrippingUnitType;
    string_map["IFCPROTECTIVEDEVICETRIPPINGUNITTYPEENUM"        ] = Type::IfcProtectiveDeviceTrippingUnitTypeEnum;
    string_map["IFCPROTECTIVEDEVICETYPE"                        ] = Type::IfcProtectiveDeviceType;
    string_map["IFCPROTECTIVEDEVICETYPEENUM"                    ] = Type::IfcProtectiveDeviceTypeEnum;
    string_map["IFCPROXY"                                       ] = Type::IfcProxy;
    string_map["IFCPUMP"                                        ] = Type::IfcPump;
    string_map["IFCPUMPTYPE"                                    ] = Type::IfcPumpType;
    string_map["IFCPUMPTYPEENUM"                                ] = Type::IfcPumpTypeEnum;
    string_map["IFCQUANTITYAREA"                                ] = Type::IfcQuantityArea;
    string_map["IFCQUANTITYCOUNT"                               ] = Type::IfcQuantityCount;
    string_map["IFCQUANTITYLENGTH"                              ] = Type::IfcQuantityLength;
    string_map["IFCQUANTITYSET"                                 ] = Type::IfcQuantitySet;
    string_map["IFCQUANTITYTIME"                                ] = Type::IfcQuantityTime;
    string_map["IFCQUANTITYVOLUME"                              ] = Type::IfcQuantityVolume;
    string_map["IFCQUANTITYWEIGHT"                              ] = Type::IfcQuantityWeight;
    string_map["IFCRADIOACTIVITYMEASURE"                        ] = Type::IfcRadioActivityMeasure;
    string_map["IFCRAILING"                                     ] = Type::IfcRailing;
    string_map["IFCRAILINGTYPE"                                 ] = Type::IfcRailingType;
    string_map["IFCRAILINGTYPEENUM"                             ] = Type::IfcRailingTypeEnum;
    string_map["IFCRAMP"                                        ] = Type::IfcRamp;
    string_map["IFCRAMPFLIGHT"                                  ] = Type::IfcRampFlight;
    string_map["IFCRAMPFLIGHTTYPE"                              ] = Type::IfcRampFlightType;
    string_map["IFCRAMPFLIGHTTYPEENUM"                          ] = Type::IfcRampFlightTypeEnum;
    string_map["IFCRAMPTYPE"                                    ] = Type::IfcRampType;
    string_map["IFCRAMPTYPEENUM"                                ] = Type::IfcRampTypeEnum;
    string_map["IFCRATIOMEASURE"                                ] = Type::IfcRatioMeasure;
    string_map["IFCRATIONALBSPLINECURVEWITHKNOTS"               ] = Type::IfcRationalBSplineCurveWithKnots;
    string_map["IFCRATIONALBSPLINESURFACEWITHKNOTS"             ] = Type::IfcRationalBSplineSurfaceWithKnots;
    string_map["IFCREAL"                                        ] = Type::IfcReal;
    string_map["IFCRECTANGLEHOLLOWPROFILEDEF"                   ] = Type::IfcRectangleHollowProfileDef;
    string_map["IFCRECTANGLEPROFILEDEF"                         ] = Type::IfcRectangleProfileDef;
    string_map["IFCRECTANGULARPYRAMID"                          ] = Type::IfcRectangularPyramid;
    string_map["IFCRECTANGULARTRIMMEDSURFACE"                   ] = Type::IfcRectangularTrimmedSurface;
    string_map["IFCRECURRENCEPATTERN"                           ] = Type::IfcRecurrencePattern;
    string_map["IFCRECURRENCETYPEENUM"                          ] = Type::IfcRecurrenceTypeEnum;
    string_map["IFCREFERENCE"                                   ] = Type::IfcReference;
    string_map["IFCREFLECTANCEMETHODENUM"                       ] = Type::IfcReflectanceMethodEnum;
    string_map["IFCREGULARTIMESERIES"                           ] = Type::IfcRegularTimeSeries;
    string_map["IFCREINFORCEMENTBARPROPERTIES"                  ] = Type::IfcReinforcementBarProperties;
    string_map["IFCREINFORCEMENTDEFINITIONPROPERTIES"           ] = Type::IfcReinforcementDefinitionProperties;
    string_map["IFCREINFORCINGBAR"                              ] = Type::IfcReinforcingBar;
    string_map["IFCREINFORCINGBARROLEENUM"                      ] = Type::IfcReinforcingBarRoleEnum;
    string_map["IFCREINFORCINGBARSURFACEENUM"                   ] = Type::IfcReinforcingBarSurfaceEnum;
    string_map["IFCREINFORCINGBARTYPE"                          ] = Type::IfcReinforcingBarType;
    string_map["IFCREINFORCINGBARTYPEENUM"                      ] = Type::IfcReinforcingBarTypeEnum;
    string_map["IFCREINFORCINGELEMENT"                          ] = Type::IfcReinforcingElement;
    string_map["IFCREINFORCINGELEMENTTYPE"                      ] = Type::IfcReinforcingElementType;
    string_map["IFCREINFORCINGMESH"                             ] = Type::IfcReinforcingMesh;
    string_map["IFCREINFORCINGMESHTYPE"                         ] = Type::IfcReinforcingMeshType;
    string_map["IFCREINFORCINGMESHTYPEENUM"                     ] = Type::IfcReinforcingMeshTypeEnum;
    string_map["IFCRELAGGREGATES"                               ] = Type::IfcRelAggregates;
    string_map["IFCRELASSIGNS"                                  ] = Type::IfcRelAssigns;
    string_map["IFCRELASSIGNSTOACTOR"                           ] = Type::IfcRelAssignsToActor;
    string_map["IFCRELASSIGNSTOCONTROL"                         ] = Type::IfcRelAssignsToControl;
    string_map["IFCRELASSIGNSTOGROUP"                           ] = Type::IfcRelAssignsToGroup;
    string_map["IFCRELASSIGNSTOGROUPBYFACTOR"                   ] = Type::IfcRelAssignsToGroupByFactor;
    string_map["IFCRELASSIGNSTOPROCESS"                         ] = Type::IfcRelAssignsToProcess;
    string_map["IFCRELASSIGNSTOPRODUCT"                         ] = Type::IfcRelAssignsToProduct;
    string_map["IFCRELASSIGNSTORESOURCE"                        ] = Type::IfcRelAssignsToResource;
    string_map["IFCRELASSOCIATES"                               ] = Type::IfcRelAssociates;
    string_map["IFCRELASSOCIATESAPPROVAL"                       ] = Type::IfcRelAssociatesApproval;
    string_map["IFCRELASSOCIATESCLASSIFICATION"                 ] = Type::IfcRelAssociatesClassification;
    string_map["IFCRELASSOCIATESCONSTRAINT"                     ] = Type::IfcRelAssociatesConstraint;
    string_map["IFCRELASSOCIATESDOCUMENT"                       ] = Type::IfcRelAssociatesDocument;
    string_map["IFCRELASSOCIATESLIBRARY"                        ] = Type::IfcRelAssociatesLibrary;
    string_map["IFCRELASSOCIATESMATERIAL"                       ] = Type::IfcRelAssociatesMaterial;
    string_map["IFCRELCONNECTS"                                 ] = Type::IfcRelConnects;
    string_map["IFCRELCONNECTSELEMENTS"                         ] = Type::IfcRelConnectsElements;
    string_map["IFCRELCONNECTSPATHELEMENTS"                     ] = Type::IfcRelConnectsPathElements;
    string_map["IFCRELCONNECTSPORTTOELEMENT"                    ] = Type::IfcRelConnectsPortToElement;
    string_map["IFCRELCONNECTSPORTS"                            ] = Type::IfcRelConnectsPorts;
    string_map["IFCRELCONNECTSSTRUCTURALACTIVITY"               ] = Type::IfcRelConnectsStructuralActivity;
    string_map["IFCRELCONNECTSSTRUCTURALMEMBER"                 ] = Type::IfcRelConnectsStructuralMember;
    string_map["IFCRELCONNECTSWITHECCENTRICITY"                 ] = Type::IfcRelConnectsWithEccentricity;
    string_map["IFCRELCONNECTSWITHREALIZINGELEMENTS"            ] = Type::IfcRelConnectsWithRealizingElements;
    string_map["IFCRELCONTAINEDINSPATIALSTRUCTURE"              ] = Type::IfcRelContainedInSpatialStructure;
    string_map["IFCRELCOVERSBLDGELEMENTS"                       ] = Type::IfcRelCoversBldgElements;
    string_map["IFCRELCOVERSSPACES"                             ] = Type::IfcRelCoversSpaces;
    string_map["IFCRELDECLARES"                                 ] = Type::IfcRelDeclares;
    string_map["IFCRELDECOMPOSES"                               ] = Type::IfcRelDecomposes;
    string_map["IFCRELDEFINES"                                  ] = Type::IfcRelDefines;
    string_map["IFCRELDEFINESBYOBJECT"                          ] = Type::IfcRelDefinesByObject;
    string_map["IFCRELDEFINESBYPROPERTIES"                      ] = Type::IfcRelDefinesByProperties;
    string_map["IFCRELDEFINESBYTEMPLATE"                        ] = Type::IfcRelDefinesByTemplate;
    string_map["IFCRELDEFINESBYTYPE"                            ] = Type::IfcRelDefinesByType;
    string_map["IFCRELFILLSELEMENT"                             ] = Type::IfcRelFillsElement;
    string_map["IFCRELFLOWCONTROLELEMENTS"                      ] = Type::IfcRelFlowControlElements;
    string_map["IFCRELINTERFERESELEMENTS"                       ] = Type::IfcRelInterferesElements;
    string_map["IFCRELNESTS"                                    ] = Type::IfcRelNests;
    string_map["IFCRELPROJECTSELEMENT"                          ] = Type::IfcRelProjectsElement;
    string_map["IFCRELREFERENCEDINSPATIALSTRUCTURE"             ] = Type::IfcRelReferencedInSpatialStructure;
    string_map["IFCRELSEQUENCE"                                 ] = Type::IfcRelSequence;
    string_map["IFCRELSERVICESBUILDINGS"                        ] = Type::IfcRelServicesBuildings;
    string_map["IFCRELSPACEBOUNDARY"                            ] = Type::IfcRelSpaceBoundary;
    string_map["IFCRELSPACEBOUNDARY1STLEVEL"                    ] = Type::IfcRelSpaceBoundary1stLevel;
    string_map["IFCRELSPACEBOUNDARY2NDLEVEL"                    ] = Type::IfcRelSpaceBoundary2ndLevel;
    string_map["IFCRELVOIDSELEMENT"                             ] = Type::IfcRelVoidsElement;
    string_map["IFCRELATIONSHIP"                                ] = Type::IfcRelationship;
    string_map["IFCREPARAMETRISEDCOMPOSITECURVESEGMENT"         ] = Type::IfcReparametrisedCompositeCurveSegment;
    string_map["IFCREPRESENTATION"                              ] = Type::IfcRepresentation;
    string_map["IFCREPRESENTATIONCONTEXT"                       ] = Type::IfcRepresentationContext;
    string_map["IFCREPRESENTATIONITEM"                          ] = Type::IfcRepresentationItem;
    string_map["IFCREPRESENTATIONMAP"                           ] = Type::IfcRepresentationMap;
    string_map["IFCRESOURCE"                                    ] = Type::IfcResource;
    string_map["IFCRESOURCEAPPROVALRELATIONSHIP"                ] = Type::IfcResourceApprovalRelationship;
    string_map["IFCRESOURCECONSTRAINTRELATIONSHIP"              ] = Type::IfcResourceConstraintRelationship;
    string_map["IFCRESOURCELEVELRELATIONSHIP"                   ] = Type::IfcResourceLevelRelationship;
    string_map["IFCRESOURCEOBJECTSELECT"                        ] = Type::IfcResourceObjectSelect;
    string_map["IFCRESOURCESELECT"                              ] = Type::IfcResourceSelect;
    string_map["IFCRESOURCETIME"                                ] = Type::IfcResourceTime;
    string_map["IFCREVOLVEDAREASOLID"                           ] = Type::IfcRevolvedAreaSolid;
    string_map["IFCREVOLVEDAREASOLIDTAPERED"                    ] = Type::IfcRevolvedAreaSolidTapered;
    string_map["IFCRIGHTCIRCULARCONE"                           ] = Type::IfcRightCircularCone;
    string_map["IFCRIGHTCIRCULARCYLINDER"                       ] = Type::IfcRightCircularCylinder;
    string_map["IFCROLEENUM"                                    ] = Type::IfcRoleEnum;
    string_map["IFCROOF"                                        ] = Type::IfcRoof;
    string_map["IFCROOFTYPE"                                    ] = Type::IfcRoofType;
    string_map["IFCROOFTYPEENUM"                                ] = Type::IfcRoofTypeEnum;
    string_map["IFCROOT"                                        ] = Type::IfcRoot;
    string_map["IFCROTATIONALFREQUENCYMEASURE"                  ] = Type::IfcRotationalFrequencyMeasure;
    string_map["IFCROTATIONALMASSMEASURE"                       ] = Type::IfcRotationalMassMeasure;
    string_map["IFCROTATIONALSTIFFNESSMEASURE"                  ] = Type::IfcRotationalStiffnessMeasure;
    string_map["IFCROTATIONALSTIFFNESSSELECT"                   ] = Type::IfcRotationalStiffnessSelect;
    string_map["IFCROUNDEDRECTANGLEPROFILEDEF"                  ] = Type::IfcRoundedRectangleProfileDef;
    string_map["IFCSIPREFIX"                                    ] = Type::IfcSIPrefix;
    string_map["IFCSIUNIT"                                      ] = Type::IfcSIUnit;
    string_map["IFCSIUNITNAME"                                  ] = Type::IfcSIUnitName;
    string_map["IFCSANITARYTERMINAL"                            ] = Type::IfcSanitaryTerminal;
    string_map["IFCSANITARYTERMINALTYPE"                        ] = Type::IfcSanitaryTerminalType;
    string_map["IFCSANITARYTERMINALTYPEENUM"                    ] = Type::IfcSanitaryTerminalTypeEnum;
    string_map["IFCSCHEDULINGTIME"                              ] = Type::IfcSchedulingTime;
    string_map["IFCSECTIONMODULUSMEASURE"                       ] = Type::IfcSectionModulusMeasure;
    string_map["IFCSECTIONPROPERTIES"                           ] = Type::IfcSectionProperties;
    string_map["IFCSECTIONREINFORCEMENTPROPERTIES"              ] = Type::IfcSectionReinforcementProperties;
    string_map["IFCSECTIONTYPEENUM"                             ] = Type::IfcSectionTypeEnum;
    string_map["IFCSECTIONALAREAINTEGRALMEASURE"                ] = Type::IfcSectionalAreaIntegralMeasure;
    string_map["IFCSECTIONEDSPINE"                              ] = Type::IfcSectionedSpine;
    string_map["IFCSEGMENTINDEXSELECT"                          ] = Type::IfcSegmentIndexSelect;
    string_map["IFCSENSOR"                                      ] = Type::IfcSensor;
    string_map["IFCSENSORTYPE"                                  ] = Type::IfcSensorType;
    string_map["IFCSENSORTYPEENUM"                              ] = Type::IfcSensorTypeEnum;
    string_map["IFCSEQUENCEENUM"                                ] = Type::IfcSequenceEnum;
    string_map["IFCSHADINGDEVICE"                               ] = Type::IfcShadingDevice;
    string_map["IFCSHADINGDEVICETYPE"                           ] = Type::IfcShadingDeviceType;
    string_map["IFCSHADINGDEVICETYPEENUM"                       ] = Type::IfcShadingDeviceTypeEnum;
    string_map["IFCSHAPEASPECT"                                 ] = Type::IfcShapeAspect;
    string_map["IFCSHAPEMODEL"                                  ] = Type::IfcShapeModel;
    string_map["IFCSHAPEREPRESENTATION"                         ] = Type::IfcShapeRepresentation;
    string_map["IFCSHEARMODULUSMEASURE"                         ] = Type::IfcShearModulusMeasure;
    string_map["IFCSHELL"                                       ] = Type::IfcShell;
    string_map["IFCSHELLBASEDSURFACEMODEL"                      ] = Type::IfcShellBasedSurfaceModel;
    string_map["IFCSIMPLEPROPERTY"                              ] = Type::IfcSimpleProperty;
    string_map["IFCSIMPLEPROPERTYTEMPLATE"                      ] = Type::IfcSimplePropertyTemplate;
    string_map["IFCSIMPLEPROPERTYTEMPLATETYPEENUM"              ] = Type::IfcSimplePropertyTemplateTypeEnum;
    string_map["IFCSIMPLEVALUE"                                 ] = Type::IfcSimpleValue;
    string_map["IFCSITE"                                        ] = Type::IfcSite;
    string_map["IFCSIZESELECT"                                  ] = Type::IfcSizeSelect;
    string_map["IFCSLAB"                                        ] = Type::IfcSlab;
    string_map["IFCSLABELEMENTEDCASE"                           ] = Type::IfcSlabElementedCase;
    string_map["IFCSLABSTANDARDCASE"                            ] = Type::IfcSlabStandardCase;
    string_map["IFCSLABTYPE"                                    ] = Type::IfcSlabType;
    string_map["IFCSLABTYPEENUM"                                ] = Type::IfcSlabTypeEnum;
    string_map["IFCSLIPPAGECONNECTIONCONDITION"                 ] = Type::IfcSlippageConnectionCondition;
    string_map["IFCSOLARDEVICE"                                 ] = Type::IfcSolarDevice;
    string_map["IFCSOLARDEVICETYPE"                             ] = Type::IfcSolarDeviceType;
    string_map["IFCSOLARDEVICETYPEENUM"                         ] = Type::IfcSolarDeviceTypeEnum;
    string_map["IFCSOLIDANGLEMEASURE"                           ] = Type::IfcSolidAngleMeasure;
    string_map["IFCSOLIDMODEL"                                  ] = Type::IfcSolidModel;
    string_map["IFCSOLIDORSHELL"                                ] = Type::IfcSolidOrShell;
    string_map["IFCSOUNDPOWERLEVELMEASURE"                      ] = Type::IfcSoundPowerLevelMeasure;
    string_map["IFCSOUNDPOWERMEASURE"                           ] = Type::IfcSoundPowerMeasure;
    string_map["IFCSOUNDPRESSURELEVELMEASURE"                   ] = Type::IfcSoundPressureLevelMeasure;
    string_map["IFCSOUNDPRESSUREMEASURE"                        ] = Type::IfcSoundPressureMeasure;
    string_map["IFCSPACE"                                       ] = Type::IfcSpace;
    string_map["IFCSPACEBOUNDARYSELECT"                         ] = Type::IfcSpaceBoundarySelect;
    string_map["IFCSPACEHEATER"                                 ] = Type::IfcSpaceHeater;
    string_map["IFCSPACEHEATERTYPE"                             ] = Type::IfcSpaceHeaterType;
    string_map["IFCSPACEHEATERTYPEENUM"                         ] = Type::IfcSpaceHeaterTypeEnum;
    string_map["IFCSPACETYPE"                                   ] = Type::IfcSpaceType;
    string_map["IFCSPACETYPEENUM"                               ] = Type::IfcSpaceTypeEnum;
    string_map["IFCSPATIALELEMENT"                              ] = Type::IfcSpatialElement;
    string_map["IFCSPATIALELEMENTTYPE"                          ] = Type::IfcSpatialElementType;
    string_map["IFCSPATIALSTRUCTUREELEMENT"                     ] = Type::IfcSpatialStructureElement;
    string_map["IFCSPATIALSTRUCTUREELEMENTTYPE"                 ] = Type::IfcSpatialStructureElementType;
    string_map["IFCSPATIALZONE"                                 ] = Type::IfcSpatialZone;
    string_map["IFCSPATIALZONETYPE"                             ] = Type::IfcSpatialZoneType;
    string_map["IFCSPATIALZONETYPEENUM"                         ] = Type::IfcSpatialZoneTypeEnum;
    string_map["IFCSPECIFICHEATCAPACITYMEASURE"                 ] = Type::IfcSpecificHeatCapacityMeasure;
    string_map["IFCSPECULAREXPONENT"                            ] = Type::IfcSpecularExponent;
    string_map["IFCSPECULARHIGHLIGHTSELECT"                     ] = Type::IfcSpecularHighlightSelect;
    string_map["IFCSPECULARROUGHNESS"                           ] = Type::IfcSpecularRoughness;
    string_map["IFCSPHERE"                                      ] = Type::IfcSphere;
    string_map["IFCSTACKTERMINAL"                               ] = Type::IfcStackTerminal;
    string_map["IFCSTACKTERMINALTYPE"                           ] = Type::IfcStackTerminalType;
    string_map["IFCSTACKTERMINALTYPEENUM"                       ] = Type::IfcStackTerminalTypeEnum;
    string_map["IFCSTAIR"                                       ] = Type::IfcStair;
    string_map["IFCSTAIRFLIGHT"                                 ] = Type::IfcStairFlight;
    string_map["IFCSTAIRFLIGHTTYPE"                             ] = Type::IfcStairFlightType;
    string_map["IFCSTAIRFLIGHTTYPEENUM"                         ] = Type::IfcStairFlightTypeEnum;
    string_map["IFCSTAIRTYPE"                                   ] = Type::IfcStairType;
    string_map["IFCSTAIRTYPEENUM"                               ] = Type::IfcStairTypeEnum;
    string_map["IFCSTATEENUM"                                   ] = Type::IfcStateEnum;
    string_map["IFCSTRIPPEDOPTIONAL"                            ] = Type::IfcStrippedOptional;
    string_map["IFCSTRUCTURALACTION"                            ] = Type::IfcStructuralAction;
    string_map["IFCSTRUCTURALACTIVITY"                          ] = Type::IfcStructuralActivity;
    string_map["IFCSTRUCTURALACTIVITYASSIGNMENTSELECT"          ] = Type::IfcStructuralActivityAssignmentSelect;
    string_map["IFCSTRUCTURALANALYSISMODEL"                     ] = Type::IfcStructuralAnalysisModel;
    string_map["IFCSTRUCTURALCONNECTION"                        ] = Type::IfcStructuralConnection;
    string_map["IFCSTRUCTURALCONNECTIONCONDITION"               ] = Type::IfcStructuralConnectionCondition;
    string_map["IFCSTRUCTURALCURVEACTION"                       ] = Type::IfcStructuralCurveAction;
    string_map["IFCSTRUCTURALCURVEACTIVITYTYPEENUM"             ] = Type::IfcStructuralCurveActivityTypeEnum;
    string_map["IFCSTRUCTURALCURVECONNECTION"                   ] = Type::IfcStructuralCurveConnection;
    string_map["IFCSTRUCTURALCURVEMEMBER"                       ] = Type::IfcStructuralCurveMember;
    string_map["IFCSTRUCTURALCURVEMEMBERTYPEENUM"               ] = Type::IfcStructuralCurveMemberTypeEnum;
    string_map["IFCSTRUCTURALCURVEMEMBERVARYING"                ] = Type::IfcStructuralCurveMemberVarying;
    string_map["IFCSTRUCTURALCURVEREACTION"                     ] = Type::IfcStructuralCurveReaction;
    string_map["IFCSTRUCTURALITEM"                              ] = Type::IfcStructuralItem;
    string_map["IFCSTRUCTURALLINEARACTION"                      ] = Type::IfcStructuralLinearAction;
    string_map["IFCSTRUCTURALLOAD"                              ] = Type::IfcStructuralLoad;
    string_map["IFCSTRUCTURALLOADCASE"                          ] = Type::IfcStructuralLoadCase;
    string_map["IFCSTRUCTURALLOADCONFIGURATION"                 ] = Type::IfcStructuralLoadConfiguration;
    string_map["IFCSTRUCTURALLOADGROUP"                         ] = Type::IfcStructuralLoadGroup;
    string_map["IFCSTRUCTURALLOADLINEARFORCE"                   ] = Type::IfcStructuralLoadLinearForce;
    string_map["IFCSTRUCTURALLOADORRESULT"                      ] = Type::IfcStructuralLoadOrResult;
    string_map["IFCSTRUCTURALLOADPLANARFORCE"                   ] = Type::IfcStructuralLoadPlanarForce;
    string_map["IFCSTRUCTURALLOADSINGLEDISPLACEMENT"            ] = Type::IfcStructuralLoadSingleDisplacement;
    string_map["IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION"  ] = Type::IfcStructuralLoadSingleDisplacementDistortion;
    string_map["IFCSTRUCTURALLOADSINGLEFORCE"                   ] = Type::IfcStructuralLoadSingleForce;
    string_map["IFCSTRUCTURALLOADSINGLEFORCEWARPING"            ] = Type::IfcStructuralLoadSingleForceWarping;
    string_map["IFCSTRUCTURALLOADSTATIC"                        ] = Type::IfcStructuralLoadStatic;
    string_map["IFCSTRUCTURALLOADTEMPERATURE"                   ] = Type::IfcStructuralLoadTemperature;
    string_map["IFCSTRUCTURALMEMBER"                            ] = Type::IfcStructuralMember;
    string_map["IFCSTRUCTURALPLANARACTION"                      ] = Type::IfcStructuralPlanarAction;
    string_map["IFCSTRUCTURALPOINTACTION"                       ] = Type::IfcStructuralPointAction;
    string_map["IFCSTRUCTURALPOINTCONNECTION"                   ] = Type::IfcStructuralPointConnection;
    string_map["IFCSTRUCTURALPOINTREACTION"                     ] = Type::IfcStructuralPointReaction;
    string_map["IFCSTRUCTURALREACTION"                          ] = Type::IfcStructuralReaction;
    string_map["IFCSTRUCTURALRESULTGROUP"                       ] = Type::IfcStructuralResultGroup;
    string_map["IFCSTRUCTURALSURFACEACTION"                     ] = Type::IfcStructuralSurfaceAction;
    string_map["IFCSTRUCTURALSURFACEACTIVITYTYPEENUM"           ] = Type::IfcStructuralSurfaceActivityTypeEnum;
    string_map["IFCSTRUCTURALSURFACECONNECTION"                 ] = Type::IfcStructuralSurfaceConnection;
    string_map["IFCSTRUCTURALSURFACEMEMBER"                     ] = Type::IfcStructuralSurfaceMember;
    string_map["IFCSTRUCTURALSURFACEMEMBERTYPEENUM"             ] = Type::IfcStructuralSurfaceMemberTypeEnum;
    string_map["IFCSTRUCTURALSURFACEMEMBERVARYING"              ] = Type::IfcStructuralSurfaceMemberVarying;
    string_map["IFCSTRUCTURALSURFACEREACTION"                   ] = Type::IfcStructuralSurfaceReaction;
    string_map["IFCSTYLEASSIGNMENTSELECT"                       ] = Type::IfcStyleAssignmentSelect;
    string_map["IFCSTYLEMODEL"                                  ] = Type::IfcStyleModel;
    string_map["IFCSTYLEDITEM"                                  ] = Type::IfcStyledItem;
    string_map["IFCSTYLEDREPRESENTATION"                        ] = Type::IfcStyledRepresentation;
    string_map["IFCSUBCONTRACTRESOURCE"                         ] = Type::IfcSubContractResource;
    string_map["IFCSUBCONTRACTRESOURCETYPE"                     ] = Type::IfcSubContractResourceType;
    string_map["IFCSUBCONTRACTRESOURCETYPEENUM"                 ] = Type::IfcSubContractResourceTypeEnum;
    string_map["IFCSUBEDGE"                                     ] = Type::IfcSubedge;
    string_map["IFCSURFACE"                                     ] = Type::IfcSurface;
    string_map["IFCSURFACECURVESWEPTAREASOLID"                  ] = Type::IfcSurfaceCurveSweptAreaSolid;
    string_map["IFCSURFACEFEATURE"                              ] = Type::IfcSurfaceFeature;
    string_map["IFCSURFACEFEATURETYPEENUM"                      ] = Type::IfcSurfaceFeatureTypeEnum;
    string_map["IFCSURFACEOFLINEAREXTRUSION"                    ] = Type::IfcSurfaceOfLinearExtrusion;
    string_map["IFCSURFACEOFREVOLUTION"                         ] = Type::IfcSurfaceOfRevolution;
    string_map["IFCSURFACEORFACESURFACE"                        ] = Type::IfcSurfaceOrFaceSurface;
    string_map["IFCSURFACEREINFORCEMENTAREA"                    ] = Type::IfcSurfaceReinforcementArea;
    string_map["IFCSURFACESIDE"                                 ] = Type::IfcSurfaceSide;
    string_map["IFCSURFACESTYLE"                                ] = Type::IfcSurfaceStyle;
    string_map["IFCSURFACESTYLEELEMENTSELECT"                   ] = Type::IfcSurfaceStyleElementSelect;
    string_map["IFCSURFACESTYLELIGHTING"                        ] = Type::IfcSurfaceStyleLighting;
    string_map["IFCSURFACESTYLEREFRACTION"                      ] = Type::IfcSurfaceStyleRefraction;
    string_map["IFCSURFACESTYLERENDERING"                       ] = Type::IfcSurfaceStyleRendering;
    string_map["IFCSURFACESTYLESHADING"                         ] = Type::IfcSurfaceStyleShading;
    string_map["IFCSURFACESTYLEWITHTEXTURES"                    ] = Type::IfcSurfaceStyleWithTextures;
    string_map["IFCSURFACETEXTURE"                              ] = Type::IfcSurfaceTexture;
    string_map["IFCSWEPTAREASOLID"                              ] = Type::IfcSweptAreaSolid;
    string_map["IFCSWEPTDISKSOLID"                              ] = Type::IfcSweptDiskSolid;
    string_map["IFCSWEPTDISKSOLIDPOLYGONAL"                     ] = Type::IfcSweptDiskSolidPolygonal;
    string_map["IFCSWEPTSURFACE"                                ] = Type::IfcSweptSurface;
    string_map["IFCSWITCHINGDEVICE"                             ] = Type::IfcSwitchingDevice;
    string_map["IFCSWITCHINGDEVICETYPE"                         ] = Type::IfcSwitchingDeviceType;
    string_map["IFCSWITCHINGDEVICETYPEENUM"                     ] = Type::IfcSwitchingDeviceTypeEnum;
    string_map["IFCSYSTEM"                                      ] = Type::IfcSystem;
    string_map["IFCSYSTEMFURNITUREELEMENT"                      ] = Type::IfcSystemFurnitureElement;
    string_map["IFCSYSTEMFURNITUREELEMENTTYPE"                  ] = Type::IfcSystemFurnitureElementType;
    string_map["IFCSYSTEMFURNITUREELEMENTTYPEENUM"              ] = Type::IfcSystemFurnitureElementTypeEnum;
    string_map["IFCTSHAPEPROFILEDEF"                            ] = Type::IfcTShapeProfileDef;
    string_map["IFCTABLE"                                       ] = Type::IfcTable;
    string_map["IFCTABLECOLUMN"                                 ] = Type::IfcTableColumn;
    string_map["IFCTABLEROW"                                    ] = Type::IfcTableRow;
    string_map["IFCTANK"                                        ] = Type::IfcTank;
    string_map["IFCTANKTYPE"                                    ] = Type::IfcTankType;
    string_map["IFCTANKTYPEENUM"                                ] = Type::IfcTankTypeEnum;
    string_map["IFCTASK"                                        ] = Type::IfcTask;
    string_map["IFCTASKDURATIONENUM"                            ] = Type::IfcTaskDurationEnum;
    string_map["IFCTASKTIME"                                    ] = Type::IfcTaskTime;
    string_map["IFCTASKTIMERECURRING"                           ] = Type::IfcTaskTimeRecurring;
    string_map["IFCTASKTYPE"                                    ] = Type::IfcTaskType;
    string_map["IFCTASKTYPEENUM"                                ] = Type::IfcTaskTypeEnum;
    string_map["IFCTELECOMADDRESS"                              ] = Type::IfcTelecomAddress;
    string_map["IFCTEMPERATUREGRADIENTMEASURE"                  ] = Type::IfcTemperatureGradientMeasure;
    string_map["IFCTEMPERATURERATEOFCHANGEMEASURE"              ] = Type::IfcTemperatureRateOfChangeMeasure;
    string_map["IFCTENDON"                                      ] = Type::IfcTendon;
    string_map["IFCTENDONANCHOR"                                ] = Type::IfcTendonAnchor;
    string_map["IFCTENDONANCHORTYPE"                            ] = Type::IfcTendonAnchorType;
    string_map["IFCTENDONANCHORTYPEENUM"                        ] = Type::IfcTendonAnchorTypeEnum;
    string_map["IFCTENDONTYPE"                                  ] = Type::IfcTendonType;
    string_map["IFCTENDONTYPEENUM"                              ] = Type::IfcTendonTypeEnum;
    string_map["IFCTESSELLATEDFACESET"                          ] = Type::IfcTessellatedFaceSet;
    string_map["IFCTESSELLATEDITEM"                             ] = Type::IfcTessellatedItem;
    string_map["IFCTEXT"                                        ] = Type::IfcText;
    string_map["IFCTEXTALIGNMENT"                               ] = Type::IfcTextAlignment;
    string_map["IFCTEXTDECORATION"                              ] = Type::IfcTextDecoration;
    string_map["IFCTEXTFONTNAME"                                ] = Type::IfcTextFontName;
    string_map["IFCTEXTFONTSELECT"                              ] = Type::IfcTextFontSelect;
    string_map["IFCTEXTLITERAL"                                 ] = Type::IfcTextLiteral;
    string_map["IFCTEXTLITERALWITHEXTENT"                       ] = Type::IfcTextLiteralWithExtent;
    string_map["IFCTEXTPATH"                                    ] = Type::IfcTextPath;
    string_map["IFCTEXTSTYLE"                                   ] = Type::IfcTextStyle;
    string_map["IFCTEXTSTYLEFONTMODEL"                          ] = Type::IfcTextStyleFontModel;
    string_map["IFCTEXTSTYLEFORDEFINEDFONT"                     ] = Type::IfcTextStyleForDefinedFont;
    string_map["IFCTEXTSTYLETEXTMODEL"                          ] = Type::IfcTextStyleTextModel;
    string_map["IFCTEXTTRANSFORMATION"                          ] = Type::IfcTextTransformation;
    string_map["IFCTEXTURECOORDINATE"                           ] = Type::IfcTextureCoordinate;
    string_map["IFCTEXTURECOORDINATEGENERATOR"                  ] = Type::IfcTextureCoordinateGenerator;
    string_map["IFCTEXTUREMAP"                                  ] = Type::IfcTextureMap;
    string_map["IFCTEXTUREVERTEX"                               ] = Type::IfcTextureVertex;
    string_map["IFCTEXTUREVERTEXLIST"                           ] = Type::IfcTextureVertexList;
    string_map["IFCTHERMALADMITTANCEMEASURE"                    ] = Type::IfcThermalAdmittanceMeasure;
    string_map["IFCTHERMALCONDUCTIVITYMEASURE"                  ] = Type::IfcThermalConductivityMeasure;
    string_map["IFCTHERMALEXPANSIONCOEFFICIENTMEASURE"          ] = Type::IfcThermalExpansionCoefficientMeasure;
    string_map["IFCTHERMALRESISTANCEMEASURE"                    ] = Type::IfcThermalResistanceMeasure;
    string_map["IFCTHERMALTRANSMITTANCEMEASURE"                 ] = Type::IfcThermalTransmittanceMeasure;
    string_map["IFCTHERMODYNAMICTEMPERATUREMEASURE"             ] = Type::IfcThermodynamicTemperatureMeasure;
    string_map["IFCTIME"                                        ] = Type::IfcTime;
    string_map["IFCTIMEMEASURE"                                 ] = Type::IfcTimeMeasure;
    string_map["IFCTIMEORRATIOSELECT"                           ] = Type::IfcTimeOrRatioSelect;
    string_map["IFCTIMEPERIOD"                                  ] = Type::IfcTimePeriod;
    string_map["IFCTIMESERIES"                                  ] = Type::IfcTimeSeries;
    string_map["IFCTIMESERIESDATATYPEENUM"                      ] = Type::IfcTimeSeriesDataTypeEnum;
    string_map["IFCTIMESERIESVALUE"                             ] = Type::IfcTimeSeriesValue;
    string_map["IFCTIMESTAMP"                                   ] = Type::IfcTimeStamp;
    string_map["IFCTOPOLOGICALREPRESENTATIONITEM"               ] = Type::IfcTopologicalRepresentationItem;
    string_map["IFCTOPOLOGYREPRESENTATION"                      ] = Type::IfcTopologyRepresentation;
    string_map["IFCTORQUEMEASURE"                               ] = Type::IfcTorqueMeasure;
    string_map["IFCTRANSFORMER"                                 ] = Type::IfcTransformer;
    string_map["IFCTRANSFORMERTYPE"                             ] = Type::IfcTransformerType;
    string_map["IFCTRANSFORMERTYPEENUM"                         ] = Type::IfcTransformerTypeEnum;
    string_map["IFCTRANSITIONCODE"                              ] = Type::IfcTransitionCode;
    string_map["IFCTRANSLATIONALSTIFFNESSSELECT"                ] = Type::IfcTranslationalStiffnessSelect;
    string_map["IFCTRANSPORTELEMENT"                            ] = Type::IfcTransportElement;
    string_map["IFCTRANSPORTELEMENTTYPE"                        ] = Type::IfcTransportElementType;
    string_map["IFCTRANSPORTELEMENTTYPEENUM"                    ] = Type::IfcTransportElementTypeEnum;
    string_map["IFCTRAPEZIUMPROFILEDEF"                         ] = Type::IfcTrapeziumProfileDef;
    string_map["IFCTRIANGULATEDFACESET"                         ] = Type::IfcTriangulatedFaceSet;
    string_map["IFCTRIMMEDCURVE"                                ] = Type::IfcTrimmedCurve;
    string_map["IFCTRIMMINGPREFERENCE"                          ] = Type::IfcTrimmingPreference;
    string_map["IFCTRIMMINGSELECT"                              ] = Type::IfcTrimmingSelect;
    string_map["IFCTUBEBUNDLE"                                  ] = Type::IfcTubeBundle;
    string_map["IFCTUBEBUNDLETYPE"                              ] = Type::IfcTubeBundleType;
    string_map["IFCTUBEBUNDLETYPEENUM"                          ] = Type::IfcTubeBundleTypeEnum;
    string_map["IFCTYPEOBJECT"                                  ] = Type::IfcTypeObject;
    string_map["IFCTYPEPROCESS"                                 ] = Type::IfcTypeProcess;
    string_map["IFCTYPEPRODUCT"                                 ] = Type::IfcTypeProduct;
    string_map["IFCTYPERESOURCE"                                ] = Type::IfcTypeResource;
    string_map["IFCURIREFERENCE"                                ] = Type::IfcURIReference;
    string_map["IFCUSHAPEPROFILEDEF"                            ] = Type::IfcUShapeProfileDef;
    string_map["IFCUNIT"                                        ] = Type::IfcUnit;
    string_map["IFCUNITASSIGNMENT"                              ] = Type::IfcUnitAssignment;
    string_map["IFCUNITENUM"                                    ] = Type::IfcUnitEnum;
    string_map["IFCUNITARYCONTROLELEMENT"                       ] = Type::IfcUnitaryControlElement;
    string_map["IFCUNITARYCONTROLELEMENTTYPE"                   ] = Type::IfcUnitaryControlElementType;
    string_map["IFCUNITARYCONTROLELEMENTTYPEENUM"               ] = Type::IfcUnitaryControlElementTypeEnum;
    string_map["IFCUNITARYEQUIPMENT"                            ] = Type::IfcUnitaryEquipment;
    string_map["IFCUNITARYEQUIPMENTTYPE"                        ] = Type::IfcUnitaryEquipmentType;
    string_map["IFCUNITARYEQUIPMENTTYPEENUM"                    ] = Type::IfcUnitaryEquipmentTypeEnum;
    string_map["IFCVALUE"                                       ] = Type::IfcValue;
    string_map["IFCVALVE"                                       ] = Type::IfcValve;
    string_map["IFCVALVETYPE"                                   ] = Type::IfcValveType;
    string_map["IFCVALVETYPEENUM"                               ] = Type::IfcValveTypeEnum;
    string_map["IFCVAPORPERMEABILITYMEASURE"                    ] = Type::IfcVaporPermeabilityMeasure;
    string_map["IFCVECTOR"                                      ] = Type::IfcVector;
    string_map["IFCVECTORORDIRECTION"                           ] = Type::IfcVectorOrDirection;
    string_map["IFCVERTEX"                                      ] = Type::IfcVertex;
    string_map["IFCVERTEXLOOP"                                  ] = Type::IfcVertexLoop;
    string_map["IFCVERTEXPOINT"                                 ] = Type::IfcVertexPoint;
    string_map["IFCVIBRATIONISOLATOR"                           ] = Type::IfcVibrationIsolator;
    string_map["IFCVIBRATIONISOLATORTYPE"                       ] = Type::IfcVibrationIsolatorType;
    string_map["IFCVIBRATIONISOLATORTYPEENUM"                   ] = Type::IfcVibrationIsolatorTypeEnum;
    string_map["IFCVIRTUALELEMENT"                              ] = Type::IfcVirtualElement;
    string_map["IFCVIRTUALGRIDINTERSECTION"                     ] = Type::IfcVirtualGridIntersection;
    string_map["IFCVOIDINGFEATURE"                              ] = Type::IfcVoidingFeature;
    string_map["IFCVOIDINGFEATURETYPEENUM"                      ] = Type::IfcVoidingFeatureTypeEnum;
    string_map["IFCVOLUMEMEASURE"                               ] = Type::IfcVolumeMeasure;
    string_map["IFCVOLUMETRICFLOWRATEMEASURE"                   ] = Type::IfcVolumetricFlowRateMeasure;
    string_map["IFCWALL"                                        ] = Type::IfcWall;
    string_map["IFCWALLELEMENTEDCASE"                           ] = Type::IfcWallElementedCase;
    string_map["IFCWALLSTANDARDCASE"                            ] = Type::IfcWallStandardCase;
    string_map["IFCWALLTYPE"                                    ] = Type::IfcWallType;
    string_map["IFCWALLTYPEENUM"                                ] = Type::IfcWallTypeEnum;
    string_map["IFCWARPINGCONSTANTMEASURE"                      ] = Type::IfcWarpingConstantMeasure;
    string_map["IFCWARPINGMOMENTMEASURE"                        ] = Type::IfcWarpingMomentMeasure;
    string_map["IFCWARPINGSTIFFNESSSELECT"                      ] = Type::IfcWarpingStiffnessSelect;
    string_map["IFCWASTETERMINAL"                               ] = Type::IfcWasteTerminal;
    string_map["IFCWASTETERMINALTYPE"                           ] = Type::IfcWasteTerminalType;
    string_map["IFCWASTETERMINALTYPEENUM"                       ] = Type::IfcWasteTerminalTypeEnum;
    string_map["IFCWINDOW"                                      ] = Type::IfcWindow;
    string_map["IFCWINDOWLININGPROPERTIES"                      ] = Type::IfcWindowLiningProperties;
    string_map["IFCWINDOWPANELOPERATIONENUM"                    ] = Type::IfcWindowPanelOperationEnum;
    string_map["IFCWINDOWPANELPOSITIONENUM"                     ] = Type::IfcWindowPanelPositionEnum;
    string_map["IFCWINDOWPANELPROPERTIES"                       ] = Type::IfcWindowPanelProperties;
    string_map["IFCWINDOWSTANDARDCASE"                          ] = Type::IfcWindowStandardCase;
    string_map["IFCWINDOWSTYLE"                                 ] = Type::IfcWindowStyle;
    string_map["IFCWINDOWSTYLECONSTRUCTIONENUM"                 ] = Type::IfcWindowStyleConstructionEnum;
    string_map["IFCWINDOWSTYLEOPERATIONENUM"                    ] = Type::IfcWindowStyleOperationEnum;
    string_map["IFCWINDOWTYPE"                                  ] = Type::IfcWindowType;
    string_map["IFCWINDOWTYPEENUM"                              ] = Type::IfcWindowTypeEnum;
    string_map["IFCWINDOWTYPEPARTITIONINGENUM"                  ] = Type::IfcWindowTypePartitioningEnum;
    string_map["IFCWORKCALENDAR"                                ] = Type::IfcWorkCalendar;
    string_map["IFCWORKCALENDARTYPEENUM"                        ] = Type::IfcWorkCalendarTypeEnum;
    string_map["IFCWORKCONTROL"                                 ] = Type::IfcWorkControl;
    string_map["IFCWORKPLAN"                                    ] = Type::IfcWorkPlan;
    string_map["IFCWORKPLANTYPEENUM"                            ] = Type::IfcWorkPlanTypeEnum;
    string_map["IFCWORKSCHEDULE"                                ] = Type::IfcWorkSchedule;
    string_map["IFCWORKSCHEDULETYPEENUM"                        ] = Type::IfcWorkScheduleTypeEnum;
    string_map["IFCWORKTIME"                                    ] = Type::IfcWorkTime;
    string_map["IFCZSHAPEPROFILEDEF"                            ] = Type::IfcZShapeProfileDef;
    string_map["IFCZONE"                                        ] = Type::IfcZone;
}

Type::Enum Type::FromString(const std::string& s) {
    if (string_map.empty()) InitStringMap();
    std::map<std::string,Type::Enum>::const_iterator it = string_map.find(s);
    if ( it == string_map.end() ) throw IfcException("Unable to find find keyword in schema");
    else return it->second;
}

static int parent_map[] = {-1,-1,202,-1,-1,-1,611,-1,-1,276,277,-1,-1,-1,548,14,390,431,414,415,-1,432,-1,357,358,-1,276,277,-1,-1,-1,-1,-1,705,454,-1,-1,-1,-1,848,710,710,40,-1,-1,-1,-1,-1,465,636,431,432,-1,662,-1,662,662,86,-1,57,87,-1,60,92,63,99,-1,-1,-1,-1,1011,229,357,358,-1,-1,79,-1,-1,454,-1,167,80,80,80,84,237,995,454,-1,466,924,345,349,350,-1,92,99,-1,353,924,1019,-1,357,358,-1,636,417,418,-1,427,428,-1,417,418,-1,427,428,-1,-1,672,454,121,121,454,124,125,124,127,41,-1,357,358,-1,92,99,-1,177,139,636,345,353,375,376,-1,-1,178,357,358,-1,-1,-1,154,693,693,92,155,99,-1,431,432,-1,-1,721,738,-1,86,166,454,710,-1,425,426,-1,357,358,-1,237,1079,180,-1,182,180,180,-1,180,-1,-1,197,198,-1,197,198,-1,197,198,-1,845,1101,612,-1,606,611,276,277,-1,606,206,357,358,-1,357,358,-1,-1,-1,-1,202,-1,202,-1,36,-1,92,99,-1,197,198,-1,454,-1,909,848,92,99,-1,-1,454,87,87,-1,-1,-1,-1,696,693,693,693,-1,354,414,415,-1,-1,-1,-1,-1,-1,-1,-1,710,-1,-1,-1,-1,-1,-1,454,-1,349,350,-1,280,281,-1,284,278,279,345,353,278,279,679,-1,1019,-1,-1,375,848,376,-1,-1,92,690,-1,-1,690,292,1100,-1,-1,99,-1,-1,-1,686,687,417,418,-1,427,428,-1,433,434,-1,-1,-1,1079,318,542,431,432,-1,-1,-1,-1,-1,414,415,-1,429,430,-1,357,358,-1,357,358,-1,-1,414,415,-1,-1,705,345,353,-1,345,353,-1,753,1100,995,177,636,280,281,-1,357,358,-1,357,358,-1,357,358,-1,703,872,-1,1099,-1,722,-1,-1,848,380,-1,922,376,376,376,1012,384,1079,454,1079,388,386,548,391,950,425,426,-1,349,350,-1,345,400,400,696,454,454,-1,433,434,-1,431,432,-1,1012,280,281,-1,280,281,276,277,-1,414,415,-1,280,281,280,281,280,281,280,281,280,281,-1,-1,-1,92,99,-1,-1,-1,345,353,443,444,-1,345,353,-1,456,-1,842,843,453,454,-1,-1,-1,705,-1,613,-1,-1,611,454,-1,357,358,-1,-1,-1,357,358,-1,636,-1,-1,1011,693,86,1060,482,-1,-1,-1,433,434,-1,-1,465,-1,-1,1075,-1,-1,417,418,-1,-1,-1,636,-1,197,198,-1,872,431,432,-1,-1,-1,-1,-1,375,376,-1,-1,-1,-1,-1,431,432,-1,-1,454,526,526,526,526,530,237,-1,-1,-1,-1,-1,-1,613,-1,-1,1079,-1,-1,-1,-1,-1,909,214,843,-1,-1,-1,-1,559,-1,559,559,-1,707,559,559,574,561,-1,559,559,574,568,566,374,848,-1,-1,-1,-1,349,350,-1,431,432,-1,92,583,99,-1,186,-1,260,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,357,358,-1,-1,-1,-1,-1,-1,612,860,-1,-1,-1,186,-1,6,-1,237,237,178,402,-1,623,-1,848,318,81,431,432,-1,-1,-1,-1,710,1079,237,202,-1,-1,690,202,-1,-1,-1,649,-1,-1,649,92,-1,99,-1,417,418,-1,427,428,-1,1011,454,664,454,-1,354,-1,92,668,99,-1,454,672,672,-1,542,466,86,705,-1,-1,-1,-1,12,-1,688,688,693,722,731,688,-1,-1,-1,694,-1,-1,-1,-1,703,1099,-1,611,-1,611,707,-1,-1,-1,-1,374,-1,199,199,202,-1,215,-1,401,-1,722,-1,893,860,848,893,722,893,893,731,724,-1,-1,739,-1,893,893,739,724,414,276,277,-1,415,-1,705,425,426,-1,650,650,650,731,650,650,650,-1,92,99,-1,92,92,99,-1,99,-1,-1,59,62,-1,772,636,229,87,-1,-1,-1,-1,1075,689,690,787,-1,-1,788,-1,349,350,787,788,-1,821,839,793,793,793,796,793,793,793,839,801,801,801,801,801,801,839,808,809,808,808,808,808,814,809,808,808,808,839,839,839,822,822,822,822,808,808,808,821,821,808,808,808,808,835,836,821,860,168,-1,-1,-1,-1,611,848,848,-1,-1,-1,872,1012,852,229,229,-1,92,99,-1,-1,-1,-1,-1,-1,772,-1,606,-1,431,432,-1,-1,-1,689,689,-1,-1,454,-1,276,277,-1,-1,92,99,-1,-1,841,888,-1,-1,454,721,738,-1,-1,924,-1,92,899,899,99,-1,950,357,358,-1,-1,454,-1,-1,-1,-1,-1,924,-1,431,432,-1,925,-1,705,1100,922,923,922,923,-1,-1,-1,-1,-1,229,431,432,-1,92,92,99,-1,99,-1,-1,-1,946,705,-1,1019,958,-1,945,-1,949,973,-1,954,978,705,951,-1,963,960,465,971,960,971,971,967,971,969,965,971,958,980,945,949,978,946,465,945,-1,949,973,-1,983,978,-1,841,843,988,197,198,-1,318,454,1012,400,-1,1015,1015,-1,965,-1,696,-1,693,693,1009,693,693,693,909,909,1013,995,414,415,-1,465,443,444,-1,636,-1,-1,-1,429,430,-1,703,-1,872,1032,1099,-1,12,-1,-1,787,787,788,-1,788,-1,1046,454,-1,-1,-1,-1,-1,454,1052,-1,696,691,693,693,-1,693,1060,1060,693,693,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,843,888,-1,357,358,-1,-1,-1,345,353,-1,636,1045,86,-1,-1,357,358,-1,612,1098,1098,1098,-1,636,-1,-1,-1,276,277,-1,357,358,-1,-1,414,415,-1,-1,454,-1,1079,542,1120,349,350,-1,345,-1,402,-1,-1,-1,92,1132,1132,99,-1,-1,-1,-1,431,432,-1,92,690,-1,-1,690,1143,1100,-1,-1,99,-1,-1,202,-1,202,1157,-1,1157,-1,872,636,1019};
boost::optional<Type::Enum> Type::Parent(Enum v){
    const int p = parent_map[static_cast<int>(v)];
    if (p >= 0) {
        return static_cast<Type::Enum>(p);
    } else {
        return boost::none;
    }
}

bool Type::IsSimple(Enum v) {
    return v == Type::IfcAbsorbedDoseMeasure || v == Type::IfcAccelerationMeasure || v == Type::IfcAmountOfSubstanceMeasure || v == Type::IfcAngularVelocityMeasure || v == Type::IfcArcIndex || v == Type::IfcAreaDensityMeasure || v == Type::IfcAreaMeasure || v == Type::IfcBoolean || v == Type::IfcColour || v == Type::IfcComplexNumber || v == Type::IfcCompoundPlaneAngleMeasure || v == Type::IfcContextDependentMeasure || v == Type::IfcCountMeasure || v == Type::IfcCurvatureMeasure || v == Type::IfcCurveStyleFontSelect || v == Type::IfcDate || v == Type::IfcDateTime || v == Type::IfcDerivedMeasureValue || v == Type::IfcDescriptiveMeasure || v == Type::IfcDoseEquivalentMeasure || v == Type::IfcDuration || v == Type::IfcDynamicViscosityMeasure || v == Type::IfcElectricCapacitanceMeasure || v == Type::IfcElectricChargeMeasure || v == Type::IfcElectricConductanceMeasure || v == Type::IfcElectricCurrentMeasure || v == Type::IfcElectricResistanceMeasure || v == Type::IfcElectricVoltageMeasure || v == Type::IfcEnergyMeasure || v == Type::IfcForceMeasure || v == Type::IfcFrequencyMeasure || v == Type::IfcHeatFluxDensityMeasure || v == Type::IfcHeatingValueMeasure || v == Type::IfcIdentifier || v == Type::IfcIlluminanceMeasure || v == Type::IfcInductanceMeasure || v == Type::IfcInteger || v == Type::IfcIntegerCountRateMeasure || v == Type::IfcIonConcentrationMeasure || v == Type::IfcIsothermalMoistureCapacityMeasure || v == Type::IfcKinematicViscosityMeasure || v == Type::IfcLabel || v == Type::IfcLengthMeasure || v == Type::IfcLineIndex || v == Type::IfcLinearForceMeasure || v == Type::IfcLinearMomentMeasure || v == Type::IfcLinearStiffnessMeasure || v == Type::IfcLinearVelocityMeasure || v == Type::IfcLogical || v == Type::IfcLuminousFluxMeasure || v == Type::IfcLuminousIntensityDistributionMeasure || v == Type::IfcLuminousIntensityMeasure || v == Type::IfcMagneticFluxDensityMeasure || v == Type::IfcMagneticFluxMeasure || v == Type::IfcMassDensityMeasure || v == Type::IfcMassFlowRateMeasure || v == Type::IfcMassMeasure || v == Type::IfcMassPerLengthMeasure || v == Type::IfcMeasureValue || v == Type::IfcModulusOfElasticityMeasure || v == Type::IfcModulusOfLinearSubgradeReactionMeasure || v == Type::IfcModulusOfRotationalSubgradeReactionMeasure || v == Type::IfcModulusOfSubgradeReactionMeasure || v == Type::IfcMoistureDiffusivityMeasure || v == Type::IfcMolecularWeightMeasure || v == Type::IfcMomentOfInertiaMeasure || v == Type::IfcMonetaryMeasure || v == Type::IfcNonNegativeLengthMeasure || v == Type::IfcNormalisedRatioMeasure || v == Type::IfcNullStyle || v == Type::IfcNumericMeasure || v == Type::IfcPHMeasure || v == Type::IfcParameterValue || v == Type::IfcPlanarForceMeasure || v == Type::IfcPlaneAngleMeasure || v == Type::IfcPositiveInteger || v == Type::IfcPositiveLengthMeasure || v == Type::IfcPositivePlaneAngleMeasure || v == Type::IfcPositiveRatioMeasure || v == Type::IfcPowerMeasure || v == Type::IfcPressureMeasure || v == Type::IfcPropertySetDefinitionSet || v == Type::IfcRadioActivityMeasure || v == Type::IfcRatioMeasure || v == Type::IfcReal || v == Type::IfcRotationalFrequencyMeasure || v == Type::IfcRotationalMassMeasure || v == Type::IfcRotationalStiffnessMeasure || v == Type::IfcSectionModulusMeasure || v == Type::IfcSectionalAreaIntegralMeasure || v == Type::IfcShearModulusMeasure || v == Type::IfcSimpleValue || v == Type::IfcSolidAngleMeasure || v == Type::IfcSoundPowerLevelMeasure || v == Type::IfcSoundPowerMeasure || v == Type::IfcSoundPressureLevelMeasure || v == Type::IfcSoundPressureMeasure || v == Type::IfcSpecificHeatCapacityMeasure || v == Type::IfcSpecularExponent || v == Type::IfcSpecularRoughness || v == Type::IfcTemperatureGradientMeasure || v == Type::IfcTemperatureRateOfChangeMeasure || v == Type::IfcText || v == Type::IfcThermalAdmittanceMeasure || v == Type::IfcThermalConductivityMeasure || v == Type::IfcThermalExpansionCoefficientMeasure || v == Type::IfcThermalResistanceMeasure || v == Type::IfcThermalTransmittanceMeasure || v == Type::IfcThermodynamicTemperatureMeasure || v == Type::IfcTime || v == Type::IfcTimeMeasure || v == Type::IfcTimeStamp || v == Type::IfcTorqueMeasure || v == Type::IfcValue || v == Type::IfcVaporPermeabilityMeasure || v == Type::IfcVolumeMeasure || v == Type::IfcVolumetricFlowRateMeasure || v == Type::IfcWarpingConstantMeasure || v == Type::IfcWarpingMomentMeasure;
}


const char* IfcActionRequestTypeEnum::ToString(IfcActionRequestTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EMAIL", "FAX", "PHONE", "POST", "VERBAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActionRequestTypeEnum::IfcActionRequestTypeEnum IfcActionRequestTypeEnum::FromString(const std::string& s) {
    if (s == "EMAIL") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_EMAIL;
    if (s == "FAX") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_FAX;
    if (s == "PHONE") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_PHONE;
    if (s == "POST") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_POST;
    if (s == "VERBAL") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_VERBAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcActionSourceTypeEnum::ToString(IfcActionSourceTypeEnum v) {
    if ( v < 0 || v >= 27 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DEAD_LOAD_G", "COMPLETION_G1", "LIVE_LOAD_Q", "SNOW_S", "WIND_W", "PRESTRESSING_P", "SETTLEMENT_U", "TEMPERATURE_T", "EARTHQUAKE_E", "FIRE", "IMPULSE", "IMPACT", "TRANSPORT", "ERECTION", "PROPPING", "SYSTEM_IMPERFECTION", "SHRINKAGE", "CREEP", "LACK_OF_FIT", "BUOYANCY", "ICE", "CURRENT", "WAVE", "RAIN", "BRAKES", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActionSourceTypeEnum::IfcActionSourceTypeEnum IfcActionSourceTypeEnum::FromString(const std::string& s) {
    if (s == "DEAD_LOAD_G") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_DEAD_LOAD_G;
    if (s == "COMPLETION_G1") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_COMPLETION_G1;
    if (s == "LIVE_LOAD_Q") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_LIVE_LOAD_Q;
    if (s == "SNOW_S") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_SNOW_S;
    if (s == "WIND_W") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_WIND_W;
    if (s == "PRESTRESSING_P") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_PRESTRESSING_P;
    if (s == "SETTLEMENT_U") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_SETTLEMENT_U;
    if (s == "TEMPERATURE_T") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_TEMPERATURE_T;
    if (s == "EARTHQUAKE_E") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_EARTHQUAKE_E;
    if (s == "FIRE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_FIRE;
    if (s == "IMPULSE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_IMPULSE;
    if (s == "IMPACT") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_IMPACT;
    if (s == "TRANSPORT") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_TRANSPORT;
    if (s == "ERECTION") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_ERECTION;
    if (s == "PROPPING") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_PROPPING;
    if (s == "SYSTEM_IMPERFECTION") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_SYSTEM_IMPERFECTION;
    if (s == "SHRINKAGE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_SHRINKAGE;
    if (s == "CREEP") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_CREEP;
    if (s == "LACK_OF_FIT") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_LACK_OF_FIT;
    if (s == "BUOYANCY") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_BUOYANCY;
    if (s == "ICE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_ICE;
    if (s == "CURRENT") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_CURRENT;
    if (s == "WAVE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_WAVE;
    if (s == "RAIN") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_RAIN;
    if (s == "BRAKES") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_BRAKES;
    if (s == "USERDEFINED") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcActionTypeEnum::ToString(IfcActionTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PERMANENT_G", "VARIABLE_Q", "EXTRAORDINARY_A", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActionTypeEnum::IfcActionTypeEnum IfcActionTypeEnum::FromString(const std::string& s) {
    if (s == "PERMANENT_G") return ::Ifc4::IfcActionTypeEnum::IfcActionType_PERMANENT_G;
    if (s == "VARIABLE_Q") return ::Ifc4::IfcActionTypeEnum::IfcActionType_VARIABLE_Q;
    if (s == "EXTRAORDINARY_A") return ::Ifc4::IfcActionTypeEnum::IfcActionType_EXTRAORDINARY_A;
    if (s == "USERDEFINED") return ::Ifc4::IfcActionTypeEnum::IfcActionType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcActionTypeEnum::IfcActionType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcActuatorTypeEnum::ToString(IfcActuatorTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELECTRICACTUATOR", "HANDOPERATEDACTUATOR", "HYDRAULICACTUATOR", "PNEUMATICACTUATOR", "THERMOSTATICACTUATOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActuatorTypeEnum::IfcActuatorTypeEnum IfcActuatorTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRICACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_ELECTRICACTUATOR;
    if (s == "HANDOPERATEDACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_HANDOPERATEDACTUATOR;
    if (s == "HYDRAULICACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_HYDRAULICACTUATOR;
    if (s == "PNEUMATICACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_PNEUMATICACTUATOR;
    if (s == "THERMOSTATICACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_THERMOSTATICACTUATOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAddressTypeEnum::ToString(IfcAddressTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "OFFICE", "SITE", "HOME", "DISTRIBUTIONPOINT", "USERDEFINED" };
    return names[v];
}

IfcAddressTypeEnum::IfcAddressTypeEnum IfcAddressTypeEnum::FromString(const std::string& s) {
    if (s == "OFFICE") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_OFFICE;
    if (s == "SITE") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_SITE;
    if (s == "HOME") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_HOME;
    if (s == "DISTRIBUTIONPOINT") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_DISTRIBUTIONPOINT;
    if (s == "USERDEFINED") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAirTerminalBoxTypeEnum::ToString(IfcAirTerminalBoxTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONSTANTFLOW", "VARIABLEFLOWPRESSUREDEPENDANT", "VARIABLEFLOWPRESSUREINDEPENDANT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum IfcAirTerminalBoxTypeEnum::FromString(const std::string& s) {
    if (s == "CONSTANTFLOW") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_CONSTANTFLOW;
    if (s == "VARIABLEFLOWPRESSUREDEPENDANT") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREDEPENDANT;
    if (s == "VARIABLEFLOWPRESSUREINDEPENDANT") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREINDEPENDANT;
    if (s == "USERDEFINED") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAirTerminalTypeEnum::ToString(IfcAirTerminalTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DIFFUSER", "GRILLE", "LOUVRE", "REGISTER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum IfcAirTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "DIFFUSER") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_DIFFUSER;
    if (s == "GRILLE") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_GRILLE;
    if (s == "LOUVRE") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_LOUVRE;
    if (s == "REGISTER") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_REGISTER;
    if (s == "USERDEFINED") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAirToAirHeatRecoveryTypeEnum::ToString(IfcAirToAirHeatRecoveryTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FIXEDPLATECOUNTERFLOWEXCHANGER", "FIXEDPLATECROSSFLOWEXCHANGER", "FIXEDPLATEPARALLELFLOWEXCHANGER", "ROTARYWHEEL", "RUNAROUNDCOILLOOP", "HEATPIPE", "TWINTOWERENTHALPYRECOVERYLOOPS", "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS", "THERMOSIPHONCOILTYPEHEATEXCHANGERS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum IfcAirToAirHeatRecoveryTypeEnum::FromString(const std::string& s) {
    if (s == "FIXEDPLATECOUNTERFLOWEXCHANGER") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATECOUNTERFLOWEXCHANGER;
    if (s == "FIXEDPLATECROSSFLOWEXCHANGER") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATECROSSFLOWEXCHANGER;
    if (s == "FIXEDPLATEPARALLELFLOWEXCHANGER") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATEPARALLELFLOWEXCHANGER;
    if (s == "ROTARYWHEEL") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_ROTARYWHEEL;
    if (s == "RUNAROUNDCOILLOOP") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_RUNAROUNDCOILLOOP;
    if (s == "HEATPIPE") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_HEATPIPE;
    if (s == "TWINTOWERENTHALPYRECOVERYLOOPS") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_TWINTOWERENTHALPYRECOVERYLOOPS;
    if (s == "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_THERMOSIPHONSEALEDTUBEHEATEXCHANGERS;
    if (s == "THERMOSIPHONCOILTYPEHEATEXCHANGERS") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_THERMOSIPHONCOILTYPEHEATEXCHANGERS;
    if (s == "USERDEFINED") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAlarmTypeEnum::ToString(IfcAlarmTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BELL", "BREAKGLASSBUTTON", "LIGHT", "MANUALPULLBOX", "SIREN", "WHISTLE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAlarmTypeEnum::IfcAlarmTypeEnum IfcAlarmTypeEnum::FromString(const std::string& s) {
    if (s == "BELL") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_BELL;
    if (s == "BREAKGLASSBUTTON") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_BREAKGLASSBUTTON;
    if (s == "LIGHT") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_LIGHT;
    if (s == "MANUALPULLBOX") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_MANUALPULLBOX;
    if (s == "SIREN") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_SIREN;
    if (s == "WHISTLE") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_WHISTLE;
    if (s == "USERDEFINED") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAnalysisModelTypeEnum::ToString(IfcAnalysisModelTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "IN_PLANE_LOADING_2D", "OUT_PLANE_LOADING_2D", "LOADING_3D", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum IfcAnalysisModelTypeEnum::FromString(const std::string& s) {
    if (s == "IN_PLANE_LOADING_2D") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_IN_PLANE_LOADING_2D;
    if (s == "OUT_PLANE_LOADING_2D") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_OUT_PLANE_LOADING_2D;
    if (s == "LOADING_3D") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_LOADING_3D;
    if (s == "USERDEFINED") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAnalysisTheoryTypeEnum::ToString(IfcAnalysisTheoryTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FIRST_ORDER_THEORY", "SECOND_ORDER_THEORY", "THIRD_ORDER_THEORY", "FULL_NONLINEAR_THEORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum IfcAnalysisTheoryTypeEnum::FromString(const std::string& s) {
    if (s == "FIRST_ORDER_THEORY") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_FIRST_ORDER_THEORY;
    if (s == "SECOND_ORDER_THEORY") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_SECOND_ORDER_THEORY;
    if (s == "THIRD_ORDER_THEORY") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_THIRD_ORDER_THEORY;
    if (s == "FULL_NONLINEAR_THEORY") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_FULL_NONLINEAR_THEORY;
    if (s == "USERDEFINED") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcArithmeticOperatorEnum::ToString(IfcArithmeticOperatorEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ADD", "DIVIDE", "MULTIPLY", "SUBTRACT" };
    return names[v];
}

IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum IfcArithmeticOperatorEnum::FromString(const std::string& s) {
    if (s == "ADD") return ::Ifc4::IfcArithmeticOperatorEnum::IfcArithmeticOperator_ADD;
    if (s == "DIVIDE") return ::Ifc4::IfcArithmeticOperatorEnum::IfcArithmeticOperator_DIVIDE;
    if (s == "MULTIPLY") return ::Ifc4::IfcArithmeticOperatorEnum::IfcArithmeticOperator_MULTIPLY;
    if (s == "SUBTRACT") return ::Ifc4::IfcArithmeticOperatorEnum::IfcArithmeticOperator_SUBTRACT;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAssemblyPlaceEnum::ToString(IfcAssemblyPlaceEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SITE", "FACTORY", "NOTDEFINED" };
    return names[v];
}

IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum IfcAssemblyPlaceEnum::FromString(const std::string& s) {
    if (s == "SITE") return ::Ifc4::IfcAssemblyPlaceEnum::IfcAssemblyPlace_SITE;
    if (s == "FACTORY") return ::Ifc4::IfcAssemblyPlaceEnum::IfcAssemblyPlace_FACTORY;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAssemblyPlaceEnum::IfcAssemblyPlace_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAudioVisualApplianceTypeEnum::ToString(IfcAudioVisualApplianceTypeEnum v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AMPLIFIER", "CAMERA", "DISPLAY", "MICROPHONE", "PLAYER", "PROJECTOR", "RECEIVER", "SPEAKER", "SWITCHER", "TELEPHONE", "TUNER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum IfcAudioVisualApplianceTypeEnum::FromString(const std::string& s) {
    if (s == "AMPLIFIER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_AMPLIFIER;
    if (s == "CAMERA") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_CAMERA;
    if (s == "DISPLAY") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_DISPLAY;
    if (s == "MICROPHONE") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_MICROPHONE;
    if (s == "PLAYER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_PLAYER;
    if (s == "PROJECTOR") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_PROJECTOR;
    if (s == "RECEIVER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_RECEIVER;
    if (s == "SPEAKER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_SPEAKER;
    if (s == "SWITCHER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_SWITCHER;
    if (s == "TELEPHONE") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_TELEPHONE;
    if (s == "TUNER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_TUNER;
    if (s == "USERDEFINED") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBSplineCurveForm::ToString(IfcBSplineCurveForm v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POLYLINE_FORM", "CIRCULAR_ARC", "ELLIPTIC_ARC", "PARABOLIC_ARC", "HYPERBOLIC_ARC", "UNSPECIFIED" };
    return names[v];
}

IfcBSplineCurveForm::IfcBSplineCurveForm IfcBSplineCurveForm::FromString(const std::string& s) {
    if (s == "POLYLINE_FORM") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_POLYLINE_FORM;
    if (s == "CIRCULAR_ARC") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_CIRCULAR_ARC;
    if (s == "ELLIPTIC_ARC") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_ELLIPTIC_ARC;
    if (s == "PARABOLIC_ARC") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_PARABOLIC_ARC;
    if (s == "HYPERBOLIC_ARC") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_HYPERBOLIC_ARC;
    if (s == "UNSPECIFIED") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBSplineSurfaceForm::ToString(IfcBSplineSurfaceForm v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PLANE_SURF", "CYLINDRICAL_SURF", "CONICAL_SURF", "SPHERICAL_SURF", "TOROIDAL_SURF", "SURF_OF_REVOLUTION", "RULED_SURF", "GENERALISED_CONE", "QUADRIC_SURF", "SURF_OF_LINEAR_EXTRUSION", "UNSPECIFIED" };
    return names[v];
}

IfcBSplineSurfaceForm::IfcBSplineSurfaceForm IfcBSplineSurfaceForm::FromString(const std::string& s) {
    if (s == "PLANE_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_PLANE_SURF;
    if (s == "CYLINDRICAL_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_CYLINDRICAL_SURF;
    if (s == "CONICAL_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_CONICAL_SURF;
    if (s == "SPHERICAL_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_SPHERICAL_SURF;
    if (s == "TOROIDAL_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_TOROIDAL_SURF;
    if (s == "SURF_OF_REVOLUTION") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_SURF_OF_REVOLUTION;
    if (s == "RULED_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_RULED_SURF;
    if (s == "GENERALISED_CONE") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_GENERALISED_CONE;
    if (s == "QUADRIC_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_QUADRIC_SURF;
    if (s == "SURF_OF_LINEAR_EXTRUSION") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_SURF_OF_LINEAR_EXTRUSION;
    if (s == "UNSPECIFIED") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBeamTypeEnum::ToString(IfcBeamTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEAM", "JOIST", "HOLLOWCORE", "LINTEL", "SPANDREL", "T_BEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBeamTypeEnum::IfcBeamTypeEnum IfcBeamTypeEnum::FromString(const std::string& s) {
    if (s == "BEAM") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_BEAM;
    if (s == "JOIST") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_JOIST;
    if (s == "HOLLOWCORE") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_HOLLOWCORE;
    if (s == "LINTEL") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_LINTEL;
    if (s == "SPANDREL") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_SPANDREL;
    if (s == "T_BEAM") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_T_BEAM;
    if (s == "USERDEFINED") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBenchmarkEnum::ToString(IfcBenchmarkEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GREATERTHAN", "GREATERTHANOREQUALTO", "LESSTHAN", "LESSTHANOREQUALTO", "EQUALTO", "NOTEQUALTO", "INCLUDES", "NOTINCLUDES", "INCLUDEDIN", "NOTINCLUDEDIN" };
    return names[v];
}

IfcBenchmarkEnum::IfcBenchmarkEnum IfcBenchmarkEnum::FromString(const std::string& s) {
    if (s == "GREATERTHAN") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_GREATERTHAN;
    if (s == "GREATERTHANOREQUALTO") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_GREATERTHANOREQUALTO;
    if (s == "LESSTHAN") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_LESSTHAN;
    if (s == "LESSTHANOREQUALTO") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_LESSTHANOREQUALTO;
    if (s == "EQUALTO") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_EQUALTO;
    if (s == "NOTEQUALTO") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_NOTEQUALTO;
    if (s == "INCLUDES") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_INCLUDES;
    if (s == "NOTINCLUDES") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_NOTINCLUDES;
    if (s == "INCLUDEDIN") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_INCLUDEDIN;
    if (s == "NOTINCLUDEDIN") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_NOTINCLUDEDIN;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBoilerTypeEnum::ToString(IfcBoilerTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "WATER", "STEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBoilerTypeEnum::IfcBoilerTypeEnum IfcBoilerTypeEnum::FromString(const std::string& s) {
    if (s == "WATER") return ::Ifc4::IfcBoilerTypeEnum::IfcBoilerType_WATER;
    if (s == "STEAM") return ::Ifc4::IfcBoilerTypeEnum::IfcBoilerType_STEAM;
    if (s == "USERDEFINED") return ::Ifc4::IfcBoilerTypeEnum::IfcBoilerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBoilerTypeEnum::IfcBoilerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBooleanOperator::ToString(IfcBooleanOperator v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "UNION", "INTERSECTION", "DIFFERENCE" };
    return names[v];
}

IfcBooleanOperator::IfcBooleanOperator IfcBooleanOperator::FromString(const std::string& s) {
    if (s == "UNION") return ::Ifc4::IfcBooleanOperator::IfcBooleanOperator_UNION;
    if (s == "INTERSECTION") return ::Ifc4::IfcBooleanOperator::IfcBooleanOperator_INTERSECTION;
    if (s == "DIFFERENCE") return ::Ifc4::IfcBooleanOperator::IfcBooleanOperator_DIFFERENCE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBuildingElementPartTypeEnum::ToString(IfcBuildingElementPartTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "INSULATION", "PRECASTPANEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum IfcBuildingElementPartTypeEnum::FromString(const std::string& s) {
    if (s == "INSULATION") return ::Ifc4::IfcBuildingElementPartTypeEnum::IfcBuildingElementPartType_INSULATION;
    if (s == "PRECASTPANEL") return ::Ifc4::IfcBuildingElementPartTypeEnum::IfcBuildingElementPartType_PRECASTPANEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcBuildingElementPartTypeEnum::IfcBuildingElementPartType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBuildingElementPartTypeEnum::IfcBuildingElementPartType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBuildingElementProxyTypeEnum::ToString(IfcBuildingElementProxyTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPLEX", "ELEMENT", "PARTIAL", "PROVISIONFORVOID", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum IfcBuildingElementProxyTypeEnum::FromString(const std::string& s) {
    if (s == "COMPLEX") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_COMPLEX;
    if (s == "ELEMENT") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_ELEMENT;
    if (s == "PARTIAL") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_PARTIAL;
    if (s == "PROVISIONFORVOID") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_PROVISIONFORVOID;
    if (s == "USERDEFINED") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBuildingSystemTypeEnum::ToString(IfcBuildingSystemTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FENESTRATION", "FOUNDATION", "LOADBEARING", "OUTERSHELL", "SHADING", "TRANSPORT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum IfcBuildingSystemTypeEnum::FromString(const std::string& s) {
    if (s == "FENESTRATION") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_FENESTRATION;
    if (s == "FOUNDATION") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_FOUNDATION;
    if (s == "LOADBEARING") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_LOADBEARING;
    if (s == "OUTERSHELL") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_OUTERSHELL;
    if (s == "SHADING") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_SHADING;
    if (s == "TRANSPORT") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_TRANSPORT;
    if (s == "USERDEFINED") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBurnerTypeEnum::ToString(IfcBurnerTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBurnerTypeEnum::IfcBurnerTypeEnum IfcBurnerTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcBurnerTypeEnum::IfcBurnerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBurnerTypeEnum::IfcBurnerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableCarrierFittingTypeEnum::ToString(IfcCableCarrierFittingTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEND", "CROSS", "REDUCER", "TEE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum IfcCableCarrierFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_BEND;
    if (s == "CROSS") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_CROSS;
    if (s == "REDUCER") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_REDUCER;
    if (s == "TEE") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_TEE;
    if (s == "USERDEFINED") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableCarrierSegmentTypeEnum::ToString(IfcCableCarrierSegmentTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CABLELADDERSEGMENT", "CABLETRAYSEGMENT", "CABLETRUNKINGSEGMENT", "CONDUITSEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum IfcCableCarrierSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "CABLELADDERSEGMENT") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLELADDERSEGMENT;
    if (s == "CABLETRAYSEGMENT") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLETRAYSEGMENT;
    if (s == "CABLETRUNKINGSEGMENT") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLETRUNKINGSEGMENT;
    if (s == "CONDUITSEGMENT") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CONDUITSEGMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableFittingTypeEnum::ToString(IfcCableFittingTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableFittingTypeEnum::IfcCableFittingTypeEnum IfcCableFittingTypeEnum::FromString(const std::string& s) {
    if (s == "CONNECTOR") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_JUNCTION;
    if (s == "TRANSITION") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableSegmentTypeEnum::ToString(IfcCableSegmentTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BUSBARSEGMENT", "CABLESEGMENT", "CONDUCTORSEGMENT", "CORESEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum IfcCableSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "BUSBARSEGMENT") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_BUSBARSEGMENT;
    if (s == "CABLESEGMENT") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_CABLESEGMENT;
    if (s == "CONDUCTORSEGMENT") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_CONDUCTORSEGMENT;
    if (s == "CORESEGMENT") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_CORESEGMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcChangeActionEnum::ToString(IfcChangeActionEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "NOCHANGE", "MODIFIED", "ADDED", "DELETED", "NOTDEFINED" };
    return names[v];
}

IfcChangeActionEnum::IfcChangeActionEnum IfcChangeActionEnum::FromString(const std::string& s) {
    if (s == "NOCHANGE") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_NOCHANGE;
    if (s == "MODIFIED") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_MODIFIED;
    if (s == "ADDED") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_ADDED;
    if (s == "DELETED") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_DELETED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcChillerTypeEnum::ToString(IfcChillerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRCOOLED", "WATERCOOLED", "HEATRECOVERY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcChillerTypeEnum::IfcChillerTypeEnum IfcChillerTypeEnum::FromString(const std::string& s) {
    if (s == "AIRCOOLED") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_AIRCOOLED;
    if (s == "WATERCOOLED") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_WATERCOOLED;
    if (s == "HEATRECOVERY") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_HEATRECOVERY;
    if (s == "USERDEFINED") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcChimneyTypeEnum::ToString(IfcChimneyTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcChimneyTypeEnum::IfcChimneyTypeEnum IfcChimneyTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcChimneyTypeEnum::IfcChimneyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcChimneyTypeEnum::IfcChimneyType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCoilTypeEnum::ToString(IfcCoilTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DXCOOLINGCOIL", "ELECTRICHEATINGCOIL", "GASHEATINGCOIL", "HYDRONICCOIL", "STEAMHEATINGCOIL", "WATERCOOLINGCOIL", "WATERHEATINGCOIL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCoilTypeEnum::IfcCoilTypeEnum IfcCoilTypeEnum::FromString(const std::string& s) {
    if (s == "DXCOOLINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_DXCOOLINGCOIL;
    if (s == "ELECTRICHEATINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_ELECTRICHEATINGCOIL;
    if (s == "GASHEATINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_GASHEATINGCOIL;
    if (s == "HYDRONICCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_HYDRONICCOIL;
    if (s == "STEAMHEATINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_STEAMHEATINGCOIL;
    if (s == "WATERCOOLINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_WATERCOOLINGCOIL;
    if (s == "WATERHEATINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_WATERHEATINGCOIL;
    if (s == "USERDEFINED") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcColumnTypeEnum::ToString(IfcColumnTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COLUMN", "PILASTER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcColumnTypeEnum::IfcColumnTypeEnum IfcColumnTypeEnum::FromString(const std::string& s) {
    if (s == "COLUMN") return ::Ifc4::IfcColumnTypeEnum::IfcColumnType_COLUMN;
    if (s == "PILASTER") return ::Ifc4::IfcColumnTypeEnum::IfcColumnType_PILASTER;
    if (s == "USERDEFINED") return ::Ifc4::IfcColumnTypeEnum::IfcColumnType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcColumnTypeEnum::IfcColumnType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCommunicationsApplianceTypeEnum::ToString(IfcCommunicationsApplianceTypeEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANTENNA", "COMPUTER", "FAX", "GATEWAY", "MODEM", "NETWORKAPPLIANCE", "NETWORKBRIDGE", "NETWORKHUB", "PRINTER", "REPEATER", "ROUTER", "SCANNER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum IfcCommunicationsApplianceTypeEnum::FromString(const std::string& s) {
    if (s == "ANTENNA") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_ANTENNA;
    if (s == "COMPUTER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_COMPUTER;
    if (s == "FAX") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_FAX;
    if (s == "GATEWAY") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_GATEWAY;
    if (s == "MODEM") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_MODEM;
    if (s == "NETWORKAPPLIANCE") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_NETWORKAPPLIANCE;
    if (s == "NETWORKBRIDGE") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_NETWORKBRIDGE;
    if (s == "NETWORKHUB") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_NETWORKHUB;
    if (s == "PRINTER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_PRINTER;
    if (s == "REPEATER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_REPEATER;
    if (s == "ROUTER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_ROUTER;
    if (s == "SCANNER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_SCANNER;
    if (s == "USERDEFINED") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcComplexPropertyTemplateTypeEnum::ToString(IfcComplexPropertyTemplateTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "P_COMPLEX", "Q_COMPLEX" };
    return names[v];
}

IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum IfcComplexPropertyTemplateTypeEnum::FromString(const std::string& s) {
    if (s == "P_COMPLEX") return ::Ifc4::IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateType_P_COMPLEX;
    if (s == "Q_COMPLEX") return ::Ifc4::IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateType_Q_COMPLEX;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCompressorTypeEnum::ToString(IfcCompressorTypeEnum v) {
    if ( v < 0 || v >= 17 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DYNAMIC", "RECIPROCATING", "ROTARY", "SCROLL", "TROCHOIDAL", "SINGLESTAGE", "BOOSTER", "OPENTYPE", "HERMETIC", "SEMIHERMETIC", "WELDEDSHELLHERMETIC", "ROLLINGPISTON", "ROTARYVANE", "SINGLESCREW", "TWINSCREW", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCompressorTypeEnum::IfcCompressorTypeEnum IfcCompressorTypeEnum::FromString(const std::string& s) {
    if (s == "DYNAMIC") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_DYNAMIC;
    if (s == "RECIPROCATING") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_RECIPROCATING;
    if (s == "ROTARY") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_ROTARY;
    if (s == "SCROLL") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_SCROLL;
    if (s == "TROCHOIDAL") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_TROCHOIDAL;
    if (s == "SINGLESTAGE") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_SINGLESTAGE;
    if (s == "BOOSTER") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_BOOSTER;
    if (s == "OPENTYPE") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_OPENTYPE;
    if (s == "HERMETIC") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_HERMETIC;
    if (s == "SEMIHERMETIC") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_SEMIHERMETIC;
    if (s == "WELDEDSHELLHERMETIC") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_WELDEDSHELLHERMETIC;
    if (s == "ROLLINGPISTON") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_ROLLINGPISTON;
    if (s == "ROTARYVANE") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_ROTARYVANE;
    if (s == "SINGLESCREW") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_SINGLESCREW;
    if (s == "TWINSCREW") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_TWINSCREW;
    if (s == "USERDEFINED") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCondenserTypeEnum::ToString(IfcCondenserTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRCOOLED", "EVAPORATIVECOOLED", "WATERCOOLED", "WATERCOOLEDBRAZEDPLATE", "WATERCOOLEDSHELLCOIL", "WATERCOOLEDSHELLTUBE", "WATERCOOLEDTUBEINTUBE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCondenserTypeEnum::IfcCondenserTypeEnum IfcCondenserTypeEnum::FromString(const std::string& s) {
    if (s == "AIRCOOLED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_AIRCOOLED;
    if (s == "EVAPORATIVECOOLED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_EVAPORATIVECOOLED;
    if (s == "WATERCOOLED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLED;
    if (s == "WATERCOOLEDBRAZEDPLATE") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDBRAZEDPLATE;
    if (s == "WATERCOOLEDSHELLCOIL") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDSHELLCOIL;
    if (s == "WATERCOOLEDSHELLTUBE") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDSHELLTUBE;
    if (s == "WATERCOOLEDTUBEINTUBE") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDTUBEINTUBE;
    if (s == "USERDEFINED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConnectionTypeEnum::ToString(IfcConnectionTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ATPATH", "ATSTART", "ATEND", "NOTDEFINED" };
    return names[v];
}

IfcConnectionTypeEnum::IfcConnectionTypeEnum IfcConnectionTypeEnum::FromString(const std::string& s) {
    if (s == "ATPATH") return ::Ifc4::IfcConnectionTypeEnum::IfcConnectionType_ATPATH;
    if (s == "ATSTART") return ::Ifc4::IfcConnectionTypeEnum::IfcConnectionType_ATSTART;
    if (s == "ATEND") return ::Ifc4::IfcConnectionTypeEnum::IfcConnectionType_ATEND;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConnectionTypeEnum::IfcConnectionType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConstraintEnum::ToString(IfcConstraintEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "HARD", "SOFT", "ADVISORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcConstraintEnum::IfcConstraintEnum IfcConstraintEnum::FromString(const std::string& s) {
    if (s == "HARD") return ::Ifc4::IfcConstraintEnum::IfcConstraint_HARD;
    if (s == "SOFT") return ::Ifc4::IfcConstraintEnum::IfcConstraint_SOFT;
    if (s == "ADVISORY") return ::Ifc4::IfcConstraintEnum::IfcConstraint_ADVISORY;
    if (s == "USERDEFINED") return ::Ifc4::IfcConstraintEnum::IfcConstraint_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConstraintEnum::IfcConstraint_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConstructionEquipmentResourceTypeEnum::ToString(IfcConstructionEquipmentResourceTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DEMOLISHING", "EARTHMOVING", "ERECTING", "HEATING", "LIGHTING", "PAVING", "PUMPING", "TRANSPORTING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum IfcConstructionEquipmentResourceTypeEnum::FromString(const std::string& s) {
    if (s == "DEMOLISHING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_DEMOLISHING;
    if (s == "EARTHMOVING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_EARTHMOVING;
    if (s == "ERECTING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_ERECTING;
    if (s == "HEATING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_HEATING;
    if (s == "LIGHTING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_LIGHTING;
    if (s == "PAVING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_PAVING;
    if (s == "PUMPING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_PUMPING;
    if (s == "TRANSPORTING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_TRANSPORTING;
    if (s == "USERDEFINED") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConstructionMaterialResourceTypeEnum::ToString(IfcConstructionMaterialResourceTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AGGREGATES", "CONCRETE", "DRYWALL", "FUEL", "GYPSUM", "MASONRY", "METAL", "PLASTIC", "WOOD", "NOTDEFINED", "USERDEFINED" };
    return names[v];
}

IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum IfcConstructionMaterialResourceTypeEnum::FromString(const std::string& s) {
    if (s == "AGGREGATES") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_AGGREGATES;
    if (s == "CONCRETE") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_CONCRETE;
    if (s == "DRYWALL") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_DRYWALL;
    if (s == "FUEL") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_FUEL;
    if (s == "GYPSUM") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_GYPSUM;
    if (s == "MASONRY") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_MASONRY;
    if (s == "METAL") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_METAL;
    if (s == "PLASTIC") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_PLASTIC;
    if (s == "WOOD") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_WOOD;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_NOTDEFINED;
    if (s == "USERDEFINED") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConstructionProductResourceTypeEnum::ToString(IfcConstructionProductResourceTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ASSEMBLY", "FORMWORK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum IfcConstructionProductResourceTypeEnum::FromString(const std::string& s) {
    if (s == "ASSEMBLY") return ::Ifc4::IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceType_ASSEMBLY;
    if (s == "FORMWORK") return ::Ifc4::IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceType_FORMWORK;
    if (s == "USERDEFINED") return ::Ifc4::IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcControllerTypeEnum::ToString(IfcControllerTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLOATING", "PROGRAMMABLE", "PROPORTIONAL", "MULTIPOSITION", "TWOPOSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcControllerTypeEnum::IfcControllerTypeEnum IfcControllerTypeEnum::FromString(const std::string& s) {
    if (s == "FLOATING") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_FLOATING;
    if (s == "PROGRAMMABLE") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_PROGRAMMABLE;
    if (s == "PROPORTIONAL") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_PROPORTIONAL;
    if (s == "MULTIPOSITION") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_MULTIPOSITION;
    if (s == "TWOPOSITION") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_TWOPOSITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCooledBeamTypeEnum::ToString(IfcCooledBeamTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACTIVE", "PASSIVE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum IfcCooledBeamTypeEnum::FromString(const std::string& s) {
    if (s == "ACTIVE") return ::Ifc4::IfcCooledBeamTypeEnum::IfcCooledBeamType_ACTIVE;
    if (s == "PASSIVE") return ::Ifc4::IfcCooledBeamTypeEnum::IfcCooledBeamType_PASSIVE;
    if (s == "USERDEFINED") return ::Ifc4::IfcCooledBeamTypeEnum::IfcCooledBeamType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCooledBeamTypeEnum::IfcCooledBeamType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCoolingTowerTypeEnum::ToString(IfcCoolingTowerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "NATURALDRAFT", "MECHANICALINDUCEDDRAFT", "MECHANICALFORCEDDRAFT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum IfcCoolingTowerTypeEnum::FromString(const std::string& s) {
    if (s == "NATURALDRAFT") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_NATURALDRAFT;
    if (s == "MECHANICALINDUCEDDRAFT") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_MECHANICALINDUCEDDRAFT;
    if (s == "MECHANICALFORCEDDRAFT") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_MECHANICALFORCEDDRAFT;
    if (s == "USERDEFINED") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCostItemTypeEnum::ToString(IfcCostItemTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCostItemTypeEnum::IfcCostItemTypeEnum IfcCostItemTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcCostItemTypeEnum::IfcCostItemType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCostItemTypeEnum::IfcCostItemType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCostScheduleTypeEnum::ToString(IfcCostScheduleTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BUDGET", "COSTPLAN", "ESTIMATE", "TENDER", "PRICEDBILLOFQUANTITIES", "UNPRICEDBILLOFQUANTITIES", "SCHEDULEOFRATES", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum IfcCostScheduleTypeEnum::FromString(const std::string& s) {
    if (s == "BUDGET") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_BUDGET;
    if (s == "COSTPLAN") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_COSTPLAN;
    if (s == "ESTIMATE") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_ESTIMATE;
    if (s == "TENDER") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_TENDER;
    if (s == "PRICEDBILLOFQUANTITIES") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_PRICEDBILLOFQUANTITIES;
    if (s == "UNPRICEDBILLOFQUANTITIES") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_UNPRICEDBILLOFQUANTITIES;
    if (s == "SCHEDULEOFRATES") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_SCHEDULEOFRATES;
    if (s == "USERDEFINED") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCoveringTypeEnum::ToString(IfcCoveringTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CEILING", "FLOORING", "CLADDING", "ROOFING", "MOLDING", "SKIRTINGBOARD", "INSULATION", "MEMBRANE", "SLEEVING", "WRAPPING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCoveringTypeEnum::IfcCoveringTypeEnum IfcCoveringTypeEnum::FromString(const std::string& s) {
    if (s == "CEILING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_CEILING;
    if (s == "FLOORING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_FLOORING;
    if (s == "CLADDING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_CLADDING;
    if (s == "ROOFING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_ROOFING;
    if (s == "MOLDING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_MOLDING;
    if (s == "SKIRTINGBOARD") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_SKIRTINGBOARD;
    if (s == "INSULATION") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_INSULATION;
    if (s == "MEMBRANE") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_MEMBRANE;
    if (s == "SLEEVING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_SLEEVING;
    if (s == "WRAPPING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_WRAPPING;
    if (s == "USERDEFINED") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCrewResourceTypeEnum::ToString(IfcCrewResourceTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "OFFICE", "SITE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum IfcCrewResourceTypeEnum::FromString(const std::string& s) {
    if (s == "OFFICE") return ::Ifc4::IfcCrewResourceTypeEnum::IfcCrewResourceType_OFFICE;
    if (s == "SITE") return ::Ifc4::IfcCrewResourceTypeEnum::IfcCrewResourceType_SITE;
    if (s == "USERDEFINED") return ::Ifc4::IfcCrewResourceTypeEnum::IfcCrewResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCrewResourceTypeEnum::IfcCrewResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCurtainWallTypeEnum::ToString(IfcCurtainWallTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum IfcCurtainWallTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcCurtainWallTypeEnum::IfcCurtainWallType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCurtainWallTypeEnum::IfcCurtainWallType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCurveInterpolationEnum::ToString(IfcCurveInterpolationEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LINEAR", "LOG_LINEAR", "LOG_LOG", "NOTDEFINED" };
    return names[v];
}

IfcCurveInterpolationEnum::IfcCurveInterpolationEnum IfcCurveInterpolationEnum::FromString(const std::string& s) {
    if (s == "LINEAR") return ::Ifc4::IfcCurveInterpolationEnum::IfcCurveInterpolation_LINEAR;
    if (s == "LOG_LINEAR") return ::Ifc4::IfcCurveInterpolationEnum::IfcCurveInterpolation_LOG_LINEAR;
    if (s == "LOG_LOG") return ::Ifc4::IfcCurveInterpolationEnum::IfcCurveInterpolation_LOG_LOG;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCurveInterpolationEnum::IfcCurveInterpolation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDamperTypeEnum::ToString(IfcDamperTypeEnum v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BACKDRAFTDAMPER", "BALANCINGDAMPER", "BLASTDAMPER", "CONTROLDAMPER", "FIREDAMPER", "FIRESMOKEDAMPER", "FUMEHOODEXHAUST", "GRAVITYDAMPER", "GRAVITYRELIEFDAMPER", "RELIEFDAMPER", "SMOKEDAMPER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDamperTypeEnum::IfcDamperTypeEnum IfcDamperTypeEnum::FromString(const std::string& s) {
    if (s == "BACKDRAFTDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_BACKDRAFTDAMPER;
    if (s == "BALANCINGDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_BALANCINGDAMPER;
    if (s == "BLASTDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_BLASTDAMPER;
    if (s == "CONTROLDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_CONTROLDAMPER;
    if (s == "FIREDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_FIREDAMPER;
    if (s == "FIRESMOKEDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_FIRESMOKEDAMPER;
    if (s == "FUMEHOODEXHAUST") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_FUMEHOODEXHAUST;
    if (s == "GRAVITYDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_GRAVITYDAMPER;
    if (s == "GRAVITYRELIEFDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_GRAVITYRELIEFDAMPER;
    if (s == "RELIEFDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_RELIEFDAMPER;
    if (s == "SMOKEDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_SMOKEDAMPER;
    if (s == "USERDEFINED") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDataOriginEnum::ToString(IfcDataOriginEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MEASURED", "PREDICTED", "SIMULATED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDataOriginEnum::IfcDataOriginEnum IfcDataOriginEnum::FromString(const std::string& s) {
    if (s == "MEASURED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_MEASURED;
    if (s == "PREDICTED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_PREDICTED;
    if (s == "SIMULATED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_SIMULATED;
    if (s == "USERDEFINED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDerivedUnitEnum::ToString(IfcDerivedUnitEnum v) {
    if ( v < 0 || v >= 53 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANGULARVELOCITYUNIT", "AREADENSITYUNIT", "COMPOUNDPLANEANGLEUNIT", "DYNAMICVISCOSITYUNIT", "HEATFLUXDENSITYUNIT", "INTEGERCOUNTRATEUNIT", "ISOTHERMALMOISTURECAPACITYUNIT", "KINEMATICVISCOSITYUNIT", "LINEARVELOCITYUNIT", "MASSDENSITYUNIT", "MASSFLOWRATEUNIT", "MOISTUREDIFFUSIVITYUNIT", "MOLECULARWEIGHTUNIT", "SPECIFICHEATCAPACITYUNIT", "THERMALADMITTANCEUNIT", "THERMALCONDUCTANCEUNIT", "THERMALRESISTANCEUNIT", "THERMALTRANSMITTANCEUNIT", "VAPORPERMEABILITYUNIT", "VOLUMETRICFLOWRATEUNIT", "ROTATIONALFREQUENCYUNIT", "TORQUEUNIT", "MOMENTOFINERTIAUNIT", "LINEARMOMENTUNIT", "LINEARFORCEUNIT", "PLANARFORCEUNIT", "MODULUSOFELASTICITYUNIT", "SHEARMODULUSUNIT", "LINEARSTIFFNESSUNIT", "ROTATIONALSTIFFNESSUNIT", "MODULUSOFSUBGRADEREACTIONUNIT", "ACCELERATIONUNIT", "CURVATUREUNIT", "HEATINGVALUEUNIT", "IONCONCENTRATIONUNIT", "LUMINOUSINTENSITYDISTRIBUTIONUNIT", "MASSPERLENGTHUNIT", "MODULUSOFLINEARSUBGRADEREACTIONUNIT", "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT", "PHUNIT", "ROTATIONALMASSUNIT", "SECTIONAREAINTEGRALUNIT", "SECTIONMODULUSUNIT", "SOUNDPOWERLEVELUNIT", "SOUNDPOWERUNIT", "SOUNDPRESSURELEVELUNIT", "SOUNDPRESSUREUNIT", "TEMPERATUREGRADIENTUNIT", "TEMPERATURERATEOFCHANGEUNIT", "THERMALEXPANSIONCOEFFICIENTUNIT", "WARPINGCONSTANTUNIT", "WARPINGMOMENTUNIT", "USERDEFINED" };
    return names[v];
}

IfcDerivedUnitEnum::IfcDerivedUnitEnum IfcDerivedUnitEnum::FromString(const std::string& s) {
    if (s == "ANGULARVELOCITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ANGULARVELOCITYUNIT;
    if (s == "AREADENSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_AREADENSITYUNIT;
    if (s == "COMPOUNDPLANEANGLEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_COMPOUNDPLANEANGLEUNIT;
    if (s == "DYNAMICVISCOSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_DYNAMICVISCOSITYUNIT;
    if (s == "HEATFLUXDENSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_HEATFLUXDENSITYUNIT;
    if (s == "INTEGERCOUNTRATEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_INTEGERCOUNTRATEUNIT;
    if (s == "ISOTHERMALMOISTURECAPACITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ISOTHERMALMOISTURECAPACITYUNIT;
    if (s == "KINEMATICVISCOSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_KINEMATICVISCOSITYUNIT;
    if (s == "LINEARVELOCITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARVELOCITYUNIT;
    if (s == "MASSDENSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MASSDENSITYUNIT;
    if (s == "MASSFLOWRATEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MASSFLOWRATEUNIT;
    if (s == "MOISTUREDIFFUSIVITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MOISTUREDIFFUSIVITYUNIT;
    if (s == "MOLECULARWEIGHTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MOLECULARWEIGHTUNIT;
    if (s == "SPECIFICHEATCAPACITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SPECIFICHEATCAPACITYUNIT;
    if (s == "THERMALADMITTANCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALADMITTANCEUNIT;
    if (s == "THERMALCONDUCTANCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALCONDUCTANCEUNIT;
    if (s == "THERMALRESISTANCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALRESISTANCEUNIT;
    if (s == "THERMALTRANSMITTANCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALTRANSMITTANCEUNIT;
    if (s == "VAPORPERMEABILITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_VAPORPERMEABILITYUNIT;
    if (s == "VOLUMETRICFLOWRATEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_VOLUMETRICFLOWRATEUNIT;
    if (s == "ROTATIONALFREQUENCYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALFREQUENCYUNIT;
    if (s == "TORQUEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_TORQUEUNIT;
    if (s == "MOMENTOFINERTIAUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MOMENTOFINERTIAUNIT;
    if (s == "LINEARMOMENTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARMOMENTUNIT;
    if (s == "LINEARFORCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARFORCEUNIT;
    if (s == "PLANARFORCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_PLANARFORCEUNIT;
    if (s == "MODULUSOFELASTICITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFELASTICITYUNIT;
    if (s == "SHEARMODULUSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SHEARMODULUSUNIT;
    if (s == "LINEARSTIFFNESSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARSTIFFNESSUNIT;
    if (s == "ROTATIONALSTIFFNESSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALSTIFFNESSUNIT;
    if (s == "MODULUSOFSUBGRADEREACTIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFSUBGRADEREACTIONUNIT;
    if (s == "ACCELERATIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ACCELERATIONUNIT;
    if (s == "CURVATUREUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_CURVATUREUNIT;
    if (s == "HEATINGVALUEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_HEATINGVALUEUNIT;
    if (s == "IONCONCENTRATIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_IONCONCENTRATIONUNIT;
    if (s == "LUMINOUSINTENSITYDISTRIBUTIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LUMINOUSINTENSITYDISTRIBUTIONUNIT;
    if (s == "MASSPERLENGTHUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MASSPERLENGTHUNIT;
    if (s == "MODULUSOFLINEARSUBGRADEREACTIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFLINEARSUBGRADEREACTIONUNIT;
    if (s == "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFROTATIONALSUBGRADEREACTIONUNIT;
    if (s == "PHUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_PHUNIT;
    if (s == "ROTATIONALMASSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALMASSUNIT;
    if (s == "SECTIONAREAINTEGRALUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SECTIONAREAINTEGRALUNIT;
    if (s == "SECTIONMODULUSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SECTIONMODULUSUNIT;
    if (s == "SOUNDPOWERLEVELUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPOWERLEVELUNIT;
    if (s == "SOUNDPOWERUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPOWERUNIT;
    if (s == "SOUNDPRESSURELEVELUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPRESSURELEVELUNIT;
    if (s == "SOUNDPRESSUREUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPRESSUREUNIT;
    if (s == "TEMPERATUREGRADIENTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_TEMPERATUREGRADIENTUNIT;
    if (s == "TEMPERATURERATEOFCHANGEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_TEMPERATURERATEOFCHANGEUNIT;
    if (s == "THERMALEXPANSIONCOEFFICIENTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALEXPANSIONCOEFFICIENTUNIT;
    if (s == "WARPINGCONSTANTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_WARPINGCONSTANTUNIT;
    if (s == "WARPINGMOMENTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_WARPINGMOMENTUNIT;
    if (s == "USERDEFINED") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDirectionSenseEnum::ToString(IfcDirectionSenseEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POSITIVE", "NEGATIVE" };
    return names[v];
}

IfcDirectionSenseEnum::IfcDirectionSenseEnum IfcDirectionSenseEnum::FromString(const std::string& s) {
    if (s == "POSITIVE") return ::Ifc4::IfcDirectionSenseEnum::IfcDirectionSense_POSITIVE;
    if (s == "NEGATIVE") return ::Ifc4::IfcDirectionSenseEnum::IfcDirectionSense_NEGATIVE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDiscreteAccessoryTypeEnum::ToString(IfcDiscreteAccessoryTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANCHORPLATE", "BRACKET", "SHOE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum IfcDiscreteAccessoryTypeEnum::FromString(const std::string& s) {
    if (s == "ANCHORPLATE") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_ANCHORPLATE;
    if (s == "BRACKET") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_BRACKET;
    if (s == "SHOE") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_SHOE;
    if (s == "USERDEFINED") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDistributionChamberElementTypeEnum::ToString(IfcDistributionChamberElementTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FORMEDDUCT", "INSPECTIONCHAMBER", "INSPECTIONPIT", "MANHOLE", "METERCHAMBER", "SUMP", "TRENCH", "VALVECHAMBER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum IfcDistributionChamberElementTypeEnum::FromString(const std::string& s) {
    if (s == "FORMEDDUCT") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_FORMEDDUCT;
    if (s == "INSPECTIONCHAMBER") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_INSPECTIONCHAMBER;
    if (s == "INSPECTIONPIT") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_INSPECTIONPIT;
    if (s == "MANHOLE") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_MANHOLE;
    if (s == "METERCHAMBER") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_METERCHAMBER;
    if (s == "SUMP") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_SUMP;
    if (s == "TRENCH") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_TRENCH;
    if (s == "VALVECHAMBER") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_VALVECHAMBER;
    if (s == "USERDEFINED") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDistributionPortTypeEnum::ToString(IfcDistributionPortTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CABLE", "CABLECARRIER", "DUCT", "PIPE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum IfcDistributionPortTypeEnum::FromString(const std::string& s) {
    if (s == "CABLE") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_CABLE;
    if (s == "CABLECARRIER") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_CABLECARRIER;
    if (s == "DUCT") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_DUCT;
    if (s == "PIPE") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_PIPE;
    if (s == "USERDEFINED") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDistributionSystemEnum::ToString(IfcDistributionSystemEnum v) {
    if ( v < 0 || v >= 44 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRCONDITIONING", "AUDIOVISUAL", "CHEMICAL", "CHILLEDWATER", "COMMUNICATION", "COMPRESSEDAIR", "CONDENSERWATER", "CONTROL", "CONVEYING", "DATA", "DISPOSAL", "DOMESTICCOLDWATER", "DOMESTICHOTWATER", "DRAINAGE", "EARTHING", "ELECTRICAL", "ELECTROACOUSTIC", "EXHAUST", "FIREPROTECTION", "FUEL", "GAS", "HAZARDOUS", "HEATING", "LIGHTING", "LIGHTNINGPROTECTION", "MUNICIPALSOLIDWASTE", "OIL", "OPERATIONAL", "POWERGENERATION", "RAINWATER", "REFRIGERATION", "SECURITY", "SEWAGE", "SIGNAL", "STORMWATER", "TELEPHONE", "TV", "VACUUM", "VENT", "VENTILATION", "WASTEWATER", "WATERSUPPLY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDistributionSystemEnum::IfcDistributionSystemEnum IfcDistributionSystemEnum::FromString(const std::string& s) {
    if (s == "AIRCONDITIONING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_AIRCONDITIONING;
    if (s == "AUDIOVISUAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_AUDIOVISUAL;
    if (s == "CHEMICAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CHEMICAL;
    if (s == "CHILLEDWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CHILLEDWATER;
    if (s == "COMMUNICATION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_COMMUNICATION;
    if (s == "COMPRESSEDAIR") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_COMPRESSEDAIR;
    if (s == "CONDENSERWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CONDENSERWATER;
    if (s == "CONTROL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CONTROL;
    if (s == "CONVEYING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CONVEYING;
    if (s == "DATA") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DATA;
    if (s == "DISPOSAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DISPOSAL;
    if (s == "DOMESTICCOLDWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DOMESTICCOLDWATER;
    if (s == "DOMESTICHOTWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DOMESTICHOTWATER;
    if (s == "DRAINAGE") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DRAINAGE;
    if (s == "EARTHING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_EARTHING;
    if (s == "ELECTRICAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_ELECTRICAL;
    if (s == "ELECTROACOUSTIC") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_ELECTROACOUSTIC;
    if (s == "EXHAUST") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_EXHAUST;
    if (s == "FIREPROTECTION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_FIREPROTECTION;
    if (s == "FUEL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_FUEL;
    if (s == "GAS") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_GAS;
    if (s == "HAZARDOUS") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_HAZARDOUS;
    if (s == "HEATING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_HEATING;
    if (s == "LIGHTING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_LIGHTING;
    if (s == "LIGHTNINGPROTECTION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_LIGHTNINGPROTECTION;
    if (s == "MUNICIPALSOLIDWASTE") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_MUNICIPALSOLIDWASTE;
    if (s == "OIL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_OIL;
    if (s == "OPERATIONAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_OPERATIONAL;
    if (s == "POWERGENERATION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_POWERGENERATION;
    if (s == "RAINWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_RAINWATER;
    if (s == "REFRIGERATION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_REFRIGERATION;
    if (s == "SECURITY") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_SECURITY;
    if (s == "SEWAGE") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_SEWAGE;
    if (s == "SIGNAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_SIGNAL;
    if (s == "STORMWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_STORMWATER;
    if (s == "TELEPHONE") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_TELEPHONE;
    if (s == "TV") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_TV;
    if (s == "VACUUM") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_VACUUM;
    if (s == "VENT") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_VENT;
    if (s == "VENTILATION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_VENTILATION;
    if (s == "WASTEWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_WASTEWATER;
    if (s == "WATERSUPPLY") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_WATERSUPPLY;
    if (s == "USERDEFINED") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDocumentConfidentialityEnum::ToString(IfcDocumentConfidentialityEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PUBLIC", "RESTRICTED", "CONFIDENTIAL", "PERSONAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum IfcDocumentConfidentialityEnum::FromString(const std::string& s) {
    if (s == "PUBLIC") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_PUBLIC;
    if (s == "RESTRICTED") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_RESTRICTED;
    if (s == "CONFIDENTIAL") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_CONFIDENTIAL;
    if (s == "PERSONAL") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_PERSONAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDocumentStatusEnum::ToString(IfcDocumentStatusEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DRAFT", "FINALDRAFT", "FINAL", "REVISION", "NOTDEFINED" };
    return names[v];
}

IfcDocumentStatusEnum::IfcDocumentStatusEnum IfcDocumentStatusEnum::FromString(const std::string& s) {
    if (s == "DRAFT") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_DRAFT;
    if (s == "FINALDRAFT") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_FINALDRAFT;
    if (s == "FINAL") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_FINAL;
    if (s == "REVISION") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_REVISION;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorPanelOperationEnum::ToString(IfcDoorPanelOperationEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SWINGING", "DOUBLE_ACTING", "SLIDING", "FOLDING", "REVOLVING", "ROLLINGUP", "FIXEDPANEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum IfcDoorPanelOperationEnum::FromString(const std::string& s) {
    if (s == "SWINGING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_SWINGING;
    if (s == "DOUBLE_ACTING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_DOUBLE_ACTING;
    if (s == "SLIDING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_SLIDING;
    if (s == "FOLDING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_FOLDING;
    if (s == "REVOLVING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_ROLLINGUP;
    if (s == "FIXEDPANEL") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_FIXEDPANEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorPanelPositionEnum::ToString(IfcDoorPanelPositionEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LEFT", "MIDDLE", "RIGHT", "NOTDEFINED" };
    return names[v];
}

IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum IfcDoorPanelPositionEnum::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc4::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_LEFT;
    if (s == "MIDDLE") return ::Ifc4::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_MIDDLE;
    if (s == "RIGHT") return ::Ifc4::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_RIGHT;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorStyleConstructionEnum::ToString(IfcDoorStyleConstructionEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALUMINIUM", "HIGH_GRADE_STEEL", "STEEL", "WOOD", "ALUMINIUM_WOOD", "ALUMINIUM_PLASTIC", "PLASTIC", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum IfcDoorStyleConstructionEnum::FromString(const std::string& s) {
    if (s == "ALUMINIUM") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM;
    if (s == "HIGH_GRADE_STEEL") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_HIGH_GRADE_STEEL;
    if (s == "STEEL") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_STEEL;
    if (s == "WOOD") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_WOOD;
    if (s == "ALUMINIUM_WOOD") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM_WOOD;
    if (s == "ALUMINIUM_PLASTIC") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM_PLASTIC;
    if (s == "PLASTIC") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_PLASTIC;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorStyleOperationEnum::ToString(IfcDoorStyleOperationEnum v) {
    if ( v < 0 || v >= 18 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_SWING_LEFT", "SINGLE_SWING_RIGHT", "DOUBLE_DOOR_SINGLE_SWING", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT", "DOUBLE_SWING_LEFT", "DOUBLE_SWING_RIGHT", "DOUBLE_DOOR_DOUBLE_SWING", "SLIDING_TO_LEFT", "SLIDING_TO_RIGHT", "DOUBLE_DOOR_SLIDING", "FOLDING_TO_LEFT", "FOLDING_TO_RIGHT", "DOUBLE_DOOR_FOLDING", "REVOLVING", "ROLLINGUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum IfcDoorStyleOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_SWING_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SINGLE_SWING_LEFT;
    if (s == "SINGLE_SWING_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SINGLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT;
    if (s == "DOUBLE_SWING_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_SWING_LEFT;
    if (s == "DOUBLE_SWING_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_DOUBLE_SWING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_DOUBLE_SWING;
    if (s == "SLIDING_TO_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SLIDING_TO_LEFT;
    if (s == "SLIDING_TO_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SLIDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_SLIDING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SLIDING;
    if (s == "FOLDING_TO_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_FOLDING_TO_LEFT;
    if (s == "FOLDING_TO_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_FOLDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_FOLDING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_FOLDING;
    if (s == "REVOLVING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_ROLLINGUP;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorTypeEnum::ToString(IfcDoorTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DOOR", "GATE", "TRAPDOOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorTypeEnum::IfcDoorTypeEnum IfcDoorTypeEnum::FromString(const std::string& s) {
    if (s == "DOOR") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_DOOR;
    if (s == "GATE") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_GATE;
    if (s == "TRAPDOOR") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_TRAPDOOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorTypeOperationEnum::ToString(IfcDoorTypeOperationEnum v) {
    if ( v < 0 || v >= 20 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_SWING_LEFT", "SINGLE_SWING_RIGHT", "DOUBLE_DOOR_SINGLE_SWING", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT", "DOUBLE_SWING_LEFT", "DOUBLE_SWING_RIGHT", "DOUBLE_DOOR_DOUBLE_SWING", "SLIDING_TO_LEFT", "SLIDING_TO_RIGHT", "DOUBLE_DOOR_SLIDING", "FOLDING_TO_LEFT", "FOLDING_TO_RIGHT", "DOUBLE_DOOR_FOLDING", "REVOLVING", "ROLLINGUP", "SWING_FIXED_LEFT", "SWING_FIXED_RIGHT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum IfcDoorTypeOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_SWING_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SINGLE_SWING_LEFT;
    if (s == "SINGLE_SWING_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SINGLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_SINGLE_SWING;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT;
    if (s == "DOUBLE_SWING_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_SWING_LEFT;
    if (s == "DOUBLE_SWING_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_DOUBLE_SWING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_DOUBLE_SWING;
    if (s == "SLIDING_TO_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SLIDING_TO_LEFT;
    if (s == "SLIDING_TO_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SLIDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_SLIDING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_SLIDING;
    if (s == "FOLDING_TO_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_FOLDING_TO_LEFT;
    if (s == "FOLDING_TO_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_FOLDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_FOLDING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_FOLDING;
    if (s == "REVOLVING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_ROLLINGUP;
    if (s == "SWING_FIXED_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SWING_FIXED_LEFT;
    if (s == "SWING_FIXED_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SWING_FIXED_RIGHT;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDuctFittingTypeEnum::ToString(IfcDuctFittingTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEND", "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "OBSTRUCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum IfcDuctFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_BEND;
    if (s == "CONNECTOR") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_JUNCTION;
    if (s == "OBSTRUCTION") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_OBSTRUCTION;
    if (s == "TRANSITION") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDuctSegmentTypeEnum::ToString(IfcDuctSegmentTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "RIGIDSEGMENT", "FLEXIBLESEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum IfcDuctSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "RIGIDSEGMENT") return ::Ifc4::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_RIGIDSEGMENT;
    if (s == "FLEXIBLESEGMENT") return ::Ifc4::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_FLEXIBLESEGMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDuctSilencerTypeEnum::ToString(IfcDuctSilencerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLATOVAL", "RECTANGULAR", "ROUND", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum IfcDuctSilencerTypeEnum::FromString(const std::string& s) {
    if (s == "FLATOVAL") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_FLATOVAL;
    if (s == "RECTANGULAR") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_RECTANGULAR;
    if (s == "ROUND") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_ROUND;
    if (s == "USERDEFINED") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricApplianceTypeEnum::ToString(IfcElectricApplianceTypeEnum v) {
    if ( v < 0 || v >= 18 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DISHWASHER", "ELECTRICCOOKER", "FREESTANDINGELECTRICHEATER", "FREESTANDINGFAN", "FREESTANDINGWATERHEATER", "FREESTANDINGWATERCOOLER", "FREEZER", "FRIDGE_FREEZER", "HANDDRYER", "KITCHENMACHINE", "MICROWAVE", "PHOTOCOPIER", "REFRIGERATOR", "TUMBLEDRYER", "VENDINGMACHINE", "WASHINGMACHINE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum IfcElectricApplianceTypeEnum::FromString(const std::string& s) {
    if (s == "DISHWASHER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_DISHWASHER;
    if (s == "ELECTRICCOOKER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_ELECTRICCOOKER;
    if (s == "FREESTANDINGELECTRICHEATER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGELECTRICHEATER;
    if (s == "FREESTANDINGFAN") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGFAN;
    if (s == "FREESTANDINGWATERHEATER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGWATERHEATER;
    if (s == "FREESTANDINGWATERCOOLER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGWATERCOOLER;
    if (s == "FREEZER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREEZER;
    if (s == "FRIDGE_FREEZER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FRIDGE_FREEZER;
    if (s == "HANDDRYER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_HANDDRYER;
    if (s == "KITCHENMACHINE") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_KITCHENMACHINE;
    if (s == "MICROWAVE") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_MICROWAVE;
    if (s == "PHOTOCOPIER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_PHOTOCOPIER;
    if (s == "REFRIGERATOR") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_REFRIGERATOR;
    if (s == "TUMBLEDRYER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_TUMBLEDRYER;
    if (s == "VENDINGMACHINE") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_VENDINGMACHINE;
    if (s == "WASHINGMACHINE") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_WASHINGMACHINE;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricDistributionBoardTypeEnum::ToString(IfcElectricDistributionBoardTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONSUMERUNIT", "DISTRIBUTIONBOARD", "MOTORCONTROLCENTRE", "SWITCHBOARD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum IfcElectricDistributionBoardTypeEnum::FromString(const std::string& s) {
    if (s == "CONSUMERUNIT") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_CONSUMERUNIT;
    if (s == "DISTRIBUTIONBOARD") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_DISTRIBUTIONBOARD;
    if (s == "MOTORCONTROLCENTRE") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_MOTORCONTROLCENTRE;
    if (s == "SWITCHBOARD") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_SWITCHBOARD;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricFlowStorageDeviceTypeEnum::ToString(IfcElectricFlowStorageDeviceTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BATTERY", "CAPACITORBANK", "HARMONICFILTER", "INDUCTORBANK", "UPS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum IfcElectricFlowStorageDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "BATTERY") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_BATTERY;
    if (s == "CAPACITORBANK") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_CAPACITORBANK;
    if (s == "HARMONICFILTER") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_HARMONICFILTER;
    if (s == "INDUCTORBANK") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_INDUCTORBANK;
    if (s == "UPS") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_UPS;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricGeneratorTypeEnum::ToString(IfcElectricGeneratorTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CHP", "ENGINEGENERATOR", "STANDALONE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum IfcElectricGeneratorTypeEnum::FromString(const std::string& s) {
    if (s == "CHP") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_CHP;
    if (s == "ENGINEGENERATOR") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_ENGINEGENERATOR;
    if (s == "STANDALONE") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_STANDALONE;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricMotorTypeEnum::ToString(IfcElectricMotorTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DC", "INDUCTION", "POLYPHASE", "RELUCTANCESYNCHRONOUS", "SYNCHRONOUS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum IfcElectricMotorTypeEnum::FromString(const std::string& s) {
    if (s == "DC") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_DC;
    if (s == "INDUCTION") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_INDUCTION;
    if (s == "POLYPHASE") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_POLYPHASE;
    if (s == "RELUCTANCESYNCHRONOUS") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_RELUCTANCESYNCHRONOUS;
    if (s == "SYNCHRONOUS") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_SYNCHRONOUS;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricTimeControlTypeEnum::ToString(IfcElectricTimeControlTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "TIMECLOCK", "TIMEDELAY", "RELAY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum IfcElectricTimeControlTypeEnum::FromString(const std::string& s) {
    if (s == "TIMECLOCK") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_TIMECLOCK;
    if (s == "TIMEDELAY") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_TIMEDELAY;
    if (s == "RELAY") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_RELAY;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElementAssemblyTypeEnum::ToString(IfcElementAssemblyTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACCESSORY_ASSEMBLY", "ARCH", "BEAM_GRID", "BRACED_FRAME", "GIRDER", "REINFORCEMENT_UNIT", "RIGID_FRAME", "SLAB_FIELD", "TRUSS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum IfcElementAssemblyTypeEnum::FromString(const std::string& s) {
    if (s == "ACCESSORY_ASSEMBLY") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_ACCESSORY_ASSEMBLY;
    if (s == "ARCH") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_ARCH;
    if (s == "BEAM_GRID") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_BEAM_GRID;
    if (s == "BRACED_FRAME") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_BRACED_FRAME;
    if (s == "GIRDER") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_GIRDER;
    if (s == "REINFORCEMENT_UNIT") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_REINFORCEMENT_UNIT;
    if (s == "RIGID_FRAME") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_RIGID_FRAME;
    if (s == "SLAB_FIELD") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_SLAB_FIELD;
    if (s == "TRUSS") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_TRUSS;
    if (s == "USERDEFINED") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElementCompositionEnum::ToString(IfcElementCompositionEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPLEX", "ELEMENT", "PARTIAL" };
    return names[v];
}

IfcElementCompositionEnum::IfcElementCompositionEnum IfcElementCompositionEnum::FromString(const std::string& s) {
    if (s == "COMPLEX") return ::Ifc4::IfcElementCompositionEnum::IfcElementComposition_COMPLEX;
    if (s == "ELEMENT") return ::Ifc4::IfcElementCompositionEnum::IfcElementComposition_ELEMENT;
    if (s == "PARTIAL") return ::Ifc4::IfcElementCompositionEnum::IfcElementComposition_PARTIAL;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEngineTypeEnum::ToString(IfcEngineTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EXTERNALCOMBUSTION", "INTERNALCOMBUSTION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEngineTypeEnum::IfcEngineTypeEnum IfcEngineTypeEnum::FromString(const std::string& s) {
    if (s == "EXTERNALCOMBUSTION") return ::Ifc4::IfcEngineTypeEnum::IfcEngineType_EXTERNALCOMBUSTION;
    if (s == "INTERNALCOMBUSTION") return ::Ifc4::IfcEngineTypeEnum::IfcEngineType_INTERNALCOMBUSTION;
    if (s == "USERDEFINED") return ::Ifc4::IfcEngineTypeEnum::IfcEngineType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEngineTypeEnum::IfcEngineType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEvaporativeCoolerTypeEnum::ToString(IfcEvaporativeCoolerTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER", "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER", "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER", "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER", "DIRECTEVAPORATIVEAIRWASHER", "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER", "INDIRECTEVAPORATIVEWETCOIL", "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER", "INDIRECTDIRECTCOMBINATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum IfcEvaporativeCoolerTypeEnum::FromString(const std::string& s) {
    if (s == "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER;
    if (s == "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER;
    if (s == "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER;
    if (s == "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER;
    if (s == "DIRECTEVAPORATIVEAIRWASHER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVEAIRWASHER;
    if (s == "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEPACKAGEAIRCOOLER;
    if (s == "INDIRECTEVAPORATIVEWETCOIL") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEWETCOIL;
    if (s == "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER;
    if (s == "INDIRECTDIRECTCOMBINATION") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTDIRECTCOMBINATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEvaporatorTypeEnum::ToString(IfcEvaporatorTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DIRECTEXPANSION", "DIRECTEXPANSIONSHELLANDTUBE", "DIRECTEXPANSIONTUBEINTUBE", "DIRECTEXPANSIONBRAZEDPLATE", "FLOODEDSHELLANDTUBE", "SHELLANDCOIL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum IfcEvaporatorTypeEnum::FromString(const std::string& s) {
    if (s == "DIRECTEXPANSION") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSION;
    if (s == "DIRECTEXPANSIONSHELLANDTUBE") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONSHELLANDTUBE;
    if (s == "DIRECTEXPANSIONTUBEINTUBE") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONTUBEINTUBE;
    if (s == "DIRECTEXPANSIONBRAZEDPLATE") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONBRAZEDPLATE;
    if (s == "FLOODEDSHELLANDTUBE") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_FLOODEDSHELLANDTUBE;
    if (s == "SHELLANDCOIL") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_SHELLANDCOIL;
    if (s == "USERDEFINED") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEventTriggerTypeEnum::ToString(IfcEventTriggerTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EVENTRULE", "EVENTMESSAGE", "EVENTTIME", "EVENTCOMPLEX", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum IfcEventTriggerTypeEnum::FromString(const std::string& s) {
    if (s == "EVENTRULE") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_EVENTRULE;
    if (s == "EVENTMESSAGE") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_EVENTMESSAGE;
    if (s == "EVENTTIME") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_EVENTTIME;
    if (s == "EVENTCOMPLEX") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_EVENTCOMPLEX;
    if (s == "USERDEFINED") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEventTypeEnum::ToString(IfcEventTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STARTEVENT", "ENDEVENT", "INTERMEDIATEEVENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEventTypeEnum::IfcEventTypeEnum IfcEventTypeEnum::FromString(const std::string& s) {
    if (s == "STARTEVENT") return ::Ifc4::IfcEventTypeEnum::IfcEventType_STARTEVENT;
    if (s == "ENDEVENT") return ::Ifc4::IfcEventTypeEnum::IfcEventType_ENDEVENT;
    if (s == "INTERMEDIATEEVENT") return ::Ifc4::IfcEventTypeEnum::IfcEventType_INTERMEDIATEEVENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcEventTypeEnum::IfcEventType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEventTypeEnum::IfcEventType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcExternalSpatialElementTypeEnum::ToString(IfcExternalSpatialElementTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EXTERNAL", "EXTERNAL_EARTH", "EXTERNAL_WATER", "EXTERNAL_FIRE", "USERDEFINED", "NOTDEFIEND" };
    return names[v];
}

IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum IfcExternalSpatialElementTypeEnum::FromString(const std::string& s) {
    if (s == "EXTERNAL") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_EXTERNAL;
    if (s == "EXTERNAL_EARTH") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_EXTERNAL_EARTH;
    if (s == "EXTERNAL_WATER") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_EXTERNAL_WATER;
    if (s == "EXTERNAL_FIRE") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_EXTERNAL_FIRE;
    if (s == "USERDEFINED") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_USERDEFINED;
    if (s == "NOTDEFIEND") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_NOTDEFIEND;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFanTypeEnum::ToString(IfcFanTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CENTRIFUGALFORWARDCURVED", "CENTRIFUGALRADIAL", "CENTRIFUGALBACKWARDINCLINEDCURVED", "CENTRIFUGALAIRFOIL", "TUBEAXIAL", "VANEAXIAL", "PROPELLORAXIAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFanTypeEnum::IfcFanTypeEnum IfcFanTypeEnum::FromString(const std::string& s) {
    if (s == "CENTRIFUGALFORWARDCURVED") return ::Ifc4::IfcFanTypeEnum::IfcFanType_CENTRIFUGALFORWARDCURVED;
    if (s == "CENTRIFUGALRADIAL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_CENTRIFUGALRADIAL;
    if (s == "CENTRIFUGALBACKWARDINCLINEDCURVED") return ::Ifc4::IfcFanTypeEnum::IfcFanType_CENTRIFUGALBACKWARDINCLINEDCURVED;
    if (s == "CENTRIFUGALAIRFOIL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_CENTRIFUGALAIRFOIL;
    if (s == "TUBEAXIAL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_TUBEAXIAL;
    if (s == "VANEAXIAL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_VANEAXIAL;
    if (s == "PROPELLORAXIAL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_PROPELLORAXIAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcFanTypeEnum::IfcFanType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFanTypeEnum::IfcFanType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFastenerTypeEnum::ToString(IfcFastenerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GLUE", "MORTAR", "WELD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFastenerTypeEnum::IfcFastenerTypeEnum IfcFastenerTypeEnum::FromString(const std::string& s) {
    if (s == "GLUE") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_GLUE;
    if (s == "MORTAR") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_MORTAR;
    if (s == "WELD") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_WELD;
    if (s == "USERDEFINED") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFilterTypeEnum::ToString(IfcFilterTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRPARTICLEFILTER", "COMPRESSEDAIRFILTER", "ODORFILTER", "OILFILTER", "STRAINER", "WATERFILTER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFilterTypeEnum::IfcFilterTypeEnum IfcFilterTypeEnum::FromString(const std::string& s) {
    if (s == "AIRPARTICLEFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_AIRPARTICLEFILTER;
    if (s == "COMPRESSEDAIRFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_COMPRESSEDAIRFILTER;
    if (s == "ODORFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_ODORFILTER;
    if (s == "OILFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_OILFILTER;
    if (s == "STRAINER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_STRAINER;
    if (s == "WATERFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_WATERFILTER;
    if (s == "USERDEFINED") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFireSuppressionTerminalTypeEnum::ToString(IfcFireSuppressionTerminalTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BREECHINGINLET", "FIREHYDRANT", "HOSEREEL", "SPRINKLER", "SPRINKLERDEFLECTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum IfcFireSuppressionTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BREECHINGINLET") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_BREECHINGINLET;
    if (s == "FIREHYDRANT") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_FIREHYDRANT;
    if (s == "HOSEREEL") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_HOSEREEL;
    if (s == "SPRINKLER") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_SPRINKLER;
    if (s == "SPRINKLERDEFLECTOR") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_SPRINKLERDEFLECTOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFlowDirectionEnum::ToString(IfcFlowDirectionEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SOURCE", "SINK", "SOURCEANDSINK", "NOTDEFINED" };
    return names[v];
}

IfcFlowDirectionEnum::IfcFlowDirectionEnum IfcFlowDirectionEnum::FromString(const std::string& s) {
    if (s == "SOURCE") return ::Ifc4::IfcFlowDirectionEnum::IfcFlowDirection_SOURCE;
    if (s == "SINK") return ::Ifc4::IfcFlowDirectionEnum::IfcFlowDirection_SINK;
    if (s == "SOURCEANDSINK") return ::Ifc4::IfcFlowDirectionEnum::IfcFlowDirection_SOURCEANDSINK;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFlowDirectionEnum::IfcFlowDirection_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFlowInstrumentTypeEnum::ToString(IfcFlowInstrumentTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PRESSUREGAUGE", "THERMOMETER", "AMMETER", "FREQUENCYMETER", "POWERFACTORMETER", "PHASEANGLEMETER", "VOLTMETER_PEAK", "VOLTMETER_RMS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum IfcFlowInstrumentTypeEnum::FromString(const std::string& s) {
    if (s == "PRESSUREGAUGE") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_PRESSUREGAUGE;
    if (s == "THERMOMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_THERMOMETER;
    if (s == "AMMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_AMMETER;
    if (s == "FREQUENCYMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_FREQUENCYMETER;
    if (s == "POWERFACTORMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_POWERFACTORMETER;
    if (s == "PHASEANGLEMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_PHASEANGLEMETER;
    if (s == "VOLTMETER_PEAK") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_VOLTMETER_PEAK;
    if (s == "VOLTMETER_RMS") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_VOLTMETER_RMS;
    if (s == "USERDEFINED") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFlowMeterTypeEnum::ToString(IfcFlowMeterTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ENERGYMETER", "GASMETER", "OILMETER", "WATERMETER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum IfcFlowMeterTypeEnum::FromString(const std::string& s) {
    if (s == "ENERGYMETER") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_ENERGYMETER;
    if (s == "GASMETER") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_GASMETER;
    if (s == "OILMETER") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_OILMETER;
    if (s == "WATERMETER") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_WATERMETER;
    if (s == "USERDEFINED") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFootingTypeEnum::ToString(IfcFootingTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CAISSON_FOUNDATION", "FOOTING_BEAM", "PAD_FOOTING", "PILE_CAP", "STRIP_FOOTING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFootingTypeEnum::IfcFootingTypeEnum IfcFootingTypeEnum::FromString(const std::string& s) {
    if (s == "CAISSON_FOUNDATION") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_CAISSON_FOUNDATION;
    if (s == "FOOTING_BEAM") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_FOOTING_BEAM;
    if (s == "PAD_FOOTING") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_PAD_FOOTING;
    if (s == "PILE_CAP") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_PILE_CAP;
    if (s == "STRIP_FOOTING") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_STRIP_FOOTING;
    if (s == "USERDEFINED") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFurnitureTypeEnum::ToString(IfcFurnitureTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CHAIR", "TABLE", "DESK", "BED", "FILECABINET", "SHELF", "SOFA", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFurnitureTypeEnum::IfcFurnitureTypeEnum IfcFurnitureTypeEnum::FromString(const std::string& s) {
    if (s == "CHAIR") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_CHAIR;
    if (s == "TABLE") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_TABLE;
    if (s == "DESK") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_DESK;
    if (s == "BED") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_BED;
    if (s == "FILECABINET") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_FILECABINET;
    if (s == "SHELF") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_SHELF;
    if (s == "SOFA") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_SOFA;
    if (s == "USERDEFINED") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGeographicElementTypeEnum::ToString(IfcGeographicElementTypeEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "TERRAIN", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum IfcGeographicElementTypeEnum::FromString(const std::string& s) {
    if (s == "TERRAIN") return ::Ifc4::IfcGeographicElementTypeEnum::IfcGeographicElementType_TERRAIN;
    if (s == "USERDEFINED") return ::Ifc4::IfcGeographicElementTypeEnum::IfcGeographicElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcGeographicElementTypeEnum::IfcGeographicElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGeometricProjectionEnum::ToString(IfcGeometricProjectionEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GRAPH_VIEW", "SKETCH_VIEW", "MODEL_VIEW", "PLAN_VIEW", "REFLECTED_PLAN_VIEW", "SECTION_VIEW", "ELEVATION_VIEW", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcGeometricProjectionEnum::IfcGeometricProjectionEnum IfcGeometricProjectionEnum::FromString(const std::string& s) {
    if (s == "GRAPH_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_GRAPH_VIEW;
    if (s == "SKETCH_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_SKETCH_VIEW;
    if (s == "MODEL_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_MODEL_VIEW;
    if (s == "PLAN_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_PLAN_VIEW;
    if (s == "REFLECTED_PLAN_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_REFLECTED_PLAN_VIEW;
    if (s == "SECTION_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_SECTION_VIEW;
    if (s == "ELEVATION_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_ELEVATION_VIEW;
    if (s == "USERDEFINED") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGlobalOrLocalEnum::ToString(IfcGlobalOrLocalEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GLOBAL_COORDS", "LOCAL_COORDS" };
    return names[v];
}

IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum IfcGlobalOrLocalEnum::FromString(const std::string& s) {
    if (s == "GLOBAL_COORDS") return ::Ifc4::IfcGlobalOrLocalEnum::IfcGlobalOrLocal_GLOBAL_COORDS;
    if (s == "LOCAL_COORDS") return ::Ifc4::IfcGlobalOrLocalEnum::IfcGlobalOrLocal_LOCAL_COORDS;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGridTypeEnum::ToString(IfcGridTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "RECTANGULAR", "RADIAL", "TRIANGULAR", "IRREGULAR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcGridTypeEnum::IfcGridTypeEnum IfcGridTypeEnum::FromString(const std::string& s) {
    if (s == "RECTANGULAR") return ::Ifc4::IfcGridTypeEnum::IfcGridType_RECTANGULAR;
    if (s == "RADIAL") return ::Ifc4::IfcGridTypeEnum::IfcGridType_RADIAL;
    if (s == "TRIANGULAR") return ::Ifc4::IfcGridTypeEnum::IfcGridType_TRIANGULAR;
    if (s == "IRREGULAR") return ::Ifc4::IfcGridTypeEnum::IfcGridType_IRREGULAR;
    if (s == "USERDEFINED") return ::Ifc4::IfcGridTypeEnum::IfcGridType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcGridTypeEnum::IfcGridType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcHeatExchangerTypeEnum::ToString(IfcHeatExchangerTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PLATE", "SHELLANDTUBE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum IfcHeatExchangerTypeEnum::FromString(const std::string& s) {
    if (s == "PLATE") return ::Ifc4::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_PLATE;
    if (s == "SHELLANDTUBE") return ::Ifc4::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_SHELLANDTUBE;
    if (s == "USERDEFINED") return ::Ifc4::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcHumidifierTypeEnum::ToString(IfcHumidifierTypeEnum v) {
    if ( v < 0 || v >= 15 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STEAMINJECTION", "ADIABATICAIRWASHER", "ADIABATICPAN", "ADIABATICWETTEDELEMENT", "ADIABATICATOMIZING", "ADIABATICULTRASONIC", "ADIABATICRIGIDMEDIA", "ADIABATICCOMPRESSEDAIRNOZZLE", "ASSISTEDELECTRIC", "ASSISTEDNATURALGAS", "ASSISTEDPROPANE", "ASSISTEDBUTANE", "ASSISTEDSTEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcHumidifierTypeEnum::IfcHumidifierTypeEnum IfcHumidifierTypeEnum::FromString(const std::string& s) {
    if (s == "STEAMINJECTION") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_STEAMINJECTION;
    if (s == "ADIABATICAIRWASHER") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICAIRWASHER;
    if (s == "ADIABATICPAN") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICPAN;
    if (s == "ADIABATICWETTEDELEMENT") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICWETTEDELEMENT;
    if (s == "ADIABATICATOMIZING") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICATOMIZING;
    if (s == "ADIABATICULTRASONIC") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICULTRASONIC;
    if (s == "ADIABATICRIGIDMEDIA") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICRIGIDMEDIA;
    if (s == "ADIABATICCOMPRESSEDAIRNOZZLE") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICCOMPRESSEDAIRNOZZLE;
    if (s == "ASSISTEDELECTRIC") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDELECTRIC;
    if (s == "ASSISTEDNATURALGAS") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDNATURALGAS;
    if (s == "ASSISTEDPROPANE") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDPROPANE;
    if (s == "ASSISTEDBUTANE") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDBUTANE;
    if (s == "ASSISTEDSTEAM") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDSTEAM;
    if (s == "USERDEFINED") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcInterceptorTypeEnum::ToString(IfcInterceptorTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CYCLONIC", "GREASE", "OIL", "PETROL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcInterceptorTypeEnum::IfcInterceptorTypeEnum IfcInterceptorTypeEnum::FromString(const std::string& s) {
    if (s == "CYCLONIC") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_CYCLONIC;
    if (s == "GREASE") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_GREASE;
    if (s == "OIL") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_OIL;
    if (s == "PETROL") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_PETROL;
    if (s == "USERDEFINED") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcInternalOrExternalEnum::ToString(IfcInternalOrExternalEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "INTERNAL", "EXTERNAL", "EXTERNAL_EARTH", "EXTERNAL_WATER", "EXTERNAL_FIRE", "NOTDEFINED" };
    return names[v];
}

IfcInternalOrExternalEnum::IfcInternalOrExternalEnum IfcInternalOrExternalEnum::FromString(const std::string& s) {
    if (s == "INTERNAL") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_INTERNAL;
    if (s == "EXTERNAL") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL;
    if (s == "EXTERNAL_EARTH") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL_EARTH;
    if (s == "EXTERNAL_WATER") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL_WATER;
    if (s == "EXTERNAL_FIRE") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL_FIRE;
    if (s == "NOTDEFINED") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcInventoryTypeEnum::ToString(IfcInventoryTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ASSETINVENTORY", "SPACEINVENTORY", "FURNITUREINVENTORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcInventoryTypeEnum::IfcInventoryTypeEnum IfcInventoryTypeEnum::FromString(const std::string& s) {
    if (s == "ASSETINVENTORY") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_ASSETINVENTORY;
    if (s == "SPACEINVENTORY") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_SPACEINVENTORY;
    if (s == "FURNITUREINVENTORY") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_FURNITUREINVENTORY;
    if (s == "USERDEFINED") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcJunctionBoxTypeEnum::ToString(IfcJunctionBoxTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DATA", "POWER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum IfcJunctionBoxTypeEnum::FromString(const std::string& s) {
    if (s == "DATA") return ::Ifc4::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_DATA;
    if (s == "POWER") return ::Ifc4::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_POWER;
    if (s == "USERDEFINED") return ::Ifc4::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcKnotType::ToString(IfcKnotType v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "UNIFORM_KNOTS", "QUASI_UNIFORM_KNOTS", "PIECEWISE_BEZIER_KNOTS", "UNSPECIFIED" };
    return names[v];
}

IfcKnotType::IfcKnotType IfcKnotType::FromString(const std::string& s) {
    if (s == "UNIFORM_KNOTS") return ::Ifc4::IfcKnotType::IfcKnotType_UNIFORM_KNOTS;
    if (s == "QUASI_UNIFORM_KNOTS") return ::Ifc4::IfcKnotType::IfcKnotType_QUASI_UNIFORM_KNOTS;
    if (s == "PIECEWISE_BEZIER_KNOTS") return ::Ifc4::IfcKnotType::IfcKnotType_PIECEWISE_BEZIER_KNOTS;
    if (s == "UNSPECIFIED") return ::Ifc4::IfcKnotType::IfcKnotType_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLaborResourceTypeEnum::ToString(IfcLaborResourceTypeEnum v) {
    if ( v < 0 || v >= 21 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ADMINISTRATION", "CARPENTRY", "CLEANING", "CONCRETE", "DRYWALL", "ELECTRIC", "FINISHING", "FLOORING", "GENERAL", "HVAC", "LANDSCAPING", "MASONRY", "PAINTING", "PAVING", "PLUMBING", "ROOFING", "SITEGRADING", "STEELWORK", "SURVEYING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum IfcLaborResourceTypeEnum::FromString(const std::string& s) {
    if (s == "ADMINISTRATION") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_ADMINISTRATION;
    if (s == "CARPENTRY") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_CARPENTRY;
    if (s == "CLEANING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_CLEANING;
    if (s == "CONCRETE") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_CONCRETE;
    if (s == "DRYWALL") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_DRYWALL;
    if (s == "ELECTRIC") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_ELECTRIC;
    if (s == "FINISHING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_FINISHING;
    if (s == "FLOORING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_FLOORING;
    if (s == "GENERAL") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_GENERAL;
    if (s == "HVAC") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_HVAC;
    if (s == "LANDSCAPING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_LANDSCAPING;
    if (s == "MASONRY") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_MASONRY;
    if (s == "PAINTING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_PAINTING;
    if (s == "PAVING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_PAVING;
    if (s == "PLUMBING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_PLUMBING;
    if (s == "ROOFING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_ROOFING;
    if (s == "SITEGRADING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_SITEGRADING;
    if (s == "STEELWORK") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_STEELWORK;
    if (s == "SURVEYING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_SURVEYING;
    if (s == "USERDEFINED") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLampTypeEnum::ToString(IfcLampTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPACTFLUORESCENT", "FLUORESCENT", "HALOGEN", "HIGHPRESSUREMERCURY", "HIGHPRESSURESODIUM", "LED", "METALHALIDE", "OLED", "TUNGSTENFILAMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLampTypeEnum::IfcLampTypeEnum IfcLampTypeEnum::FromString(const std::string& s) {
    if (s == "COMPACTFLUORESCENT") return ::Ifc4::IfcLampTypeEnum::IfcLampType_COMPACTFLUORESCENT;
    if (s == "FLUORESCENT") return ::Ifc4::IfcLampTypeEnum::IfcLampType_FLUORESCENT;
    if (s == "HALOGEN") return ::Ifc4::IfcLampTypeEnum::IfcLampType_HALOGEN;
    if (s == "HIGHPRESSUREMERCURY") return ::Ifc4::IfcLampTypeEnum::IfcLampType_HIGHPRESSUREMERCURY;
    if (s == "HIGHPRESSURESODIUM") return ::Ifc4::IfcLampTypeEnum::IfcLampType_HIGHPRESSURESODIUM;
    if (s == "LED") return ::Ifc4::IfcLampTypeEnum::IfcLampType_LED;
    if (s == "METALHALIDE") return ::Ifc4::IfcLampTypeEnum::IfcLampType_METALHALIDE;
    if (s == "OLED") return ::Ifc4::IfcLampTypeEnum::IfcLampType_OLED;
    if (s == "TUNGSTENFILAMENT") return ::Ifc4::IfcLampTypeEnum::IfcLampType_TUNGSTENFILAMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcLampTypeEnum::IfcLampType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLampTypeEnum::IfcLampType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLayerSetDirectionEnum::ToString(IfcLayerSetDirectionEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AXIS1", "AXIS2", "AXIS3" };
    return names[v];
}

IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum IfcLayerSetDirectionEnum::FromString(const std::string& s) {
    if (s == "AXIS1") return ::Ifc4::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS1;
    if (s == "AXIS2") return ::Ifc4::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS2;
    if (s == "AXIS3") return ::Ifc4::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS3;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLightDistributionCurveEnum::ToString(IfcLightDistributionCurveEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "TYPE_A", "TYPE_B", "TYPE_C", "NOTDEFINED" };
    return names[v];
}

IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum IfcLightDistributionCurveEnum::FromString(const std::string& s) {
    if (s == "TYPE_A") return ::Ifc4::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_A;
    if (s == "TYPE_B") return ::Ifc4::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_B;
    if (s == "TYPE_C") return ::Ifc4::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_C;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLightEmissionSourceEnum::ToString(IfcLightEmissionSourceEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPACTFLUORESCENT", "FLUORESCENT", "HIGHPRESSUREMERCURY", "HIGHPRESSURESODIUM", "LIGHTEMITTINGDIODE", "LOWPRESSURESODIUM", "LOWVOLTAGEHALOGEN", "MAINVOLTAGEHALOGEN", "METALHALIDE", "TUNGSTENFILAMENT", "NOTDEFINED" };
    return names[v];
}

IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum IfcLightEmissionSourceEnum::FromString(const std::string& s) {
    if (s == "COMPACTFLUORESCENT") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_COMPACTFLUORESCENT;
    if (s == "FLUORESCENT") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_FLUORESCENT;
    if (s == "HIGHPRESSUREMERCURY") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_HIGHPRESSUREMERCURY;
    if (s == "HIGHPRESSURESODIUM") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_HIGHPRESSURESODIUM;
    if (s == "LIGHTEMITTINGDIODE") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LIGHTEMITTINGDIODE;
    if (s == "LOWPRESSURESODIUM") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LOWPRESSURESODIUM;
    if (s == "LOWVOLTAGEHALOGEN") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LOWVOLTAGEHALOGEN;
    if (s == "MAINVOLTAGEHALOGEN") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_MAINVOLTAGEHALOGEN;
    if (s == "METALHALIDE") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_METALHALIDE;
    if (s == "TUNGSTENFILAMENT") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_TUNGSTENFILAMENT;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLightFixtureTypeEnum::ToString(IfcLightFixtureTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POINTSOURCE", "DIRECTIONSOURCE", "SECURITYLIGHTING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum IfcLightFixtureTypeEnum::FromString(const std::string& s) {
    if (s == "POINTSOURCE") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_POINTSOURCE;
    if (s == "DIRECTIONSOURCE") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_DIRECTIONSOURCE;
    if (s == "SECURITYLIGHTING") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_SECURITYLIGHTING;
    if (s == "USERDEFINED") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLoadGroupTypeEnum::ToString(IfcLoadGroupTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LOAD_GROUP", "LOAD_CASE", "LOAD_COMBINATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum IfcLoadGroupTypeEnum::FromString(const std::string& s) {
    if (s == "LOAD_GROUP") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_GROUP;
    if (s == "LOAD_CASE") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_CASE;
    if (s == "LOAD_COMBINATION") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_COMBINATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLogicalOperatorEnum::ToString(IfcLogicalOperatorEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LOGICALAND", "LOGICALOR", "LOGICALXOR", "LOGICALNOTAND", "LOGICALNOTOR" };
    return names[v];
}

IfcLogicalOperatorEnum::IfcLogicalOperatorEnum IfcLogicalOperatorEnum::FromString(const std::string& s) {
    if (s == "LOGICALAND") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALAND;
    if (s == "LOGICALOR") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALOR;
    if (s == "LOGICALXOR") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALXOR;
    if (s == "LOGICALNOTAND") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALNOTAND;
    if (s == "LOGICALNOTOR") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALNOTOR;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMechanicalFastenerTypeEnum::ToString(IfcMechanicalFastenerTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANCHORBOLT", "BOLT", "DOWEL", "NAIL", "NAILPLATE", "RIVET", "SCREW", "SHEARCONNECTOR", "STAPLE", "STUDSHEARCONNECTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum IfcMechanicalFastenerTypeEnum::FromString(const std::string& s) {
    if (s == "ANCHORBOLT") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_ANCHORBOLT;
    if (s == "BOLT") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_BOLT;
    if (s == "DOWEL") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_DOWEL;
    if (s == "NAIL") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_NAIL;
    if (s == "NAILPLATE") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_NAILPLATE;
    if (s == "RIVET") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_RIVET;
    if (s == "SCREW") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_SCREW;
    if (s == "SHEARCONNECTOR") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_SHEARCONNECTOR;
    if (s == "STAPLE") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_STAPLE;
    if (s == "STUDSHEARCONNECTOR") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_STUDSHEARCONNECTOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMedicalDeviceTypeEnum::ToString(IfcMedicalDeviceTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRSTATION", "FEEDAIRUNIT", "OXYGENGENERATOR", "OXYGENPLANT", "VACUUMSTATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum IfcMedicalDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "AIRSTATION") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_AIRSTATION;
    if (s == "FEEDAIRUNIT") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_FEEDAIRUNIT;
    if (s == "OXYGENGENERATOR") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_OXYGENGENERATOR;
    if (s == "OXYGENPLANT") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_OXYGENPLANT;
    if (s == "VACUUMSTATION") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_VACUUMSTATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMemberTypeEnum::ToString(IfcMemberTypeEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BRACE", "CHORD", "COLLAR", "MEMBER", "MULLION", "PLATE", "POST", "PURLIN", "RAFTER", "STRINGER", "STRUT", "STUD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMemberTypeEnum::IfcMemberTypeEnum IfcMemberTypeEnum::FromString(const std::string& s) {
    if (s == "BRACE") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_BRACE;
    if (s == "CHORD") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_CHORD;
    if (s == "COLLAR") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_COLLAR;
    if (s == "MEMBER") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_MEMBER;
    if (s == "MULLION") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_MULLION;
    if (s == "PLATE") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_PLATE;
    if (s == "POST") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_POST;
    if (s == "PURLIN") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_PURLIN;
    if (s == "RAFTER") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_RAFTER;
    if (s == "STRINGER") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_STRINGER;
    if (s == "STRUT") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_STRUT;
    if (s == "STUD") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_STUD;
    if (s == "USERDEFINED") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMotorConnectionTypeEnum::ToString(IfcMotorConnectionTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BELTDRIVE", "COUPLING", "DIRECTDRIVE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum IfcMotorConnectionTypeEnum::FromString(const std::string& s) {
    if (s == "BELTDRIVE") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_BELTDRIVE;
    if (s == "COUPLING") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_COUPLING;
    if (s == "DIRECTDRIVE") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_DIRECTDRIVE;
    if (s == "USERDEFINED") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcNullStyle::ToString(IfcNullStyle v) {
    if ( v < 0 || v >= 1 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "NULL" };
    return names[v];
}

IfcNullStyle::IfcNullStyle IfcNullStyle::FromString(const std::string& s) {
    if (s == "NULL") return ::Ifc4::IfcNullStyle::IfcNullStyle_NULL;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcObjectTypeEnum::ToString(IfcObjectTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PRODUCT", "PROCESS", "CONTROL", "RESOURCE", "ACTOR", "GROUP", "PROJECT", "NOTDEFINED" };
    return names[v];
}

IfcObjectTypeEnum::IfcObjectTypeEnum IfcObjectTypeEnum::FromString(const std::string& s) {
    if (s == "PRODUCT") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_PRODUCT;
    if (s == "PROCESS") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_PROCESS;
    if (s == "CONTROL") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_CONTROL;
    if (s == "RESOURCE") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_RESOURCE;
    if (s == "ACTOR") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_ACTOR;
    if (s == "GROUP") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_GROUP;
    if (s == "PROJECT") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_PROJECT;
    if (s == "NOTDEFINED") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcObjectiveEnum::ToString(IfcObjectiveEnum v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CODECOMPLIANCE", "CODEWAIVER", "DESIGNINTENT", "EXTERNAL", "HEALTHANDSAFETY", "MERGECONFLICT", "MODELVIEW", "PARAMETER", "REQUIREMENT", "SPECIFICATION", "TRIGGERCONDITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcObjectiveEnum::IfcObjectiveEnum IfcObjectiveEnum::FromString(const std::string& s) {
    if (s == "CODECOMPLIANCE") return ::Ifc4::IfcObjectiveEnum::IfcObjective_CODECOMPLIANCE;
    if (s == "CODEWAIVER") return ::Ifc4::IfcObjectiveEnum::IfcObjective_CODEWAIVER;
    if (s == "DESIGNINTENT") return ::Ifc4::IfcObjectiveEnum::IfcObjective_DESIGNINTENT;
    if (s == "EXTERNAL") return ::Ifc4::IfcObjectiveEnum::IfcObjective_EXTERNAL;
    if (s == "HEALTHANDSAFETY") return ::Ifc4::IfcObjectiveEnum::IfcObjective_HEALTHANDSAFETY;
    if (s == "MERGECONFLICT") return ::Ifc4::IfcObjectiveEnum::IfcObjective_MERGECONFLICT;
    if (s == "MODELVIEW") return ::Ifc4::IfcObjectiveEnum::IfcObjective_MODELVIEW;
    if (s == "PARAMETER") return ::Ifc4::IfcObjectiveEnum::IfcObjective_PARAMETER;
    if (s == "REQUIREMENT") return ::Ifc4::IfcObjectiveEnum::IfcObjective_REQUIREMENT;
    if (s == "SPECIFICATION") return ::Ifc4::IfcObjectiveEnum::IfcObjective_SPECIFICATION;
    if (s == "TRIGGERCONDITION") return ::Ifc4::IfcObjectiveEnum::IfcObjective_TRIGGERCONDITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcObjectiveEnum::IfcObjective_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcObjectiveEnum::IfcObjective_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcOccupantTypeEnum::ToString(IfcOccupantTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ASSIGNEE", "ASSIGNOR", "LESSEE", "LESSOR", "LETTINGAGENT", "OWNER", "TENANT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcOccupantTypeEnum::IfcOccupantTypeEnum IfcOccupantTypeEnum::FromString(const std::string& s) {
    if (s == "ASSIGNEE") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_ASSIGNEE;
    if (s == "ASSIGNOR") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_ASSIGNOR;
    if (s == "LESSEE") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_LESSEE;
    if (s == "LESSOR") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_LESSOR;
    if (s == "LETTINGAGENT") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_LETTINGAGENT;
    if (s == "OWNER") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_OWNER;
    if (s == "TENANT") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_TENANT;
    if (s == "USERDEFINED") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcOpeningElementTypeEnum::ToString(IfcOpeningElementTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "OPENING", "RECESS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum IfcOpeningElementTypeEnum::FromString(const std::string& s) {
    if (s == "OPENING") return ::Ifc4::IfcOpeningElementTypeEnum::IfcOpeningElementType_OPENING;
    if (s == "RECESS") return ::Ifc4::IfcOpeningElementTypeEnum::IfcOpeningElementType_RECESS;
    if (s == "USERDEFINED") return ::Ifc4::IfcOpeningElementTypeEnum::IfcOpeningElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcOpeningElementTypeEnum::IfcOpeningElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcOutletTypeEnum::ToString(IfcOutletTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AUDIOVISUALOUTLET", "COMMUNICATIONSOUTLET", "POWEROUTLET", "DATAOUTLET", "TELEPHONEOUTLET", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcOutletTypeEnum::IfcOutletTypeEnum IfcOutletTypeEnum::FromString(const std::string& s) {
    if (s == "AUDIOVISUALOUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_AUDIOVISUALOUTLET;
    if (s == "COMMUNICATIONSOUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_COMMUNICATIONSOUTLET;
    if (s == "POWEROUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_POWEROUTLET;
    if (s == "DATAOUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_DATAOUTLET;
    if (s == "TELEPHONEOUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_TELEPHONEOUTLET;
    if (s == "USERDEFINED") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPerformanceHistoryTypeEnum::ToString(IfcPerformanceHistoryTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum IfcPerformanceHistoryTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPermeableCoveringOperationEnum::ToString(IfcPermeableCoveringOperationEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GRILL", "LOUVER", "SCREEN", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum IfcPermeableCoveringOperationEnum::FromString(const std::string& s) {
    if (s == "GRILL") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_GRILL;
    if (s == "LOUVER") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_LOUVER;
    if (s == "SCREEN") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_SCREEN;
    if (s == "USERDEFINED") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPermitTypeEnum::ToString(IfcPermitTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACCESS", "BUILDING", "WORK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPermitTypeEnum::IfcPermitTypeEnum IfcPermitTypeEnum::FromString(const std::string& s) {
    if (s == "ACCESS") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_ACCESS;
    if (s == "BUILDING") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_BUILDING;
    if (s == "WORK") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_WORK;
    if (s == "USERDEFINED") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPhysicalOrVirtualEnum::ToString(IfcPhysicalOrVirtualEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PHYSICAL", "VIRTUAL", "NOTDEFINED" };
    return names[v];
}

IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum IfcPhysicalOrVirtualEnum::FromString(const std::string& s) {
    if (s == "PHYSICAL") return ::Ifc4::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_PHYSICAL;
    if (s == "VIRTUAL") return ::Ifc4::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_VIRTUAL;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPileConstructionEnum::ToString(IfcPileConstructionEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CAST_IN_PLACE", "COMPOSITE", "PRECAST_CONCRETE", "PREFAB_STEEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPileConstructionEnum::IfcPileConstructionEnum IfcPileConstructionEnum::FromString(const std::string& s) {
    if (s == "CAST_IN_PLACE") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_CAST_IN_PLACE;
    if (s == "COMPOSITE") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_COMPOSITE;
    if (s == "PRECAST_CONCRETE") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_PRECAST_CONCRETE;
    if (s == "PREFAB_STEEL") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_PREFAB_STEEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPileTypeEnum::ToString(IfcPileTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BORED", "DRIVEN", "JETGROUTING", "COHESION", "FRICTION", "SUPPORT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPileTypeEnum::IfcPileTypeEnum IfcPileTypeEnum::FromString(const std::string& s) {
    if (s == "BORED") return ::Ifc4::IfcPileTypeEnum::IfcPileType_BORED;
    if (s == "DRIVEN") return ::Ifc4::IfcPileTypeEnum::IfcPileType_DRIVEN;
    if (s == "JETGROUTING") return ::Ifc4::IfcPileTypeEnum::IfcPileType_JETGROUTING;
    if (s == "COHESION") return ::Ifc4::IfcPileTypeEnum::IfcPileType_COHESION;
    if (s == "FRICTION") return ::Ifc4::IfcPileTypeEnum::IfcPileType_FRICTION;
    if (s == "SUPPORT") return ::Ifc4::IfcPileTypeEnum::IfcPileType_SUPPORT;
    if (s == "USERDEFINED") return ::Ifc4::IfcPileTypeEnum::IfcPileType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPileTypeEnum::IfcPileType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPipeFittingTypeEnum::ToString(IfcPipeFittingTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEND", "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "OBSTRUCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum IfcPipeFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_BEND;
    if (s == "CONNECTOR") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_JUNCTION;
    if (s == "OBSTRUCTION") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_OBSTRUCTION;
    if (s == "TRANSITION") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPipeSegmentTypeEnum::ToString(IfcPipeSegmentTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CULVERT", "FLEXIBLESEGMENT", "RIGIDSEGMENT", "GUTTER", "SPOOL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum IfcPipeSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "CULVERT") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_CULVERT;
    if (s == "FLEXIBLESEGMENT") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_FLEXIBLESEGMENT;
    if (s == "RIGIDSEGMENT") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_RIGIDSEGMENT;
    if (s == "GUTTER") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_GUTTER;
    if (s == "SPOOL") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_SPOOL;
    if (s == "USERDEFINED") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPlateTypeEnum::ToString(IfcPlateTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CURTAIN_PANEL", "SHEET", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPlateTypeEnum::IfcPlateTypeEnum IfcPlateTypeEnum::FromString(const std::string& s) {
    if (s == "CURTAIN_PANEL") return ::Ifc4::IfcPlateTypeEnum::IfcPlateType_CURTAIN_PANEL;
    if (s == "SHEET") return ::Ifc4::IfcPlateTypeEnum::IfcPlateType_SHEET;
    if (s == "USERDEFINED") return ::Ifc4::IfcPlateTypeEnum::IfcPlateType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPlateTypeEnum::IfcPlateType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProcedureTypeEnum::ToString(IfcProcedureTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ADVICE_CAUTION", "ADVICE_NOTE", "ADVICE_WARNING", "CALIBRATION", "DIAGNOSTIC", "SHUTDOWN", "STARTUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProcedureTypeEnum::IfcProcedureTypeEnum IfcProcedureTypeEnum::FromString(const std::string& s) {
    if (s == "ADVICE_CAUTION") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_CAUTION;
    if (s == "ADVICE_NOTE") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_NOTE;
    if (s == "ADVICE_WARNING") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_WARNING;
    if (s == "CALIBRATION") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_CALIBRATION;
    if (s == "DIAGNOSTIC") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_DIAGNOSTIC;
    if (s == "SHUTDOWN") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_SHUTDOWN;
    if (s == "STARTUP") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_STARTUP;
    if (s == "USERDEFINED") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProfileTypeEnum::ToString(IfcProfileTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CURVE", "AREA" };
    return names[v];
}

IfcProfileTypeEnum::IfcProfileTypeEnum IfcProfileTypeEnum::FromString(const std::string& s) {
    if (s == "CURVE") return ::Ifc4::IfcProfileTypeEnum::IfcProfileType_CURVE;
    if (s == "AREA") return ::Ifc4::IfcProfileTypeEnum::IfcProfileType_AREA;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProjectOrderTypeEnum::ToString(IfcProjectOrderTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CHANGEORDER", "MAINTENANCEWORKORDER", "MOVEORDER", "PURCHASEORDER", "WORKORDER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum IfcProjectOrderTypeEnum::FromString(const std::string& s) {
    if (s == "CHANGEORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_CHANGEORDER;
    if (s == "MAINTENANCEWORKORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_MAINTENANCEWORKORDER;
    if (s == "MOVEORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_MOVEORDER;
    if (s == "PURCHASEORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_PURCHASEORDER;
    if (s == "WORKORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_WORKORDER;
    if (s == "USERDEFINED") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProjectedOrTrueLengthEnum::ToString(IfcProjectedOrTrueLengthEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PROJECTED_LENGTH", "TRUE_LENGTH" };
    return names[v];
}

IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum IfcProjectedOrTrueLengthEnum::FromString(const std::string& s) {
    if (s == "PROJECTED_LENGTH") return ::Ifc4::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLength_PROJECTED_LENGTH;
    if (s == "TRUE_LENGTH") return ::Ifc4::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLength_TRUE_LENGTH;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProjectionElementTypeEnum::ToString(IfcProjectionElementTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum IfcProjectionElementTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcProjectionElementTypeEnum::IfcProjectionElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProjectionElementTypeEnum::IfcProjectionElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPropertySetTemplateTypeEnum::ToString(IfcPropertySetTemplateTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PSET_TYPEDRIVENONLY", "PSET_TYPEDRIVENOVERRIDE", "PSET_OCCURRENCEDRIVEN", "PSET_PERFORMANCEDRIVEN", "QTO_TYPEDRIVENONLY", "QTO_TYPEDRIVENOVERRIDE", "QTO_OCCURRENCEDRIVEN", "NOTDEFINED" };
    return names[v];
}

IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum IfcPropertySetTemplateTypeEnum::FromString(const std::string& s) {
    if (s == "PSET_TYPEDRIVENONLY") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_PSET_TYPEDRIVENONLY;
    if (s == "PSET_TYPEDRIVENOVERRIDE") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_PSET_TYPEDRIVENOVERRIDE;
    if (s == "PSET_OCCURRENCEDRIVEN") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_PSET_OCCURRENCEDRIVEN;
    if (s == "PSET_PERFORMANCEDRIVEN") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_PSET_PERFORMANCEDRIVEN;
    if (s == "QTO_TYPEDRIVENONLY") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_QTO_TYPEDRIVENONLY;
    if (s == "QTO_TYPEDRIVENOVERRIDE") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_QTO_TYPEDRIVENOVERRIDE;
    if (s == "QTO_OCCURRENCEDRIVEN") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_QTO_OCCURRENCEDRIVEN;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(IfcProtectiveDeviceTrippingUnitTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELECTRONIC", "ELECTROMAGNETIC", "RESIDUALCURRENT", "THERMAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum IfcProtectiveDeviceTrippingUnitTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRONIC") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_ELECTRONIC;
    if (s == "ELECTROMAGNETIC") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_ELECTROMAGNETIC;
    if (s == "RESIDUALCURRENT") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_RESIDUALCURRENT;
    if (s == "THERMAL") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_THERMAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProtectiveDeviceTypeEnum::ToString(IfcProtectiveDeviceTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CIRCUITBREAKER", "EARTHLEAKAGECIRCUITBREAKER", "EARTHINGSWITCH", "FUSEDISCONNECTOR", "RESIDUALCURRENTCIRCUITBREAKER", "RESIDUALCURRENTSWITCH", "VARISTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum IfcProtectiveDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "CIRCUITBREAKER") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_CIRCUITBREAKER;
    if (s == "EARTHLEAKAGECIRCUITBREAKER") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_EARTHLEAKAGECIRCUITBREAKER;
    if (s == "EARTHINGSWITCH") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_EARTHINGSWITCH;
    if (s == "FUSEDISCONNECTOR") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_FUSEDISCONNECTOR;
    if (s == "RESIDUALCURRENTCIRCUITBREAKER") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_RESIDUALCURRENTCIRCUITBREAKER;
    if (s == "RESIDUALCURRENTSWITCH") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_RESIDUALCURRENTSWITCH;
    if (s == "VARISTOR") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_VARISTOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPumpTypeEnum::ToString(IfcPumpTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CIRCULATOR", "ENDSUCTION", "SPLITCASE", "SUBMERSIBLEPUMP", "SUMPPUMP", "VERTICALINLINE", "VERTICALTURBINE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPumpTypeEnum::IfcPumpTypeEnum IfcPumpTypeEnum::FromString(const std::string& s) {
    if (s == "CIRCULATOR") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_CIRCULATOR;
    if (s == "ENDSUCTION") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_ENDSUCTION;
    if (s == "SPLITCASE") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_SPLITCASE;
    if (s == "SUBMERSIBLEPUMP") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_SUBMERSIBLEPUMP;
    if (s == "SUMPPUMP") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_SUMPPUMP;
    if (s == "VERTICALINLINE") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_VERTICALINLINE;
    if (s == "VERTICALTURBINE") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_VERTICALTURBINE;
    if (s == "USERDEFINED") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRailingTypeEnum::ToString(IfcRailingTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "HANDRAIL", "GUARDRAIL", "BALUSTRADE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRailingTypeEnum::IfcRailingTypeEnum IfcRailingTypeEnum::FromString(const std::string& s) {
    if (s == "HANDRAIL") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_HANDRAIL;
    if (s == "GUARDRAIL") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_GUARDRAIL;
    if (s == "BALUSTRADE") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_BALUSTRADE;
    if (s == "USERDEFINED") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRampFlightTypeEnum::ToString(IfcRampFlightTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT", "SPIRAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRampFlightTypeEnum::IfcRampFlightTypeEnum IfcRampFlightTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT") return ::Ifc4::IfcRampFlightTypeEnum::IfcRampFlightType_STRAIGHT;
    if (s == "SPIRAL") return ::Ifc4::IfcRampFlightTypeEnum::IfcRampFlightType_SPIRAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcRampFlightTypeEnum::IfcRampFlightType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcRampFlightTypeEnum::IfcRampFlightType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRampTypeEnum::ToString(IfcRampTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT_RUN_RAMP", "TWO_STRAIGHT_RUN_RAMP", "QUARTER_TURN_RAMP", "TWO_QUARTER_TURN_RAMP", "HALF_TURN_RAMP", "SPIRAL_RAMP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRampTypeEnum::IfcRampTypeEnum IfcRampTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT_RUN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_STRAIGHT_RUN_RAMP;
    if (s == "TWO_STRAIGHT_RUN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_TWO_STRAIGHT_RUN_RAMP;
    if (s == "QUARTER_TURN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_QUARTER_TURN_RAMP;
    if (s == "TWO_QUARTER_TURN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_TWO_QUARTER_TURN_RAMP;
    if (s == "HALF_TURN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_HALF_TURN_RAMP;
    if (s == "SPIRAL_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_SPIRAL_RAMP;
    if (s == "USERDEFINED") return ::Ifc4::IfcRampTypeEnum::IfcRampType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcRampTypeEnum::IfcRampType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRecurrenceTypeEnum::ToString(IfcRecurrenceTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DAILY", "WEEKLY", "MONTHLY_BY_DAY_OF_MONTH", "MONTHLY_BY_POSITION", "BY_DAY_COUNT", "BY_WEEKDAY_COUNT", "YEARLY_BY_DAY_OF_MONTH", "YEARLY_BY_POSITION" };
    return names[v];
}

IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum IfcRecurrenceTypeEnum::FromString(const std::string& s) {
    if (s == "DAILY") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_DAILY;
    if (s == "WEEKLY") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_WEEKLY;
    if (s == "MONTHLY_BY_DAY_OF_MONTH") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_MONTHLY_BY_DAY_OF_MONTH;
    if (s == "MONTHLY_BY_POSITION") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_MONTHLY_BY_POSITION;
    if (s == "BY_DAY_COUNT") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_BY_DAY_COUNT;
    if (s == "BY_WEEKDAY_COUNT") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_BY_WEEKDAY_COUNT;
    if (s == "YEARLY_BY_DAY_OF_MONTH") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_YEARLY_BY_DAY_OF_MONTH;
    if (s == "YEARLY_BY_POSITION") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_YEARLY_BY_POSITION;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReflectanceMethodEnum::ToString(IfcReflectanceMethodEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BLINN", "FLAT", "GLASS", "MATT", "METAL", "MIRROR", "PHONG", "PLASTIC", "STRAUSS", "NOTDEFINED" };
    return names[v];
}

IfcReflectanceMethodEnum::IfcReflectanceMethodEnum IfcReflectanceMethodEnum::FromString(const std::string& s) {
    if (s == "BLINN") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_BLINN;
    if (s == "FLAT") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_FLAT;
    if (s == "GLASS") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_GLASS;
    if (s == "MATT") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_MATT;
    if (s == "METAL") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_METAL;
    if (s == "MIRROR") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_MIRROR;
    if (s == "PHONG") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_PHONG;
    if (s == "PLASTIC") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_PLASTIC;
    if (s == "STRAUSS") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_STRAUSS;
    if (s == "NOTDEFINED") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingBarRoleEnum::ToString(IfcReinforcingBarRoleEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MAIN", "SHEAR", "LIGATURE", "STUD", "PUNCHING", "EDGE", "RING", "ANCHORING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum IfcReinforcingBarRoleEnum::FromString(const std::string& s) {
    if (s == "MAIN") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_MAIN;
    if (s == "SHEAR") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_SHEAR;
    if (s == "LIGATURE") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_LIGATURE;
    if (s == "STUD") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_STUD;
    if (s == "PUNCHING") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_PUNCHING;
    if (s == "EDGE") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_EDGE;
    if (s == "RING") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_RING;
    if (s == "ANCHORING") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_ANCHORING;
    if (s == "USERDEFINED") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingBarSurfaceEnum::ToString(IfcReinforcingBarSurfaceEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PLAIN", "TEXTURED" };
    return names[v];
}

IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcingBarSurfaceEnum::FromString(const std::string& s) {
    if (s == "PLAIN") return ::Ifc4::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurface_PLAIN;
    if (s == "TEXTURED") return ::Ifc4::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurface_TEXTURED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingBarTypeEnum::ToString(IfcReinforcingBarTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANCHORING", "EDGE", "LIGATURE", "MAIN", "PUNCHING", "RING", "SHEAR", "STUD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum IfcReinforcingBarTypeEnum::FromString(const std::string& s) {
    if (s == "ANCHORING") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_ANCHORING;
    if (s == "EDGE") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_EDGE;
    if (s == "LIGATURE") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_LIGATURE;
    if (s == "MAIN") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_MAIN;
    if (s == "PUNCHING") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_PUNCHING;
    if (s == "RING") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_RING;
    if (s == "SHEAR") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_SHEAR;
    if (s == "STUD") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_STUD;
    if (s == "USERDEFINED") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingMeshTypeEnum::ToString(IfcReinforcingMeshTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum IfcReinforcingMeshTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcReinforcingMeshTypeEnum::IfcReinforcingMeshType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcReinforcingMeshTypeEnum::IfcReinforcingMeshType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRoleEnum::ToString(IfcRoleEnum v) {
    if ( v < 0 || v >= 23 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SUPPLIER", "MANUFACTURER", "CONTRACTOR", "SUBCONTRACTOR", "ARCHITECT", "STRUCTURALENGINEER", "COSTENGINEER", "CLIENT", "BUILDINGOWNER", "BUILDINGOPERATOR", "MECHANICALENGINEER", "ELECTRICALENGINEER", "PROJECTMANAGER", "FACILITIESMANAGER", "CIVILENGINEER", "COMMISSIONINGENGINEER", "ENGINEER", "OWNER", "CONSULTANT", "CONSTRUCTIONMANAGER", "FIELDCONSTRUCTIONMANAGER", "RESELLER", "USERDEFINED" };
    return names[v];
}

IfcRoleEnum::IfcRoleEnum IfcRoleEnum::FromString(const std::string& s) {
    if (s == "SUPPLIER") return ::Ifc4::IfcRoleEnum::IfcRole_SUPPLIER;
    if (s == "MANUFACTURER") return ::Ifc4::IfcRoleEnum::IfcRole_MANUFACTURER;
    if (s == "CONTRACTOR") return ::Ifc4::IfcRoleEnum::IfcRole_CONTRACTOR;
    if (s == "SUBCONTRACTOR") return ::Ifc4::IfcRoleEnum::IfcRole_SUBCONTRACTOR;
    if (s == "ARCHITECT") return ::Ifc4::IfcRoleEnum::IfcRole_ARCHITECT;
    if (s == "STRUCTURALENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_STRUCTURALENGINEER;
    if (s == "COSTENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_COSTENGINEER;
    if (s == "CLIENT") return ::Ifc4::IfcRoleEnum::IfcRole_CLIENT;
    if (s == "BUILDINGOWNER") return ::Ifc4::IfcRoleEnum::IfcRole_BUILDINGOWNER;
    if (s == "BUILDINGOPERATOR") return ::Ifc4::IfcRoleEnum::IfcRole_BUILDINGOPERATOR;
    if (s == "MECHANICALENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_MECHANICALENGINEER;
    if (s == "ELECTRICALENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_ELECTRICALENGINEER;
    if (s == "PROJECTMANAGER") return ::Ifc4::IfcRoleEnum::IfcRole_PROJECTMANAGER;
    if (s == "FACILITIESMANAGER") return ::Ifc4::IfcRoleEnum::IfcRole_FACILITIESMANAGER;
    if (s == "CIVILENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_CIVILENGINEER;
    if (s == "COMMISSIONINGENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_COMMISSIONINGENGINEER;
    if (s == "ENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_ENGINEER;
    if (s == "OWNER") return ::Ifc4::IfcRoleEnum::IfcRole_OWNER;
    if (s == "CONSULTANT") return ::Ifc4::IfcRoleEnum::IfcRole_CONSULTANT;
    if (s == "CONSTRUCTIONMANAGER") return ::Ifc4::IfcRoleEnum::IfcRole_CONSTRUCTIONMANAGER;
    if (s == "FIELDCONSTRUCTIONMANAGER") return ::Ifc4::IfcRoleEnum::IfcRole_FIELDCONSTRUCTIONMANAGER;
    if (s == "RESELLER") return ::Ifc4::IfcRoleEnum::IfcRole_RESELLER;
    if (s == "USERDEFINED") return ::Ifc4::IfcRoleEnum::IfcRole_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRoofTypeEnum::ToString(IfcRoofTypeEnum v) {
    if ( v < 0 || v >= 15 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLAT_ROOF", "SHED_ROOF", "GABLE_ROOF", "HIP_ROOF", "HIPPED_GABLE_ROOF", "GAMBREL_ROOF", "MANSARD_ROOF", "BARREL_ROOF", "RAINBOW_ROOF", "BUTTERFLY_ROOF", "PAVILION_ROOF", "DOME_ROOF", "FREEFORM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRoofTypeEnum::IfcRoofTypeEnum IfcRoofTypeEnum::FromString(const std::string& s) {
    if (s == "FLAT_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_FLAT_ROOF;
    if (s == "SHED_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_SHED_ROOF;
    if (s == "GABLE_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_GABLE_ROOF;
    if (s == "HIP_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_HIP_ROOF;
    if (s == "HIPPED_GABLE_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_HIPPED_GABLE_ROOF;
    if (s == "GAMBREL_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_GAMBREL_ROOF;
    if (s == "MANSARD_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_MANSARD_ROOF;
    if (s == "BARREL_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_BARREL_ROOF;
    if (s == "RAINBOW_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_RAINBOW_ROOF;
    if (s == "BUTTERFLY_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_BUTTERFLY_ROOF;
    if (s == "PAVILION_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_PAVILION_ROOF;
    if (s == "DOME_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_DOME_ROOF;
    if (s == "FREEFORM") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_FREEFORM;
    if (s == "USERDEFINED") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSIPrefix::ToString(IfcSIPrefix v) {
    if ( v < 0 || v >= 16 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EXA", "PETA", "TERA", "GIGA", "MEGA", "KILO", "HECTO", "DECA", "DECI", "CENTI", "MILLI", "MICRO", "NANO", "PICO", "FEMTO", "ATTO" };
    return names[v];
}

IfcSIPrefix::IfcSIPrefix IfcSIPrefix::FromString(const std::string& s) {
    if (s == "EXA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_EXA;
    if (s == "PETA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_PETA;
    if (s == "TERA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_TERA;
    if (s == "GIGA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_GIGA;
    if (s == "MEGA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_MEGA;
    if (s == "KILO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_KILO;
    if (s == "HECTO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_HECTO;
    if (s == "DECA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_DECA;
    if (s == "DECI") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_DECI;
    if (s == "CENTI") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_CENTI;
    if (s == "MILLI") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_MILLI;
    if (s == "MICRO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_MICRO;
    if (s == "NANO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_NANO;
    if (s == "PICO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_PICO;
    if (s == "FEMTO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_FEMTO;
    if (s == "ATTO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_ATTO;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSIUnitName::ToString(IfcSIUnitName v) {
    if ( v < 0 || v >= 30 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AMPERE", "BECQUEREL", "CANDELA", "COULOMB", "CUBIC_METRE", "DEGREE_CELSIUS", "FARAD", "GRAM", "GRAY", "HENRY", "HERTZ", "JOULE", "KELVIN", "LUMEN", "LUX", "METRE", "MOLE", "NEWTON", "OHM", "PASCAL", "RADIAN", "SECOND", "SIEMENS", "SIEVERT", "SQUARE_METRE", "STERADIAN", "TESLA", "VOLT", "WATT", "WEBER" };
    return names[v];
}

IfcSIUnitName::IfcSIUnitName IfcSIUnitName::FromString(const std::string& s) {
    if (s == "AMPERE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_AMPERE;
    if (s == "BECQUEREL") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_BECQUEREL;
    if (s == "CANDELA") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_CANDELA;
    if (s == "COULOMB") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_COULOMB;
    if (s == "CUBIC_METRE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_CUBIC_METRE;
    if (s == "DEGREE_CELSIUS") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_DEGREE_CELSIUS;
    if (s == "FARAD") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_FARAD;
    if (s == "GRAM") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_GRAM;
    if (s == "GRAY") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_GRAY;
    if (s == "HENRY") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_HENRY;
    if (s == "HERTZ") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_HERTZ;
    if (s == "JOULE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_JOULE;
    if (s == "KELVIN") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_KELVIN;
    if (s == "LUMEN") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_LUMEN;
    if (s == "LUX") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_LUX;
    if (s == "METRE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_METRE;
    if (s == "MOLE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_MOLE;
    if (s == "NEWTON") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_NEWTON;
    if (s == "OHM") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_OHM;
    if (s == "PASCAL") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_PASCAL;
    if (s == "RADIAN") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_RADIAN;
    if (s == "SECOND") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_SECOND;
    if (s == "SIEMENS") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_SIEMENS;
    if (s == "SIEVERT") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_SIEVERT;
    if (s == "SQUARE_METRE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_SQUARE_METRE;
    if (s == "STERADIAN") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_STERADIAN;
    if (s == "TESLA") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_TESLA;
    if (s == "VOLT") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_VOLT;
    if (s == "WATT") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_WATT;
    if (s == "WEBER") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_WEBER;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSanitaryTerminalTypeEnum::ToString(IfcSanitaryTerminalTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BATH", "BIDET", "CISTERN", "SHOWER", "SINK", "SANITARYFOUNTAIN", "TOILETPAN", "URINAL", "WASHHANDBASIN", "WCSEAT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum IfcSanitaryTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BATH") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_BATH;
    if (s == "BIDET") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_BIDET;
    if (s == "CISTERN") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_CISTERN;
    if (s == "SHOWER") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SHOWER;
    if (s == "SINK") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SINK;
    if (s == "SANITARYFOUNTAIN") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SANITARYFOUNTAIN;
    if (s == "TOILETPAN") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_TOILETPAN;
    if (s == "URINAL") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_URINAL;
    if (s == "WASHHANDBASIN") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_WASHHANDBASIN;
    if (s == "WCSEAT") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_WCSEAT;
    if (s == "USERDEFINED") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSectionTypeEnum::ToString(IfcSectionTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "UNIFORM", "TAPERED" };
    return names[v];
}

IfcSectionTypeEnum::IfcSectionTypeEnum IfcSectionTypeEnum::FromString(const std::string& s) {
    if (s == "UNIFORM") return ::Ifc4::IfcSectionTypeEnum::IfcSectionType_UNIFORM;
    if (s == "TAPERED") return ::Ifc4::IfcSectionTypeEnum::IfcSectionType_TAPERED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSensorTypeEnum::ToString(IfcSensorTypeEnum v) {
    if ( v < 0 || v >= 25 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CO2SENSOR", "CONDUCTANCESENSOR", "CONTACTSENSOR", "FIRESENSOR", "FLOWSENSOR", "FROSTSENSOR", "GASSENSOR", "HEATSENSOR", "HUMIDITYSENSOR", "IDENTIFIERSENSOR", "IONCONCENTRATIONSENSOR", "LEVELSENSOR", "LIGHTSENSOR", "MOISTURESENSOR", "MOVEMENTSENSOR", "PHSENSOR", "PRESSURESENSOR", "RADIATIONSENSOR", "RADIOACTIVITYSENSOR", "SMOKESENSOR", "SOUNDSENSOR", "TEMPERATURESENSOR", "WINDSENSOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSensorTypeEnum::IfcSensorTypeEnum IfcSensorTypeEnum::FromString(const std::string& s) {
    if (s == "CO2SENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_CO2SENSOR;
    if (s == "CONDUCTANCESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_CONDUCTANCESENSOR;
    if (s == "CONTACTSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_CONTACTSENSOR;
    if (s == "FIRESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_FIRESENSOR;
    if (s == "FLOWSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_FLOWSENSOR;
    if (s == "FROSTSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_FROSTSENSOR;
    if (s == "GASSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_GASSENSOR;
    if (s == "HEATSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_HEATSENSOR;
    if (s == "HUMIDITYSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_HUMIDITYSENSOR;
    if (s == "IDENTIFIERSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_IDENTIFIERSENSOR;
    if (s == "IONCONCENTRATIONSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_IONCONCENTRATIONSENSOR;
    if (s == "LEVELSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_LEVELSENSOR;
    if (s == "LIGHTSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_LIGHTSENSOR;
    if (s == "MOISTURESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_MOISTURESENSOR;
    if (s == "MOVEMENTSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_MOVEMENTSENSOR;
    if (s == "PHSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_PHSENSOR;
    if (s == "PRESSURESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_PRESSURESENSOR;
    if (s == "RADIATIONSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_RADIATIONSENSOR;
    if (s == "RADIOACTIVITYSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_RADIOACTIVITYSENSOR;
    if (s == "SMOKESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_SMOKESENSOR;
    if (s == "SOUNDSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_SOUNDSENSOR;
    if (s == "TEMPERATURESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_TEMPERATURESENSOR;
    if (s == "WINDSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_WINDSENSOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSequenceEnum::ToString(IfcSequenceEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "START_START", "START_FINISH", "FINISH_START", "FINISH_FINISH", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSequenceEnum::IfcSequenceEnum IfcSequenceEnum::FromString(const std::string& s) {
    if (s == "START_START") return ::Ifc4::IfcSequenceEnum::IfcSequence_START_START;
    if (s == "START_FINISH") return ::Ifc4::IfcSequenceEnum::IfcSequence_START_FINISH;
    if (s == "FINISH_START") return ::Ifc4::IfcSequenceEnum::IfcSequence_FINISH_START;
    if (s == "FINISH_FINISH") return ::Ifc4::IfcSequenceEnum::IfcSequence_FINISH_FINISH;
    if (s == "USERDEFINED") return ::Ifc4::IfcSequenceEnum::IfcSequence_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSequenceEnum::IfcSequence_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcShadingDeviceTypeEnum::ToString(IfcShadingDeviceTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "JALOUSIE", "SHUTTER", "AWNING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum IfcShadingDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "JALOUSIE") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_JALOUSIE;
    if (s == "SHUTTER") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_SHUTTER;
    if (s == "AWNING") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_AWNING;
    if (s == "USERDEFINED") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSimplePropertyTemplateTypeEnum::ToString(IfcSimplePropertyTemplateTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "P_SINGLEVALUE", "P_ENUMERATEDVALUE", "P_BOUNDEDVALUE", "P_LISTVALUE", "P_TABLEVALUE", "P_REFERENCEVALUE", "Q_LENGTH", "Q_AREA", "Q_VOLUME", "Q_COUNT", "Q_WEIGHT", "Q_TIME" };
    return names[v];
}

IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum IfcSimplePropertyTemplateTypeEnum::FromString(const std::string& s) {
    if (s == "P_SINGLEVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_SINGLEVALUE;
    if (s == "P_ENUMERATEDVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_ENUMERATEDVALUE;
    if (s == "P_BOUNDEDVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_BOUNDEDVALUE;
    if (s == "P_LISTVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_LISTVALUE;
    if (s == "P_TABLEVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_TABLEVALUE;
    if (s == "P_REFERENCEVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_REFERENCEVALUE;
    if (s == "Q_LENGTH") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_LENGTH;
    if (s == "Q_AREA") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_AREA;
    if (s == "Q_VOLUME") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_VOLUME;
    if (s == "Q_COUNT") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_COUNT;
    if (s == "Q_WEIGHT") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_WEIGHT;
    if (s == "Q_TIME") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_TIME;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSlabTypeEnum::ToString(IfcSlabTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLOOR", "ROOF", "LANDING", "BASESLAB", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSlabTypeEnum::IfcSlabTypeEnum IfcSlabTypeEnum::FromString(const std::string& s) {
    if (s == "FLOOR") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_FLOOR;
    if (s == "ROOF") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_ROOF;
    if (s == "LANDING") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_LANDING;
    if (s == "BASESLAB") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_BASESLAB;
    if (s == "USERDEFINED") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSolarDeviceTypeEnum::ToString(IfcSolarDeviceTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SOLARCOLLECTOR", "SOLARPANEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum IfcSolarDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "SOLARCOLLECTOR") return ::Ifc4::IfcSolarDeviceTypeEnum::IfcSolarDeviceType_SOLARCOLLECTOR;
    if (s == "SOLARPANEL") return ::Ifc4::IfcSolarDeviceTypeEnum::IfcSolarDeviceType_SOLARPANEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcSolarDeviceTypeEnum::IfcSolarDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSolarDeviceTypeEnum::IfcSolarDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSpaceHeaterTypeEnum::ToString(IfcSpaceHeaterTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONVECTOR", "RADIATOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum IfcSpaceHeaterTypeEnum::FromString(const std::string& s) {
    if (s == "CONVECTOR") return ::Ifc4::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_CONVECTOR;
    if (s == "RADIATOR") return ::Ifc4::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_RADIATOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSpaceTypeEnum::ToString(IfcSpaceTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SPACE", "PARKING", "GFA", "INTERNAL", "EXTERNAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSpaceTypeEnum::IfcSpaceTypeEnum IfcSpaceTypeEnum::FromString(const std::string& s) {
    if (s == "SPACE") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_SPACE;
    if (s == "PARKING") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_PARKING;
    if (s == "GFA") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_GFA;
    if (s == "INTERNAL") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_INTERNAL;
    if (s == "EXTERNAL") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_EXTERNAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSpatialZoneTypeEnum::ToString(IfcSpatialZoneTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONSTRUCTION", "FIRESAFETY", "LIGHTING", "OCCUPANCY", "SECURITY", "THERMAL", "TRANSPORT", "VENTILATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum IfcSpatialZoneTypeEnum::FromString(const std::string& s) {
    if (s == "CONSTRUCTION") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_CONSTRUCTION;
    if (s == "FIRESAFETY") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_FIRESAFETY;
    if (s == "LIGHTING") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_LIGHTING;
    if (s == "OCCUPANCY") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_OCCUPANCY;
    if (s == "SECURITY") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_SECURITY;
    if (s == "THERMAL") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_THERMAL;
    if (s == "TRANSPORT") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_TRANSPORT;
    if (s == "VENTILATION") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_VENTILATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStackTerminalTypeEnum::ToString(IfcStackTerminalTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BIRDCAGE", "COWL", "RAINWATERHOPPER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum IfcStackTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BIRDCAGE") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_BIRDCAGE;
    if (s == "COWL") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_COWL;
    if (s == "RAINWATERHOPPER") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_RAINWATERHOPPER;
    if (s == "USERDEFINED") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStairFlightTypeEnum::ToString(IfcStairFlightTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT", "WINDER", "SPIRAL", "CURVED", "FREEFORM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStairFlightTypeEnum::IfcStairFlightTypeEnum IfcStairFlightTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_STRAIGHT;
    if (s == "WINDER") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_WINDER;
    if (s == "SPIRAL") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_SPIRAL;
    if (s == "CURVED") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_CURVED;
    if (s == "FREEFORM") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_FREEFORM;
    if (s == "USERDEFINED") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStairTypeEnum::ToString(IfcStairTypeEnum v) {
    if ( v < 0 || v >= 16 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT_RUN_STAIR", "TWO_STRAIGHT_RUN_STAIR", "QUARTER_WINDING_STAIR", "QUARTER_TURN_STAIR", "HALF_WINDING_STAIR", "HALF_TURN_STAIR", "TWO_QUARTER_WINDING_STAIR", "TWO_QUARTER_TURN_STAIR", "THREE_QUARTER_WINDING_STAIR", "THREE_QUARTER_TURN_STAIR", "SPIRAL_STAIR", "DOUBLE_RETURN_STAIR", "CURVED_RUN_STAIR", "TWO_CURVED_RUN_STAIR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStairTypeEnum::IfcStairTypeEnum IfcStairTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT_RUN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_STRAIGHT_RUN_STAIR;
    if (s == "TWO_STRAIGHT_RUN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_TWO_STRAIGHT_RUN_STAIR;
    if (s == "QUARTER_WINDING_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_QUARTER_WINDING_STAIR;
    if (s == "QUARTER_TURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_QUARTER_TURN_STAIR;
    if (s == "HALF_WINDING_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_HALF_WINDING_STAIR;
    if (s == "HALF_TURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_HALF_TURN_STAIR;
    if (s == "TWO_QUARTER_WINDING_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_TWO_QUARTER_WINDING_STAIR;
    if (s == "TWO_QUARTER_TURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_TWO_QUARTER_TURN_STAIR;
    if (s == "THREE_QUARTER_WINDING_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_THREE_QUARTER_WINDING_STAIR;
    if (s == "THREE_QUARTER_TURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_THREE_QUARTER_TURN_STAIR;
    if (s == "SPIRAL_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_SPIRAL_STAIR;
    if (s == "DOUBLE_RETURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_DOUBLE_RETURN_STAIR;
    if (s == "CURVED_RUN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_CURVED_RUN_STAIR;
    if (s == "TWO_CURVED_RUN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_TWO_CURVED_RUN_STAIR;
    if (s == "USERDEFINED") return ::Ifc4::IfcStairTypeEnum::IfcStairType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStairTypeEnum::IfcStairType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStateEnum::ToString(IfcStateEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "READWRITE", "READONLY", "LOCKED", "READWRITELOCKED", "READONLYLOCKED" };
    return names[v];
}

IfcStateEnum::IfcStateEnum IfcStateEnum::FromString(const std::string& s) {
    if (s == "READWRITE") return ::Ifc4::IfcStateEnum::IfcState_READWRITE;
    if (s == "READONLY") return ::Ifc4::IfcStateEnum::IfcState_READONLY;
    if (s == "LOCKED") return ::Ifc4::IfcStateEnum::IfcState_LOCKED;
    if (s == "READWRITELOCKED") return ::Ifc4::IfcStateEnum::IfcState_READWRITELOCKED;
    if (s == "READONLYLOCKED") return ::Ifc4::IfcStateEnum::IfcState_READONLYLOCKED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralCurveActivityTypeEnum::ToString(IfcStructuralCurveActivityTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONST", "LINEAR", "POLYGONAL", "EQUIDISTANT", "SINUS", "PARABOLA", "DISCRETE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum IfcStructuralCurveActivityTypeEnum::FromString(const std::string& s) {
    if (s == "CONST") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_CONST;
    if (s == "LINEAR") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_LINEAR;
    if (s == "POLYGONAL") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_POLYGONAL;
    if (s == "EQUIDISTANT") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_EQUIDISTANT;
    if (s == "SINUS") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_SINUS;
    if (s == "PARABOLA") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_PARABOLA;
    if (s == "DISCRETE") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_DISCRETE;
    if (s == "USERDEFINED") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralCurveMemberTypeEnum::ToString(IfcStructuralCurveMemberTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "RIGID_JOINED_MEMBER", "PIN_JOINED_MEMBER", "CABLE", "TENSION_MEMBER", "COMPRESSION_MEMBER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum IfcStructuralCurveMemberTypeEnum::FromString(const std::string& s) {
    if (s == "RIGID_JOINED_MEMBER") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_RIGID_JOINED_MEMBER;
    if (s == "PIN_JOINED_MEMBER") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_PIN_JOINED_MEMBER;
    if (s == "CABLE") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_CABLE;
    if (s == "TENSION_MEMBER") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_TENSION_MEMBER;
    if (s == "COMPRESSION_MEMBER") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_COMPRESSION_MEMBER;
    if (s == "USERDEFINED") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralSurfaceActivityTypeEnum::ToString(IfcStructuralSurfaceActivityTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONST", "BILINEAR", "DISCRETE", "ISOCONTOUR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum IfcStructuralSurfaceActivityTypeEnum::FromString(const std::string& s) {
    if (s == "CONST") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_CONST;
    if (s == "BILINEAR") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_BILINEAR;
    if (s == "DISCRETE") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_DISCRETE;
    if (s == "ISOCONTOUR") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_ISOCONTOUR;
    if (s == "USERDEFINED") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralSurfaceMemberTypeEnum::ToString(IfcStructuralSurfaceMemberTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BENDING_ELEMENT", "MEMBRANE_ELEMENT", "SHELL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum IfcStructuralSurfaceMemberTypeEnum::FromString(const std::string& s) {
    if (s == "BENDING_ELEMENT") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_BENDING_ELEMENT;
    if (s == "MEMBRANE_ELEMENT") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_MEMBRANE_ELEMENT;
    if (s == "SHELL") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_SHELL;
    if (s == "USERDEFINED") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSubContractResourceTypeEnum::ToString(IfcSubContractResourceTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PURCHASE", "WORK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum IfcSubContractResourceTypeEnum::FromString(const std::string& s) {
    if (s == "PURCHASE") return ::Ifc4::IfcSubContractResourceTypeEnum::IfcSubContractResourceType_PURCHASE;
    if (s == "WORK") return ::Ifc4::IfcSubContractResourceTypeEnum::IfcSubContractResourceType_WORK;
    if (s == "USERDEFINED") return ::Ifc4::IfcSubContractResourceTypeEnum::IfcSubContractResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSubContractResourceTypeEnum::IfcSubContractResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSurfaceFeatureTypeEnum::ToString(IfcSurfaceFeatureTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MARK", "TAG", "TREATMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum IfcSurfaceFeatureTypeEnum::FromString(const std::string& s) {
    if (s == "MARK") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_MARK;
    if (s == "TAG") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_TAG;
    if (s == "TREATMENT") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_TREATMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSurfaceSide::ToString(IfcSurfaceSide v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POSITIVE", "NEGATIVE", "BOTH" };
    return names[v];
}

IfcSurfaceSide::IfcSurfaceSide IfcSurfaceSide::FromString(const std::string& s) {
    if (s == "POSITIVE") return ::Ifc4::IfcSurfaceSide::IfcSurfaceSide_POSITIVE;
    if (s == "NEGATIVE") return ::Ifc4::IfcSurfaceSide::IfcSurfaceSide_NEGATIVE;
    if (s == "BOTH") return ::Ifc4::IfcSurfaceSide::IfcSurfaceSide_BOTH;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSwitchingDeviceTypeEnum::ToString(IfcSwitchingDeviceTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONTACTOR", "DIMMERSWITCH", "EMERGENCYSTOP", "KEYPAD", "MOMENTARYSWITCH", "SELECTORSWITCH", "STARTER", "SWITCHDISCONNECTOR", "TOGGLESWITCH", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum IfcSwitchingDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "CONTACTOR") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_CONTACTOR;
    if (s == "DIMMERSWITCH") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_DIMMERSWITCH;
    if (s == "EMERGENCYSTOP") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_EMERGENCYSTOP;
    if (s == "KEYPAD") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_KEYPAD;
    if (s == "MOMENTARYSWITCH") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_MOMENTARYSWITCH;
    if (s == "SELECTORSWITCH") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_SELECTORSWITCH;
    if (s == "STARTER") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_STARTER;
    if (s == "SWITCHDISCONNECTOR") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_SWITCHDISCONNECTOR;
    if (s == "TOGGLESWITCH") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_TOGGLESWITCH;
    if (s == "USERDEFINED") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSystemFurnitureElementTypeEnum::ToString(IfcSystemFurnitureElementTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PANEL", "WORKSURFACE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum IfcSystemFurnitureElementTypeEnum::FromString(const std::string& s) {
    if (s == "PANEL") return ::Ifc4::IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementType_PANEL;
    if (s == "WORKSURFACE") return ::Ifc4::IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementType_WORKSURFACE;
    if (s == "USERDEFINED") return ::Ifc4::IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTankTypeEnum::ToString(IfcTankTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BASIN", "BREAKPRESSURE", "EXPANSION", "FEEDANDEXPANSION", "PRESSUREVESSEL", "STORAGE", "VESSEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTankTypeEnum::IfcTankTypeEnum IfcTankTypeEnum::FromString(const std::string& s) {
    if (s == "BASIN") return ::Ifc4::IfcTankTypeEnum::IfcTankType_BASIN;
    if (s == "BREAKPRESSURE") return ::Ifc4::IfcTankTypeEnum::IfcTankType_BREAKPRESSURE;
    if (s == "EXPANSION") return ::Ifc4::IfcTankTypeEnum::IfcTankType_EXPANSION;
    if (s == "FEEDANDEXPANSION") return ::Ifc4::IfcTankTypeEnum::IfcTankType_FEEDANDEXPANSION;
    if (s == "PRESSUREVESSEL") return ::Ifc4::IfcTankTypeEnum::IfcTankType_PRESSUREVESSEL;
    if (s == "STORAGE") return ::Ifc4::IfcTankTypeEnum::IfcTankType_STORAGE;
    if (s == "VESSEL") return ::Ifc4::IfcTankTypeEnum::IfcTankType_VESSEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcTankTypeEnum::IfcTankType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTankTypeEnum::IfcTankType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTaskDurationEnum::ToString(IfcTaskDurationEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELAPSEDTIME", "WORKTIME", "NOTDEFINED" };
    return names[v];
}

IfcTaskDurationEnum::IfcTaskDurationEnum IfcTaskDurationEnum::FromString(const std::string& s) {
    if (s == "ELAPSEDTIME") return ::Ifc4::IfcTaskDurationEnum::IfcTaskDuration_ELAPSEDTIME;
    if (s == "WORKTIME") return ::Ifc4::IfcTaskDurationEnum::IfcTaskDuration_WORKTIME;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTaskDurationEnum::IfcTaskDuration_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTaskTypeEnum::ToString(IfcTaskTypeEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ATTENDANCE", "CONSTRUCTION", "DEMOLITION", "DISMANTLE", "DISPOSAL", "INSTALLATION", "LOGISTIC", "MAINTENANCE", "MOVE", "OPERATION", "REMOVAL", "RENOVATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTaskTypeEnum::IfcTaskTypeEnum IfcTaskTypeEnum::FromString(const std::string& s) {
    if (s == "ATTENDANCE") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_ATTENDANCE;
    if (s == "CONSTRUCTION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_CONSTRUCTION;
    if (s == "DEMOLITION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_DEMOLITION;
    if (s == "DISMANTLE") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_DISMANTLE;
    if (s == "DISPOSAL") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_DISPOSAL;
    if (s == "INSTALLATION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_INSTALLATION;
    if (s == "LOGISTIC") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_LOGISTIC;
    if (s == "MAINTENANCE") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_MAINTENANCE;
    if (s == "MOVE") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_MOVE;
    if (s == "OPERATION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_OPERATION;
    if (s == "REMOVAL") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_REMOVAL;
    if (s == "RENOVATION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_RENOVATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTendonAnchorTypeEnum::ToString(IfcTendonAnchorTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COUPLER", "FIXED_END", "TENSIONING_END", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum IfcTendonAnchorTypeEnum::FromString(const std::string& s) {
    if (s == "COUPLER") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_COUPLER;
    if (s == "FIXED_END") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_FIXED_END;
    if (s == "TENSIONING_END") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_TENSIONING_END;
    if (s == "USERDEFINED") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTendonTypeEnum::ToString(IfcTendonTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BAR", "COATED", "STRAND", "WIRE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTendonTypeEnum::IfcTendonTypeEnum IfcTendonTypeEnum::FromString(const std::string& s) {
    if (s == "BAR") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_BAR;
    if (s == "COATED") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_COATED;
    if (s == "STRAND") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_STRAND;
    if (s == "WIRE") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_WIRE;
    if (s == "USERDEFINED") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTextPath::ToString(IfcTextPath v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LEFT", "RIGHT", "UP", "DOWN" };
    return names[v];
}

IfcTextPath::IfcTextPath IfcTextPath::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc4::IfcTextPath::IfcTextPath_LEFT;
    if (s == "RIGHT") return ::Ifc4::IfcTextPath::IfcTextPath_RIGHT;
    if (s == "UP") return ::Ifc4::IfcTextPath::IfcTextPath_UP;
    if (s == "DOWN") return ::Ifc4::IfcTextPath::IfcTextPath_DOWN;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTimeSeriesDataTypeEnum::ToString(IfcTimeSeriesDataTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONTINUOUS", "DISCRETE", "DISCRETEBINARY", "PIECEWISEBINARY", "PIECEWISECONSTANT", "PIECEWISECONTINUOUS", "NOTDEFINED" };
    return names[v];
}

IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum IfcTimeSeriesDataTypeEnum::FromString(const std::string& s) {
    if (s == "CONTINUOUS") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_CONTINUOUS;
    if (s == "DISCRETE") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_DISCRETE;
    if (s == "DISCRETEBINARY") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_DISCRETEBINARY;
    if (s == "PIECEWISEBINARY") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISEBINARY;
    if (s == "PIECEWISECONSTANT") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISECONSTANT;
    if (s == "PIECEWISECONTINUOUS") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISECONTINUOUS;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTransformerTypeEnum::ToString(IfcTransformerTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CURRENT", "FREQUENCY", "INVERTER", "RECTIFIER", "VOLTAGE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTransformerTypeEnum::IfcTransformerTypeEnum IfcTransformerTypeEnum::FromString(const std::string& s) {
    if (s == "CURRENT") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_CURRENT;
    if (s == "FREQUENCY") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_FREQUENCY;
    if (s == "INVERTER") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_INVERTER;
    if (s == "RECTIFIER") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_RECTIFIER;
    if (s == "VOLTAGE") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_VOLTAGE;
    if (s == "USERDEFINED") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTransitionCode::ToString(IfcTransitionCode v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DISCONTINUOUS", "CONTINUOUS", "CONTSAMEGRADIENT", "CONTSAMEGRADIENTSAMECURVATURE" };
    return names[v];
}

IfcTransitionCode::IfcTransitionCode IfcTransitionCode::FromString(const std::string& s) {
    if (s == "DISCONTINUOUS") return ::Ifc4::IfcTransitionCode::IfcTransitionCode_DISCONTINUOUS;
    if (s == "CONTINUOUS") return ::Ifc4::IfcTransitionCode::IfcTransitionCode_CONTINUOUS;
    if (s == "CONTSAMEGRADIENT") return ::Ifc4::IfcTransitionCode::IfcTransitionCode_CONTSAMEGRADIENT;
    if (s == "CONTSAMEGRADIENTSAMECURVATURE") return ::Ifc4::IfcTransitionCode::IfcTransitionCode_CONTSAMEGRADIENTSAMECURVATURE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTransportElementTypeEnum::ToString(IfcTransportElementTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELEVATOR", "ESCALATOR", "MOVINGWALKWAY", "CRANEWAY", "LIFTINGGEAR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTransportElementTypeEnum::IfcTransportElementTypeEnum IfcTransportElementTypeEnum::FromString(const std::string& s) {
    if (s == "ELEVATOR") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_ELEVATOR;
    if (s == "ESCALATOR") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_ESCALATOR;
    if (s == "MOVINGWALKWAY") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_MOVINGWALKWAY;
    if (s == "CRANEWAY") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_CRANEWAY;
    if (s == "LIFTINGGEAR") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_LIFTINGGEAR;
    if (s == "USERDEFINED") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTrimmingPreference::ToString(IfcTrimmingPreference v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CARTESIAN", "PARAMETER", "UNSPECIFIED" };
    return names[v];
}

IfcTrimmingPreference::IfcTrimmingPreference IfcTrimmingPreference::FromString(const std::string& s) {
    if (s == "CARTESIAN") return ::Ifc4::IfcTrimmingPreference::IfcTrimmingPreference_CARTESIAN;
    if (s == "PARAMETER") return ::Ifc4::IfcTrimmingPreference::IfcTrimmingPreference_PARAMETER;
    if (s == "UNSPECIFIED") return ::Ifc4::IfcTrimmingPreference::IfcTrimmingPreference_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTubeBundleTypeEnum::ToString(IfcTubeBundleTypeEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FINNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum IfcTubeBundleTypeEnum::FromString(const std::string& s) {
    if (s == "FINNED") return ::Ifc4::IfcTubeBundleTypeEnum::IfcTubeBundleType_FINNED;
    if (s == "USERDEFINED") return ::Ifc4::IfcTubeBundleTypeEnum::IfcTubeBundleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTubeBundleTypeEnum::IfcTubeBundleType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcUnitEnum::ToString(IfcUnitEnum v) {
    if ( v < 0 || v >= 30 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ABSORBEDDOSEUNIT", "AMOUNTOFSUBSTANCEUNIT", "AREAUNIT", "DOSEEQUIVALENTUNIT", "ELECTRICCAPACITANCEUNIT", "ELECTRICCHARGEUNIT", "ELECTRICCONDUCTANCEUNIT", "ELECTRICCURRENTUNIT", "ELECTRICRESISTANCEUNIT", "ELECTRICVOLTAGEUNIT", "ENERGYUNIT", "FORCEUNIT", "FREQUENCYUNIT", "ILLUMINANCEUNIT", "INDUCTANCEUNIT", "LENGTHUNIT", "LUMINOUSFLUXUNIT", "LUMINOUSINTENSITYUNIT", "MAGNETICFLUXDENSITYUNIT", "MAGNETICFLUXUNIT", "MASSUNIT", "PLANEANGLEUNIT", "POWERUNIT", "PRESSUREUNIT", "RADIOACTIVITYUNIT", "SOLIDANGLEUNIT", "THERMODYNAMICTEMPERATUREUNIT", "TIMEUNIT", "VOLUMEUNIT", "USERDEFINED" };
    return names[v];
}

IfcUnitEnum::IfcUnitEnum IfcUnitEnum::FromString(const std::string& s) {
    if (s == "ABSORBEDDOSEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ABSORBEDDOSEUNIT;
    if (s == "AMOUNTOFSUBSTANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_AMOUNTOFSUBSTANCEUNIT;
    if (s == "AREAUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_AREAUNIT;
    if (s == "DOSEEQUIVALENTUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_DOSEEQUIVALENTUNIT;
    if (s == "ELECTRICCAPACITANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICCAPACITANCEUNIT;
    if (s == "ELECTRICCHARGEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICCHARGEUNIT;
    if (s == "ELECTRICCONDUCTANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICCONDUCTANCEUNIT;
    if (s == "ELECTRICCURRENTUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICCURRENTUNIT;
    if (s == "ELECTRICRESISTANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICRESISTANCEUNIT;
    if (s == "ELECTRICVOLTAGEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICVOLTAGEUNIT;
    if (s == "ENERGYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ENERGYUNIT;
    if (s == "FORCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_FORCEUNIT;
    if (s == "FREQUENCYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_FREQUENCYUNIT;
    if (s == "ILLUMINANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ILLUMINANCEUNIT;
    if (s == "INDUCTANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_INDUCTANCEUNIT;
    if (s == "LENGTHUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_LENGTHUNIT;
    if (s == "LUMINOUSFLUXUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_LUMINOUSFLUXUNIT;
    if (s == "LUMINOUSINTENSITYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_LUMINOUSINTENSITYUNIT;
    if (s == "MAGNETICFLUXDENSITYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_MAGNETICFLUXDENSITYUNIT;
    if (s == "MAGNETICFLUXUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_MAGNETICFLUXUNIT;
    if (s == "MASSUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_MASSUNIT;
    if (s == "PLANEANGLEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_PLANEANGLEUNIT;
    if (s == "POWERUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_POWERUNIT;
    if (s == "PRESSUREUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_PRESSUREUNIT;
    if (s == "RADIOACTIVITYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_RADIOACTIVITYUNIT;
    if (s == "SOLIDANGLEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_SOLIDANGLEUNIT;
    if (s == "THERMODYNAMICTEMPERATUREUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_THERMODYNAMICTEMPERATUREUNIT;
    if (s == "TIMEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_TIMEUNIT;
    if (s == "VOLUMEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_VOLUMEUNIT;
    if (s == "USERDEFINED") return ::Ifc4::IfcUnitEnum::IfcUnit_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcUnitaryControlElementTypeEnum::ToString(IfcUnitaryControlElementTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALARMPANEL", "CONTROLPANEL", "GASDETECTIONPANEL", "INDICATORPANEL", "MIMICPANEL", "HUMIDISTAT", "THERMOSTAT", "WEATHERSTATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum IfcUnitaryControlElementTypeEnum::FromString(const std::string& s) {
    if (s == "ALARMPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_ALARMPANEL;
    if (s == "CONTROLPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_CONTROLPANEL;
    if (s == "GASDETECTIONPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_GASDETECTIONPANEL;
    if (s == "INDICATORPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_INDICATORPANEL;
    if (s == "MIMICPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_MIMICPANEL;
    if (s == "HUMIDISTAT") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_HUMIDISTAT;
    if (s == "THERMOSTAT") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_THERMOSTAT;
    if (s == "WEATHERSTATION") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_WEATHERSTATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcUnitaryEquipmentTypeEnum::ToString(IfcUnitaryEquipmentTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRHANDLER", "AIRCONDITIONINGUNIT", "DEHUMIDIFIER", "SPLITSYSTEM", "ROOFTOPUNIT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum IfcUnitaryEquipmentTypeEnum::FromString(const std::string& s) {
    if (s == "AIRHANDLER") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_AIRHANDLER;
    if (s == "AIRCONDITIONINGUNIT") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_AIRCONDITIONINGUNIT;
    if (s == "DEHUMIDIFIER") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_DEHUMIDIFIER;
    if (s == "SPLITSYSTEM") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_SPLITSYSTEM;
    if (s == "ROOFTOPUNIT") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_ROOFTOPUNIT;
    if (s == "USERDEFINED") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcValveTypeEnum::ToString(IfcValveTypeEnum v) {
    if ( v < 0 || v >= 23 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRRELEASE", "ANTIVACUUM", "CHANGEOVER", "CHECK", "COMMISSIONING", "DIVERTING", "DRAWOFFCOCK", "DOUBLECHECK", "DOUBLEREGULATING", "FAUCET", "FLUSHING", "GASCOCK", "GASTAP", "ISOLATING", "MIXING", "PRESSUREREDUCING", "PRESSURERELIEF", "REGULATING", "SAFETYCUTOFF", "STEAMTRAP", "STOPCOCK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcValveTypeEnum::IfcValveTypeEnum IfcValveTypeEnum::FromString(const std::string& s) {
    if (s == "AIRRELEASE") return ::Ifc4::IfcValveTypeEnum::IfcValveType_AIRRELEASE;
    if (s == "ANTIVACUUM") return ::Ifc4::IfcValveTypeEnum::IfcValveType_ANTIVACUUM;
    if (s == "CHANGEOVER") return ::Ifc4::IfcValveTypeEnum::IfcValveType_CHANGEOVER;
    if (s == "CHECK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_CHECK;
    if (s == "COMMISSIONING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_COMMISSIONING;
    if (s == "DIVERTING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_DIVERTING;
    if (s == "DRAWOFFCOCK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_DRAWOFFCOCK;
    if (s == "DOUBLECHECK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_DOUBLECHECK;
    if (s == "DOUBLEREGULATING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_DOUBLEREGULATING;
    if (s == "FAUCET") return ::Ifc4::IfcValveTypeEnum::IfcValveType_FAUCET;
    if (s == "FLUSHING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_FLUSHING;
    if (s == "GASCOCK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_GASCOCK;
    if (s == "GASTAP") return ::Ifc4::IfcValveTypeEnum::IfcValveType_GASTAP;
    if (s == "ISOLATING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_ISOLATING;
    if (s == "MIXING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_MIXING;
    if (s == "PRESSUREREDUCING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_PRESSUREREDUCING;
    if (s == "PRESSURERELIEF") return ::Ifc4::IfcValveTypeEnum::IfcValveType_PRESSURERELIEF;
    if (s == "REGULATING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_REGULATING;
    if (s == "SAFETYCUTOFF") return ::Ifc4::IfcValveTypeEnum::IfcValveType_SAFETYCUTOFF;
    if (s == "STEAMTRAP") return ::Ifc4::IfcValveTypeEnum::IfcValveType_STEAMTRAP;
    if (s == "STOPCOCK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_STOPCOCK;
    if (s == "USERDEFINED") return ::Ifc4::IfcValveTypeEnum::IfcValveType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcValveTypeEnum::IfcValveType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcVibrationIsolatorTypeEnum::ToString(IfcVibrationIsolatorTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPRESSION", "SPRING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum IfcVibrationIsolatorTypeEnum::FromString(const std::string& s) {
    if (s == "COMPRESSION") return ::Ifc4::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_COMPRESSION;
    if (s == "SPRING") return ::Ifc4::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_SPRING;
    if (s == "USERDEFINED") return ::Ifc4::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcVoidingFeatureTypeEnum::ToString(IfcVoidingFeatureTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CUTOUT", "NOTCH", "HOLE", "MITER", "CHAMFER", "EDGE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum IfcVoidingFeatureTypeEnum::FromString(const std::string& s) {
    if (s == "CUTOUT") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_CUTOUT;
    if (s == "NOTCH") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_NOTCH;
    if (s == "HOLE") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_HOLE;
    if (s == "MITER") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_MITER;
    if (s == "CHAMFER") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_CHAMFER;
    if (s == "EDGE") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_EDGE;
    if (s == "USERDEFINED") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWallTypeEnum::ToString(IfcWallTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MOVABLE", "PARAPET", "PARTITIONING", "PLUMBINGWALL", "SHEAR", "SOLIDWALL", "STANDARD", "POLYGONAL", "ELEMENTEDWALL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWallTypeEnum::IfcWallTypeEnum IfcWallTypeEnum::FromString(const std::string& s) {
    if (s == "MOVABLE") return ::Ifc4::IfcWallTypeEnum::IfcWallType_MOVABLE;
    if (s == "PARAPET") return ::Ifc4::IfcWallTypeEnum::IfcWallType_PARAPET;
    if (s == "PARTITIONING") return ::Ifc4::IfcWallTypeEnum::IfcWallType_PARTITIONING;
    if (s == "PLUMBINGWALL") return ::Ifc4::IfcWallTypeEnum::IfcWallType_PLUMBINGWALL;
    if (s == "SHEAR") return ::Ifc4::IfcWallTypeEnum::IfcWallType_SHEAR;
    if (s == "SOLIDWALL") return ::Ifc4::IfcWallTypeEnum::IfcWallType_SOLIDWALL;
    if (s == "STANDARD") return ::Ifc4::IfcWallTypeEnum::IfcWallType_STANDARD;
    if (s == "POLYGONAL") return ::Ifc4::IfcWallTypeEnum::IfcWallType_POLYGONAL;
    if (s == "ELEMENTEDWALL") return ::Ifc4::IfcWallTypeEnum::IfcWallType_ELEMENTEDWALL;
    if (s == "USERDEFINED") return ::Ifc4::IfcWallTypeEnum::IfcWallType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWallTypeEnum::IfcWallType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWasteTerminalTypeEnum::ToString(IfcWasteTerminalTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLOORTRAP", "FLOORWASTE", "GULLYSUMP", "GULLYTRAP", "ROOFDRAIN", "WASTEDISPOSALUNIT", "WASTETRAP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum IfcWasteTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "FLOORTRAP") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_FLOORTRAP;
    if (s == "FLOORWASTE") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_FLOORWASTE;
    if (s == "GULLYSUMP") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GULLYSUMP;
    if (s == "GULLYTRAP") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GULLYTRAP;
    if (s == "ROOFDRAIN") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_ROOFDRAIN;
    if (s == "WASTEDISPOSALUNIT") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_WASTEDISPOSALUNIT;
    if (s == "WASTETRAP") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_WASTETRAP;
    if (s == "USERDEFINED") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowPanelOperationEnum::ToString(IfcWindowPanelOperationEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SIDEHUNGRIGHTHAND", "SIDEHUNGLEFTHAND", "TILTANDTURNRIGHTHAND", "TILTANDTURNLEFTHAND", "TOPHUNG", "BOTTOMHUNG", "PIVOTHORIZONTAL", "PIVOTVERTICAL", "SLIDINGHORIZONTAL", "SLIDINGVERTICAL", "REMOVABLECASEMENT", "FIXEDCASEMENT", "OTHEROPERATION", "NOTDEFINED" };
    return names[v];
}

IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum IfcWindowPanelOperationEnum::FromString(const std::string& s) {
    if (s == "SIDEHUNGRIGHTHAND") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SIDEHUNGRIGHTHAND;
    if (s == "SIDEHUNGLEFTHAND") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SIDEHUNGLEFTHAND;
    if (s == "TILTANDTURNRIGHTHAND") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TILTANDTURNRIGHTHAND;
    if (s == "TILTANDTURNLEFTHAND") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TILTANDTURNLEFTHAND;
    if (s == "TOPHUNG") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TOPHUNG;
    if (s == "BOTTOMHUNG") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_BOTTOMHUNG;
    if (s == "PIVOTHORIZONTAL") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_PIVOTHORIZONTAL;
    if (s == "PIVOTVERTICAL") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_PIVOTVERTICAL;
    if (s == "SLIDINGHORIZONTAL") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SLIDINGHORIZONTAL;
    if (s == "SLIDINGVERTICAL") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SLIDINGVERTICAL;
    if (s == "REMOVABLECASEMENT") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_REMOVABLECASEMENT;
    if (s == "FIXEDCASEMENT") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_FIXEDCASEMENT;
    if (s == "OTHEROPERATION") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_OTHEROPERATION;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowPanelPositionEnum::ToString(IfcWindowPanelPositionEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LEFT", "MIDDLE", "RIGHT", "BOTTOM", "TOP", "NOTDEFINED" };
    return names[v];
}

IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum IfcWindowPanelPositionEnum::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_LEFT;
    if (s == "MIDDLE") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_MIDDLE;
    if (s == "RIGHT") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_RIGHT;
    if (s == "BOTTOM") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_BOTTOM;
    if (s == "TOP") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_TOP;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowStyleConstructionEnum::ToString(IfcWindowStyleConstructionEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALUMINIUM", "HIGH_GRADE_STEEL", "STEEL", "WOOD", "ALUMINIUM_WOOD", "PLASTIC", "OTHER_CONSTRUCTION", "NOTDEFINED" };
    return names[v];
}

IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum IfcWindowStyleConstructionEnum::FromString(const std::string& s) {
    if (s == "ALUMINIUM") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_ALUMINIUM;
    if (s == "HIGH_GRADE_STEEL") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_HIGH_GRADE_STEEL;
    if (s == "STEEL") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_STEEL;
    if (s == "WOOD") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_WOOD;
    if (s == "ALUMINIUM_WOOD") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_ALUMINIUM_WOOD;
    if (s == "PLASTIC") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_PLASTIC;
    if (s == "OTHER_CONSTRUCTION") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_OTHER_CONSTRUCTION;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowStyleOperationEnum::ToString(IfcWindowStyleOperationEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_PANEL", "DOUBLE_PANEL_VERTICAL", "DOUBLE_PANEL_HORIZONTAL", "TRIPLE_PANEL_VERTICAL", "TRIPLE_PANEL_BOTTOM", "TRIPLE_PANEL_TOP", "TRIPLE_PANEL_LEFT", "TRIPLE_PANEL_RIGHT", "TRIPLE_PANEL_HORIZONTAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum IfcWindowStyleOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_PANEL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_SINGLE_PANEL;
    if (s == "DOUBLE_PANEL_VERTICAL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_DOUBLE_PANEL_VERTICAL;
    if (s == "DOUBLE_PANEL_HORIZONTAL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_DOUBLE_PANEL_HORIZONTAL;
    if (s == "TRIPLE_PANEL_VERTICAL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_VERTICAL;
    if (s == "TRIPLE_PANEL_BOTTOM") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_BOTTOM;
    if (s == "TRIPLE_PANEL_TOP") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_TOP;
    if (s == "TRIPLE_PANEL_LEFT") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_LEFT;
    if (s == "TRIPLE_PANEL_RIGHT") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_RIGHT;
    if (s == "TRIPLE_PANEL_HORIZONTAL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_HORIZONTAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowTypeEnum::ToString(IfcWindowTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "WINDOW", "SKYLIGHT", "LIGHTDOME", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWindowTypeEnum::IfcWindowTypeEnum IfcWindowTypeEnum::FromString(const std::string& s) {
    if (s == "WINDOW") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_WINDOW;
    if (s == "SKYLIGHT") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_SKYLIGHT;
    if (s == "LIGHTDOME") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_LIGHTDOME;
    if (s == "USERDEFINED") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowTypePartitioningEnum::ToString(IfcWindowTypePartitioningEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_PANEL", "DOUBLE_PANEL_VERTICAL", "DOUBLE_PANEL_HORIZONTAL", "TRIPLE_PANEL_VERTICAL", "TRIPLE_PANEL_BOTTOM", "TRIPLE_PANEL_TOP", "TRIPLE_PANEL_LEFT", "TRIPLE_PANEL_RIGHT", "TRIPLE_PANEL_HORIZONTAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum IfcWindowTypePartitioningEnum::FromString(const std::string& s) {
    if (s == "SINGLE_PANEL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_SINGLE_PANEL;
    if (s == "DOUBLE_PANEL_VERTICAL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_DOUBLE_PANEL_VERTICAL;
    if (s == "DOUBLE_PANEL_HORIZONTAL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_DOUBLE_PANEL_HORIZONTAL;
    if (s == "TRIPLE_PANEL_VERTICAL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_VERTICAL;
    if (s == "TRIPLE_PANEL_BOTTOM") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_BOTTOM;
    if (s == "TRIPLE_PANEL_TOP") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_TOP;
    if (s == "TRIPLE_PANEL_LEFT") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_LEFT;
    if (s == "TRIPLE_PANEL_RIGHT") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_RIGHT;
    if (s == "TRIPLE_PANEL_HORIZONTAL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_HORIZONTAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWorkCalendarTypeEnum::ToString(IfcWorkCalendarTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FIRSTSHIFT", "SECONDSHIFT", "THIRDSHIFT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum IfcWorkCalendarTypeEnum::FromString(const std::string& s) {
    if (s == "FIRSTSHIFT") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_FIRSTSHIFT;
    if (s == "SECONDSHIFT") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_SECONDSHIFT;
    if (s == "THIRDSHIFT") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_THIRDSHIFT;
    if (s == "USERDEFINED") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWorkPlanTypeEnum::ToString(IfcWorkPlanTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACTUAL", "BASELINE", "PLANNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum IfcWorkPlanTypeEnum::FromString(const std::string& s) {
    if (s == "ACTUAL") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_ACTUAL;
    if (s == "BASELINE") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_BASELINE;
    if (s == "PLANNED") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_PLANNED;
    if (s == "USERDEFINED") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWorkScheduleTypeEnum::ToString(IfcWorkScheduleTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACTUAL", "BASELINE", "PLANNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum IfcWorkScheduleTypeEnum::FromString(const std::string& s) {
    if (s == "ACTUAL") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_ACTUAL;
    if (s == "BASELINE") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_BASELINE;
    if (s == "PLANNED") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_PLANNED;
    if (s == "USERDEFINED") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}


// Function implementations for IfcAbsorbedDoseMeasure
const IfcParse::type_declaration& IfcAbsorbedDoseMeasure::Class() { return *IfcAbsorbedDoseMeasure_type; }
const IfcParse::type_declaration& IfcAbsorbedDoseMeasure::declaration() const { return *IfcAbsorbedDoseMeasure_type; }
IfcAbsorbedDoseMeasure::IfcAbsorbedDoseMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcAbsorbedDoseMeasure::IfcAbsorbedDoseMeasure(double v) { data_ = new IfcEntityInstanceData(IfcAbsorbedDoseMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcAbsorbedDoseMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcAccelerationMeasure
const IfcParse::type_declaration& IfcAccelerationMeasure::Class() { return *IfcAccelerationMeasure_type; }
const IfcParse::type_declaration& IfcAccelerationMeasure::declaration() const { return *IfcAccelerationMeasure_type; }
IfcAccelerationMeasure::IfcAccelerationMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcAccelerationMeasure::IfcAccelerationMeasure(double v) { data_ = new IfcEntityInstanceData(IfcAccelerationMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcAccelerationMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcAmountOfSubstanceMeasure
const IfcParse::type_declaration& IfcAmountOfSubstanceMeasure::Class() { return *IfcAmountOfSubstanceMeasure_type; }
const IfcParse::type_declaration& IfcAmountOfSubstanceMeasure::declaration() const { return *IfcAmountOfSubstanceMeasure_type; }
IfcAmountOfSubstanceMeasure::IfcAmountOfSubstanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcAmountOfSubstanceMeasure::IfcAmountOfSubstanceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcAmountOfSubstanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcAmountOfSubstanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcAngularVelocityMeasure
const IfcParse::type_declaration& IfcAngularVelocityMeasure::Class() { return *IfcAngularVelocityMeasure_type; }
const IfcParse::type_declaration& IfcAngularVelocityMeasure::declaration() const { return *IfcAngularVelocityMeasure_type; }
IfcAngularVelocityMeasure::IfcAngularVelocityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcAngularVelocityMeasure::IfcAngularVelocityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcAngularVelocityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcAngularVelocityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcArcIndex
const IfcParse::type_declaration& IfcArcIndex::Class() { return *IfcArcIndex_type; }
const IfcParse::type_declaration& IfcArcIndex::declaration() const { return *IfcArcIndex_type; }
IfcArcIndex::IfcArcIndex(IfcEntityInstanceData* e) { data_ = e; }
IfcArcIndex::IfcArcIndex(std::vector< int > /*[3:3]*/ v) { data_ = new IfcEntityInstanceData(IfcArcIndex_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcArcIndex::operator std::vector< int > /*[3:3]*/() const { return *data_->getArgument(0); }

// Function implementations for IfcAreaDensityMeasure
const IfcParse::type_declaration& IfcAreaDensityMeasure::Class() { return *IfcAreaDensityMeasure_type; }
const IfcParse::type_declaration& IfcAreaDensityMeasure::declaration() const { return *IfcAreaDensityMeasure_type; }
IfcAreaDensityMeasure::IfcAreaDensityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcAreaDensityMeasure::IfcAreaDensityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcAreaDensityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcAreaDensityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcAreaMeasure
const IfcParse::type_declaration& IfcAreaMeasure::Class() { return *IfcAreaMeasure_type; }
const IfcParse::type_declaration& IfcAreaMeasure::declaration() const { return *IfcAreaMeasure_type; }
IfcAreaMeasure::IfcAreaMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcAreaMeasure::IfcAreaMeasure(double v) { data_ = new IfcEntityInstanceData(IfcAreaMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcAreaMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcBinary
const IfcParse::type_declaration& IfcBinary::Class() { return *IfcBinary_type; }
const IfcParse::type_declaration& IfcBinary::declaration() const { return *IfcBinary_type; }
IfcBinary::IfcBinary(IfcEntityInstanceData* e) { data_ = e; }
IfcBinary::IfcBinary(boost::dynamic_bitset<> v) { data_ = new IfcEntityInstanceData(IfcBinary_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcBinary::operator boost::dynamic_bitset<>() const { return *data_->getArgument(0); }

// Function implementations for IfcBoolean
const IfcParse::type_declaration& IfcBoolean::Class() { return *IfcBoolean_type; }
const IfcParse::type_declaration& IfcBoolean::declaration() const { return *IfcBoolean_type; }
IfcBoolean::IfcBoolean(IfcEntityInstanceData* e) { data_ = e; }
IfcBoolean::IfcBoolean(bool v) { data_ = new IfcEntityInstanceData(IfcBoolean_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcBoolean::operator bool() const { return *data_->getArgument(0); }

// Function implementations for IfcBoxAlignment
const IfcParse::type_declaration& IfcBoxAlignment::Class() { return *IfcBoxAlignment_type; }
const IfcParse::type_declaration& IfcBoxAlignment::declaration() const { return *IfcBoxAlignment_type; }
IfcBoxAlignment::IfcBoxAlignment(IfcEntityInstanceData* e) : IfcLabel((IfcEntityInstanceData*)0) { data_ = e; }
IfcBoxAlignment::IfcBoxAlignment(std::string v) : IfcLabel((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IfcBoxAlignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcBoxAlignment::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcCardinalPointReference
const IfcParse::type_declaration& IfcCardinalPointReference::Class() { return *IfcCardinalPointReference_type; }
const IfcParse::type_declaration& IfcCardinalPointReference::declaration() const { return *IfcCardinalPointReference_type; }
IfcCardinalPointReference::IfcCardinalPointReference(IfcEntityInstanceData* e) { data_ = e; }
IfcCardinalPointReference::IfcCardinalPointReference(int v) { data_ = new IfcEntityInstanceData(IfcCardinalPointReference_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcCardinalPointReference::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcComplexNumber
const IfcParse::type_declaration& IfcComplexNumber::Class() { return *IfcComplexNumber_type; }
const IfcParse::type_declaration& IfcComplexNumber::declaration() const { return *IfcComplexNumber_type; }
IfcComplexNumber::IfcComplexNumber(IfcEntityInstanceData* e) { data_ = e; }
IfcComplexNumber::IfcComplexNumber(std::vector< double > /*[1:2]*/ v) { data_ = new IfcEntityInstanceData(IfcComplexNumber_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcComplexNumber::operator std::vector< double > /*[1:2]*/() const { return *data_->getArgument(0); }

// Function implementations for IfcCompoundPlaneAngleMeasure
const IfcParse::type_declaration& IfcCompoundPlaneAngleMeasure::Class() { return *IfcCompoundPlaneAngleMeasure_type; }
const IfcParse::type_declaration& IfcCompoundPlaneAngleMeasure::declaration() const { return *IfcCompoundPlaneAngleMeasure_type; }
IfcCompoundPlaneAngleMeasure::IfcCompoundPlaneAngleMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcCompoundPlaneAngleMeasure::IfcCompoundPlaneAngleMeasure(std::vector< int > /*[3:4]*/ v) { data_ = new IfcEntityInstanceData(IfcCompoundPlaneAngleMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcCompoundPlaneAngleMeasure::operator std::vector< int > /*[3:4]*/() const { return *data_->getArgument(0); }

// Function implementations for IfcContextDependentMeasure
const IfcParse::type_declaration& IfcContextDependentMeasure::Class() { return *IfcContextDependentMeasure_type; }
const IfcParse::type_declaration& IfcContextDependentMeasure::declaration() const { return *IfcContextDependentMeasure_type; }
IfcContextDependentMeasure::IfcContextDependentMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcContextDependentMeasure::IfcContextDependentMeasure(double v) { data_ = new IfcEntityInstanceData(IfcContextDependentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcContextDependentMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcCountMeasure
const IfcParse::type_declaration& IfcCountMeasure::Class() { return *IfcCountMeasure_type; }
const IfcParse::type_declaration& IfcCountMeasure::declaration() const { return *IfcCountMeasure_type; }
IfcCountMeasure::IfcCountMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcCountMeasure::IfcCountMeasure(double v) { data_ = new IfcEntityInstanceData(IfcCountMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcCountMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcCurvatureMeasure
const IfcParse::type_declaration& IfcCurvatureMeasure::Class() { return *IfcCurvatureMeasure_type; }
const IfcParse::type_declaration& IfcCurvatureMeasure::declaration() const { return *IfcCurvatureMeasure_type; }
IfcCurvatureMeasure::IfcCurvatureMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcCurvatureMeasure::IfcCurvatureMeasure(double v) { data_ = new IfcEntityInstanceData(IfcCurvatureMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcCurvatureMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcDate
const IfcParse::type_declaration& IfcDate::Class() { return *IfcDate_type; }
const IfcParse::type_declaration& IfcDate::declaration() const { return *IfcDate_type; }
IfcDate::IfcDate(IfcEntityInstanceData* e) { data_ = e; }
IfcDate::IfcDate(std::string v) { data_ = new IfcEntityInstanceData(IfcDate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcDate::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcDateTime
const IfcParse::type_declaration& IfcDateTime::Class() { return *IfcDateTime_type; }
const IfcParse::type_declaration& IfcDateTime::declaration() const { return *IfcDateTime_type; }
IfcDateTime::IfcDateTime(IfcEntityInstanceData* e) { data_ = e; }
IfcDateTime::IfcDateTime(std::string v) { data_ = new IfcEntityInstanceData(IfcDateTime_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcDateTime::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcDayInMonthNumber
const IfcParse::type_declaration& IfcDayInMonthNumber::Class() { return *IfcDayInMonthNumber_type; }
const IfcParse::type_declaration& IfcDayInMonthNumber::declaration() const { return *IfcDayInMonthNumber_type; }
IfcDayInMonthNumber::IfcDayInMonthNumber(IfcEntityInstanceData* e) { data_ = e; }
IfcDayInMonthNumber::IfcDayInMonthNumber(int v) { data_ = new IfcEntityInstanceData(IfcDayInMonthNumber_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcDayInMonthNumber::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcDayInWeekNumber
const IfcParse::type_declaration& IfcDayInWeekNumber::Class() { return *IfcDayInWeekNumber_type; }
const IfcParse::type_declaration& IfcDayInWeekNumber::declaration() const { return *IfcDayInWeekNumber_type; }
IfcDayInWeekNumber::IfcDayInWeekNumber(IfcEntityInstanceData* e) { data_ = e; }
IfcDayInWeekNumber::IfcDayInWeekNumber(int v) { data_ = new IfcEntityInstanceData(IfcDayInWeekNumber_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcDayInWeekNumber::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcDescriptiveMeasure
const IfcParse::type_declaration& IfcDescriptiveMeasure::Class() { return *IfcDescriptiveMeasure_type; }
const IfcParse::type_declaration& IfcDescriptiveMeasure::declaration() const { return *IfcDescriptiveMeasure_type; }
IfcDescriptiveMeasure::IfcDescriptiveMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcDescriptiveMeasure::IfcDescriptiveMeasure(std::string v) { data_ = new IfcEntityInstanceData(IfcDescriptiveMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcDescriptiveMeasure::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcDimensionCount
const IfcParse::type_declaration& IfcDimensionCount::Class() { return *IfcDimensionCount_type; }
const IfcParse::type_declaration& IfcDimensionCount::declaration() const { return *IfcDimensionCount_type; }
IfcDimensionCount::IfcDimensionCount(IfcEntityInstanceData* e) { data_ = e; }
IfcDimensionCount::IfcDimensionCount(int v) { data_ = new IfcEntityInstanceData(IfcDimensionCount_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcDimensionCount::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcDoseEquivalentMeasure
const IfcParse::type_declaration& IfcDoseEquivalentMeasure::Class() { return *IfcDoseEquivalentMeasure_type; }
const IfcParse::type_declaration& IfcDoseEquivalentMeasure::declaration() const { return *IfcDoseEquivalentMeasure_type; }
IfcDoseEquivalentMeasure::IfcDoseEquivalentMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcDoseEquivalentMeasure::IfcDoseEquivalentMeasure(double v) { data_ = new IfcEntityInstanceData(IfcDoseEquivalentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcDoseEquivalentMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcDuration
const IfcParse::type_declaration& IfcDuration::Class() { return *IfcDuration_type; }
const IfcParse::type_declaration& IfcDuration::declaration() const { return *IfcDuration_type; }
IfcDuration::IfcDuration(IfcEntityInstanceData* e) { data_ = e; }
IfcDuration::IfcDuration(std::string v) { data_ = new IfcEntityInstanceData(IfcDuration_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcDuration::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcDynamicViscosityMeasure
const IfcParse::type_declaration& IfcDynamicViscosityMeasure::Class() { return *IfcDynamicViscosityMeasure_type; }
const IfcParse::type_declaration& IfcDynamicViscosityMeasure::declaration() const { return *IfcDynamicViscosityMeasure_type; }
IfcDynamicViscosityMeasure::IfcDynamicViscosityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcDynamicViscosityMeasure::IfcDynamicViscosityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcDynamicViscosityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcDynamicViscosityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricCapacitanceMeasure
const IfcParse::type_declaration& IfcElectricCapacitanceMeasure::Class() { return *IfcElectricCapacitanceMeasure_type; }
const IfcParse::type_declaration& IfcElectricCapacitanceMeasure::declaration() const { return *IfcElectricCapacitanceMeasure_type; }
IfcElectricCapacitanceMeasure::IfcElectricCapacitanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcElectricCapacitanceMeasure::IfcElectricCapacitanceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcElectricCapacitanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcElectricCapacitanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricChargeMeasure
const IfcParse::type_declaration& IfcElectricChargeMeasure::Class() { return *IfcElectricChargeMeasure_type; }
const IfcParse::type_declaration& IfcElectricChargeMeasure::declaration() const { return *IfcElectricChargeMeasure_type; }
IfcElectricChargeMeasure::IfcElectricChargeMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcElectricChargeMeasure::IfcElectricChargeMeasure(double v) { data_ = new IfcEntityInstanceData(IfcElectricChargeMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcElectricChargeMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricConductanceMeasure
const IfcParse::type_declaration& IfcElectricConductanceMeasure::Class() { return *IfcElectricConductanceMeasure_type; }
const IfcParse::type_declaration& IfcElectricConductanceMeasure::declaration() const { return *IfcElectricConductanceMeasure_type; }
IfcElectricConductanceMeasure::IfcElectricConductanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcElectricConductanceMeasure::IfcElectricConductanceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcElectricConductanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcElectricConductanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricCurrentMeasure
const IfcParse::type_declaration& IfcElectricCurrentMeasure::Class() { return *IfcElectricCurrentMeasure_type; }
const IfcParse::type_declaration& IfcElectricCurrentMeasure::declaration() const { return *IfcElectricCurrentMeasure_type; }
IfcElectricCurrentMeasure::IfcElectricCurrentMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcElectricCurrentMeasure::IfcElectricCurrentMeasure(double v) { data_ = new IfcEntityInstanceData(IfcElectricCurrentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcElectricCurrentMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricResistanceMeasure
const IfcParse::type_declaration& IfcElectricResistanceMeasure::Class() { return *IfcElectricResistanceMeasure_type; }
const IfcParse::type_declaration& IfcElectricResistanceMeasure::declaration() const { return *IfcElectricResistanceMeasure_type; }
IfcElectricResistanceMeasure::IfcElectricResistanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcElectricResistanceMeasure::IfcElectricResistanceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcElectricResistanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcElectricResistanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricVoltageMeasure
const IfcParse::type_declaration& IfcElectricVoltageMeasure::Class() { return *IfcElectricVoltageMeasure_type; }
const IfcParse::type_declaration& IfcElectricVoltageMeasure::declaration() const { return *IfcElectricVoltageMeasure_type; }
IfcElectricVoltageMeasure::IfcElectricVoltageMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcElectricVoltageMeasure::IfcElectricVoltageMeasure(double v) { data_ = new IfcEntityInstanceData(IfcElectricVoltageMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcElectricVoltageMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcEnergyMeasure
const IfcParse::type_declaration& IfcEnergyMeasure::Class() { return *IfcEnergyMeasure_type; }
const IfcParse::type_declaration& IfcEnergyMeasure::declaration() const { return *IfcEnergyMeasure_type; }
IfcEnergyMeasure::IfcEnergyMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcEnergyMeasure::IfcEnergyMeasure(double v) { data_ = new IfcEntityInstanceData(IfcEnergyMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcEnergyMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcFontStyle
const IfcParse::type_declaration& IfcFontStyle::Class() { return *IfcFontStyle_type; }
const IfcParse::type_declaration& IfcFontStyle::declaration() const { return *IfcFontStyle_type; }
IfcFontStyle::IfcFontStyle(IfcEntityInstanceData* e) { data_ = e; }
IfcFontStyle::IfcFontStyle(std::string v) { data_ = new IfcEntityInstanceData(IfcFontStyle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcFontStyle::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcFontVariant
const IfcParse::type_declaration& IfcFontVariant::Class() { return *IfcFontVariant_type; }
const IfcParse::type_declaration& IfcFontVariant::declaration() const { return *IfcFontVariant_type; }
IfcFontVariant::IfcFontVariant(IfcEntityInstanceData* e) { data_ = e; }
IfcFontVariant::IfcFontVariant(std::string v) { data_ = new IfcEntityInstanceData(IfcFontVariant_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcFontVariant::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcFontWeight
const IfcParse::type_declaration& IfcFontWeight::Class() { return *IfcFontWeight_type; }
const IfcParse::type_declaration& IfcFontWeight::declaration() const { return *IfcFontWeight_type; }
IfcFontWeight::IfcFontWeight(IfcEntityInstanceData* e) { data_ = e; }
IfcFontWeight::IfcFontWeight(std::string v) { data_ = new IfcEntityInstanceData(IfcFontWeight_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcFontWeight::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcForceMeasure
const IfcParse::type_declaration& IfcForceMeasure::Class() { return *IfcForceMeasure_type; }
const IfcParse::type_declaration& IfcForceMeasure::declaration() const { return *IfcForceMeasure_type; }
IfcForceMeasure::IfcForceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcForceMeasure::IfcForceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcForceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcForceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcFrequencyMeasure
const IfcParse::type_declaration& IfcFrequencyMeasure::Class() { return *IfcFrequencyMeasure_type; }
const IfcParse::type_declaration& IfcFrequencyMeasure::declaration() const { return *IfcFrequencyMeasure_type; }
IfcFrequencyMeasure::IfcFrequencyMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcFrequencyMeasure::IfcFrequencyMeasure(double v) { data_ = new IfcEntityInstanceData(IfcFrequencyMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcFrequencyMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcGloballyUniqueId
const IfcParse::type_declaration& IfcGloballyUniqueId::Class() { return *IfcGloballyUniqueId_type; }
const IfcParse::type_declaration& IfcGloballyUniqueId::declaration() const { return *IfcGloballyUniqueId_type; }
IfcGloballyUniqueId::IfcGloballyUniqueId(IfcEntityInstanceData* e) { data_ = e; }
IfcGloballyUniqueId::IfcGloballyUniqueId(std::string v) { data_ = new IfcEntityInstanceData(IfcGloballyUniqueId_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcGloballyUniqueId::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcHeatFluxDensityMeasure
const IfcParse::type_declaration& IfcHeatFluxDensityMeasure::Class() { return *IfcHeatFluxDensityMeasure_type; }
const IfcParse::type_declaration& IfcHeatFluxDensityMeasure::declaration() const { return *IfcHeatFluxDensityMeasure_type; }
IfcHeatFluxDensityMeasure::IfcHeatFluxDensityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcHeatFluxDensityMeasure::IfcHeatFluxDensityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcHeatFluxDensityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcHeatFluxDensityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcHeatingValueMeasure
const IfcParse::type_declaration& IfcHeatingValueMeasure::Class() { return *IfcHeatingValueMeasure_type; }
const IfcParse::type_declaration& IfcHeatingValueMeasure::declaration() const { return *IfcHeatingValueMeasure_type; }
IfcHeatingValueMeasure::IfcHeatingValueMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcHeatingValueMeasure::IfcHeatingValueMeasure(double v) { data_ = new IfcEntityInstanceData(IfcHeatingValueMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcHeatingValueMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcIdentifier
const IfcParse::type_declaration& IfcIdentifier::Class() { return *IfcIdentifier_type; }
const IfcParse::type_declaration& IfcIdentifier::declaration() const { return *IfcIdentifier_type; }
IfcIdentifier::IfcIdentifier(IfcEntityInstanceData* e) { data_ = e; }
IfcIdentifier::IfcIdentifier(std::string v) { data_ = new IfcEntityInstanceData(IfcIdentifier_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcIdentifier::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcIlluminanceMeasure
const IfcParse::type_declaration& IfcIlluminanceMeasure::Class() { return *IfcIlluminanceMeasure_type; }
const IfcParse::type_declaration& IfcIlluminanceMeasure::declaration() const { return *IfcIlluminanceMeasure_type; }
IfcIlluminanceMeasure::IfcIlluminanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcIlluminanceMeasure::IfcIlluminanceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcIlluminanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcIlluminanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcInductanceMeasure
const IfcParse::type_declaration& IfcInductanceMeasure::Class() { return *IfcInductanceMeasure_type; }
const IfcParse::type_declaration& IfcInductanceMeasure::declaration() const { return *IfcInductanceMeasure_type; }
IfcInductanceMeasure::IfcInductanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcInductanceMeasure::IfcInductanceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcInductanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcInductanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcInteger
const IfcParse::type_declaration& IfcInteger::Class() { return *IfcInteger_type; }
const IfcParse::type_declaration& IfcInteger::declaration() const { return *IfcInteger_type; }
IfcInteger::IfcInteger(IfcEntityInstanceData* e) { data_ = e; }
IfcInteger::IfcInteger(int v) { data_ = new IfcEntityInstanceData(IfcInteger_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcInteger::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcIntegerCountRateMeasure
const IfcParse::type_declaration& IfcIntegerCountRateMeasure::Class() { return *IfcIntegerCountRateMeasure_type; }
const IfcParse::type_declaration& IfcIntegerCountRateMeasure::declaration() const { return *IfcIntegerCountRateMeasure_type; }
IfcIntegerCountRateMeasure::IfcIntegerCountRateMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcIntegerCountRateMeasure::IfcIntegerCountRateMeasure(int v) { data_ = new IfcEntityInstanceData(IfcIntegerCountRateMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcIntegerCountRateMeasure::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcIonConcentrationMeasure
const IfcParse::type_declaration& IfcIonConcentrationMeasure::Class() { return *IfcIonConcentrationMeasure_type; }
const IfcParse::type_declaration& IfcIonConcentrationMeasure::declaration() const { return *IfcIonConcentrationMeasure_type; }
IfcIonConcentrationMeasure::IfcIonConcentrationMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcIonConcentrationMeasure::IfcIonConcentrationMeasure(double v) { data_ = new IfcEntityInstanceData(IfcIonConcentrationMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcIonConcentrationMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcIsothermalMoistureCapacityMeasure
const IfcParse::type_declaration& IfcIsothermalMoistureCapacityMeasure::Class() { return *IfcIsothermalMoistureCapacityMeasure_type; }
const IfcParse::type_declaration& IfcIsothermalMoistureCapacityMeasure::declaration() const { return *IfcIsothermalMoistureCapacityMeasure_type; }
IfcIsothermalMoistureCapacityMeasure::IfcIsothermalMoistureCapacityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcIsothermalMoistureCapacityMeasure::IfcIsothermalMoistureCapacityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcIsothermalMoistureCapacityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcIsothermalMoistureCapacityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcKinematicViscosityMeasure
const IfcParse::type_declaration& IfcKinematicViscosityMeasure::Class() { return *IfcKinematicViscosityMeasure_type; }
const IfcParse::type_declaration& IfcKinematicViscosityMeasure::declaration() const { return *IfcKinematicViscosityMeasure_type; }
IfcKinematicViscosityMeasure::IfcKinematicViscosityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcKinematicViscosityMeasure::IfcKinematicViscosityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcKinematicViscosityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcKinematicViscosityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLabel
const IfcParse::type_declaration& IfcLabel::Class() { return *IfcLabel_type; }
const IfcParse::type_declaration& IfcLabel::declaration() const { return *IfcLabel_type; }
IfcLabel::IfcLabel(IfcEntityInstanceData* e) { data_ = e; }
IfcLabel::IfcLabel(std::string v) { data_ = new IfcEntityInstanceData(IfcLabel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLabel::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcLanguageId
const IfcParse::type_declaration& IfcLanguageId::Class() { return *IfcLanguageId_type; }
const IfcParse::type_declaration& IfcLanguageId::declaration() const { return *IfcLanguageId_type; }
IfcLanguageId::IfcLanguageId(IfcEntityInstanceData* e) : IfcIdentifier((IfcEntityInstanceData*)0) { data_ = e; }
IfcLanguageId::IfcLanguageId(std::string v) : IfcIdentifier((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IfcLanguageId_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLanguageId::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcLengthMeasure
const IfcParse::type_declaration& IfcLengthMeasure::Class() { return *IfcLengthMeasure_type; }
const IfcParse::type_declaration& IfcLengthMeasure::declaration() const { return *IfcLengthMeasure_type; }
IfcLengthMeasure::IfcLengthMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcLengthMeasure::IfcLengthMeasure(double v) { data_ = new IfcEntityInstanceData(IfcLengthMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLengthMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLineIndex
const IfcParse::type_declaration& IfcLineIndex::Class() { return *IfcLineIndex_type; }
const IfcParse::type_declaration& IfcLineIndex::declaration() const { return *IfcLineIndex_type; }
IfcLineIndex::IfcLineIndex(IfcEntityInstanceData* e) { data_ = e; }
IfcLineIndex::IfcLineIndex(std::vector< int > /*[2:?]*/ v) { data_ = new IfcEntityInstanceData(IfcLineIndex_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLineIndex::operator std::vector< int > /*[2:?]*/() const { return *data_->getArgument(0); }

// Function implementations for IfcLinearForceMeasure
const IfcParse::type_declaration& IfcLinearForceMeasure::Class() { return *IfcLinearForceMeasure_type; }
const IfcParse::type_declaration& IfcLinearForceMeasure::declaration() const { return *IfcLinearForceMeasure_type; }
IfcLinearForceMeasure::IfcLinearForceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcLinearForceMeasure::IfcLinearForceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcLinearForceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLinearForceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLinearMomentMeasure
const IfcParse::type_declaration& IfcLinearMomentMeasure::Class() { return *IfcLinearMomentMeasure_type; }
const IfcParse::type_declaration& IfcLinearMomentMeasure::declaration() const { return *IfcLinearMomentMeasure_type; }
IfcLinearMomentMeasure::IfcLinearMomentMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcLinearMomentMeasure::IfcLinearMomentMeasure(double v) { data_ = new IfcEntityInstanceData(IfcLinearMomentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLinearMomentMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLinearStiffnessMeasure
const IfcParse::type_declaration& IfcLinearStiffnessMeasure::Class() { return *IfcLinearStiffnessMeasure_type; }
const IfcParse::type_declaration& IfcLinearStiffnessMeasure::declaration() const { return *IfcLinearStiffnessMeasure_type; }
IfcLinearStiffnessMeasure::IfcLinearStiffnessMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcLinearStiffnessMeasure::IfcLinearStiffnessMeasure(double v) { data_ = new IfcEntityInstanceData(IfcLinearStiffnessMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLinearStiffnessMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLinearVelocityMeasure
const IfcParse::type_declaration& IfcLinearVelocityMeasure::Class() { return *IfcLinearVelocityMeasure_type; }
const IfcParse::type_declaration& IfcLinearVelocityMeasure::declaration() const { return *IfcLinearVelocityMeasure_type; }
IfcLinearVelocityMeasure::IfcLinearVelocityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcLinearVelocityMeasure::IfcLinearVelocityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcLinearVelocityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLinearVelocityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLogical
const IfcParse::type_declaration& IfcLogical::Class() { return *IfcLogical_type; }
const IfcParse::type_declaration& IfcLogical::declaration() const { return *IfcLogical_type; }
IfcLogical::IfcLogical(IfcEntityInstanceData* e) { data_ = e; }
IfcLogical::IfcLogical(bool v) { data_ = new IfcEntityInstanceData(IfcLogical_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLogical::operator bool() const { return *data_->getArgument(0); }

// Function implementations for IfcLuminousFluxMeasure
const IfcParse::type_declaration& IfcLuminousFluxMeasure::Class() { return *IfcLuminousFluxMeasure_type; }
const IfcParse::type_declaration& IfcLuminousFluxMeasure::declaration() const { return *IfcLuminousFluxMeasure_type; }
IfcLuminousFluxMeasure::IfcLuminousFluxMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcLuminousFluxMeasure::IfcLuminousFluxMeasure(double v) { data_ = new IfcEntityInstanceData(IfcLuminousFluxMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLuminousFluxMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLuminousIntensityDistributionMeasure
const IfcParse::type_declaration& IfcLuminousIntensityDistributionMeasure::Class() { return *IfcLuminousIntensityDistributionMeasure_type; }
const IfcParse::type_declaration& IfcLuminousIntensityDistributionMeasure::declaration() const { return *IfcLuminousIntensityDistributionMeasure_type; }
IfcLuminousIntensityDistributionMeasure::IfcLuminousIntensityDistributionMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcLuminousIntensityDistributionMeasure::IfcLuminousIntensityDistributionMeasure(double v) { data_ = new IfcEntityInstanceData(IfcLuminousIntensityDistributionMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLuminousIntensityDistributionMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLuminousIntensityMeasure
const IfcParse::type_declaration& IfcLuminousIntensityMeasure::Class() { return *IfcLuminousIntensityMeasure_type; }
const IfcParse::type_declaration& IfcLuminousIntensityMeasure::declaration() const { return *IfcLuminousIntensityMeasure_type; }
IfcLuminousIntensityMeasure::IfcLuminousIntensityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcLuminousIntensityMeasure::IfcLuminousIntensityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcLuminousIntensityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcLuminousIntensityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMagneticFluxDensityMeasure
const IfcParse::type_declaration& IfcMagneticFluxDensityMeasure::Class() { return *IfcMagneticFluxDensityMeasure_type; }
const IfcParse::type_declaration& IfcMagneticFluxDensityMeasure::declaration() const { return *IfcMagneticFluxDensityMeasure_type; }
IfcMagneticFluxDensityMeasure::IfcMagneticFluxDensityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMagneticFluxDensityMeasure::IfcMagneticFluxDensityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMagneticFluxDensityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMagneticFluxDensityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMagneticFluxMeasure
const IfcParse::type_declaration& IfcMagneticFluxMeasure::Class() { return *IfcMagneticFluxMeasure_type; }
const IfcParse::type_declaration& IfcMagneticFluxMeasure::declaration() const { return *IfcMagneticFluxMeasure_type; }
IfcMagneticFluxMeasure::IfcMagneticFluxMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMagneticFluxMeasure::IfcMagneticFluxMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMagneticFluxMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMagneticFluxMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMassDensityMeasure
const IfcParse::type_declaration& IfcMassDensityMeasure::Class() { return *IfcMassDensityMeasure_type; }
const IfcParse::type_declaration& IfcMassDensityMeasure::declaration() const { return *IfcMassDensityMeasure_type; }
IfcMassDensityMeasure::IfcMassDensityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMassDensityMeasure::IfcMassDensityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMassDensityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMassDensityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMassFlowRateMeasure
const IfcParse::type_declaration& IfcMassFlowRateMeasure::Class() { return *IfcMassFlowRateMeasure_type; }
const IfcParse::type_declaration& IfcMassFlowRateMeasure::declaration() const { return *IfcMassFlowRateMeasure_type; }
IfcMassFlowRateMeasure::IfcMassFlowRateMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMassFlowRateMeasure::IfcMassFlowRateMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMassFlowRateMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMassFlowRateMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMassMeasure
const IfcParse::type_declaration& IfcMassMeasure::Class() { return *IfcMassMeasure_type; }
const IfcParse::type_declaration& IfcMassMeasure::declaration() const { return *IfcMassMeasure_type; }
IfcMassMeasure::IfcMassMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMassMeasure::IfcMassMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMassMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMassMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMassPerLengthMeasure
const IfcParse::type_declaration& IfcMassPerLengthMeasure::Class() { return *IfcMassPerLengthMeasure_type; }
const IfcParse::type_declaration& IfcMassPerLengthMeasure::declaration() const { return *IfcMassPerLengthMeasure_type; }
IfcMassPerLengthMeasure::IfcMassPerLengthMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMassPerLengthMeasure::IfcMassPerLengthMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMassPerLengthMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMassPerLengthMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcModulusOfElasticityMeasure
const IfcParse::type_declaration& IfcModulusOfElasticityMeasure::Class() { return *IfcModulusOfElasticityMeasure_type; }
const IfcParse::type_declaration& IfcModulusOfElasticityMeasure::declaration() const { return *IfcModulusOfElasticityMeasure_type; }
IfcModulusOfElasticityMeasure::IfcModulusOfElasticityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcModulusOfElasticityMeasure::IfcModulusOfElasticityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcModulusOfElasticityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcModulusOfElasticityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcModulusOfLinearSubgradeReactionMeasure
const IfcParse::type_declaration& IfcModulusOfLinearSubgradeReactionMeasure::Class() { return *IfcModulusOfLinearSubgradeReactionMeasure_type; }
const IfcParse::type_declaration& IfcModulusOfLinearSubgradeReactionMeasure::declaration() const { return *IfcModulusOfLinearSubgradeReactionMeasure_type; }
IfcModulusOfLinearSubgradeReactionMeasure::IfcModulusOfLinearSubgradeReactionMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcModulusOfLinearSubgradeReactionMeasure::IfcModulusOfLinearSubgradeReactionMeasure(double v) { data_ = new IfcEntityInstanceData(IfcModulusOfLinearSubgradeReactionMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcModulusOfLinearSubgradeReactionMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcModulusOfRotationalSubgradeReactionMeasure
const IfcParse::type_declaration& IfcModulusOfRotationalSubgradeReactionMeasure::Class() { return *IfcModulusOfRotationalSubgradeReactionMeasure_type; }
const IfcParse::type_declaration& IfcModulusOfRotationalSubgradeReactionMeasure::declaration() const { return *IfcModulusOfRotationalSubgradeReactionMeasure_type; }
IfcModulusOfRotationalSubgradeReactionMeasure::IfcModulusOfRotationalSubgradeReactionMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcModulusOfRotationalSubgradeReactionMeasure::IfcModulusOfRotationalSubgradeReactionMeasure(double v) { data_ = new IfcEntityInstanceData(IfcModulusOfRotationalSubgradeReactionMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcModulusOfRotationalSubgradeReactionMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcModulusOfSubgradeReactionMeasure
const IfcParse::type_declaration& IfcModulusOfSubgradeReactionMeasure::Class() { return *IfcModulusOfSubgradeReactionMeasure_type; }
const IfcParse::type_declaration& IfcModulusOfSubgradeReactionMeasure::declaration() const { return *IfcModulusOfSubgradeReactionMeasure_type; }
IfcModulusOfSubgradeReactionMeasure::IfcModulusOfSubgradeReactionMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcModulusOfSubgradeReactionMeasure::IfcModulusOfSubgradeReactionMeasure(double v) { data_ = new IfcEntityInstanceData(IfcModulusOfSubgradeReactionMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcModulusOfSubgradeReactionMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMoistureDiffusivityMeasure
const IfcParse::type_declaration& IfcMoistureDiffusivityMeasure::Class() { return *IfcMoistureDiffusivityMeasure_type; }
const IfcParse::type_declaration& IfcMoistureDiffusivityMeasure::declaration() const { return *IfcMoistureDiffusivityMeasure_type; }
IfcMoistureDiffusivityMeasure::IfcMoistureDiffusivityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMoistureDiffusivityMeasure::IfcMoistureDiffusivityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMoistureDiffusivityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMoistureDiffusivityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMolecularWeightMeasure
const IfcParse::type_declaration& IfcMolecularWeightMeasure::Class() { return *IfcMolecularWeightMeasure_type; }
const IfcParse::type_declaration& IfcMolecularWeightMeasure::declaration() const { return *IfcMolecularWeightMeasure_type; }
IfcMolecularWeightMeasure::IfcMolecularWeightMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMolecularWeightMeasure::IfcMolecularWeightMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMolecularWeightMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMolecularWeightMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMomentOfInertiaMeasure
const IfcParse::type_declaration& IfcMomentOfInertiaMeasure::Class() { return *IfcMomentOfInertiaMeasure_type; }
const IfcParse::type_declaration& IfcMomentOfInertiaMeasure::declaration() const { return *IfcMomentOfInertiaMeasure_type; }
IfcMomentOfInertiaMeasure::IfcMomentOfInertiaMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMomentOfInertiaMeasure::IfcMomentOfInertiaMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMomentOfInertiaMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMomentOfInertiaMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMonetaryMeasure
const IfcParse::type_declaration& IfcMonetaryMeasure::Class() { return *IfcMonetaryMeasure_type; }
const IfcParse::type_declaration& IfcMonetaryMeasure::declaration() const { return *IfcMonetaryMeasure_type; }
IfcMonetaryMeasure::IfcMonetaryMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcMonetaryMeasure::IfcMonetaryMeasure(double v) { data_ = new IfcEntityInstanceData(IfcMonetaryMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMonetaryMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMonthInYearNumber
const IfcParse::type_declaration& IfcMonthInYearNumber::Class() { return *IfcMonthInYearNumber_type; }
const IfcParse::type_declaration& IfcMonthInYearNumber::declaration() const { return *IfcMonthInYearNumber_type; }
IfcMonthInYearNumber::IfcMonthInYearNumber(IfcEntityInstanceData* e) { data_ = e; }
IfcMonthInYearNumber::IfcMonthInYearNumber(int v) { data_ = new IfcEntityInstanceData(IfcMonthInYearNumber_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcMonthInYearNumber::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcNonNegativeLengthMeasure
const IfcParse::type_declaration& IfcNonNegativeLengthMeasure::Class() { return *IfcNonNegativeLengthMeasure_type; }
const IfcParse::type_declaration& IfcNonNegativeLengthMeasure::declaration() const { return *IfcNonNegativeLengthMeasure_type; }
IfcNonNegativeLengthMeasure::IfcNonNegativeLengthMeasure(IfcEntityInstanceData* e) : IfcLengthMeasure((IfcEntityInstanceData*)0) { data_ = e; }
IfcNonNegativeLengthMeasure::IfcNonNegativeLengthMeasure(double v) : IfcLengthMeasure((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IfcNonNegativeLengthMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcNonNegativeLengthMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcNormalisedRatioMeasure
const IfcParse::type_declaration& IfcNormalisedRatioMeasure::Class() { return *IfcNormalisedRatioMeasure_type; }
const IfcParse::type_declaration& IfcNormalisedRatioMeasure::declaration() const { return *IfcNormalisedRatioMeasure_type; }
IfcNormalisedRatioMeasure::IfcNormalisedRatioMeasure(IfcEntityInstanceData* e) : IfcRatioMeasure((IfcEntityInstanceData*)0) { data_ = e; }
IfcNormalisedRatioMeasure::IfcNormalisedRatioMeasure(double v) : IfcRatioMeasure((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IfcNormalisedRatioMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcNormalisedRatioMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcNumericMeasure
const IfcParse::type_declaration& IfcNumericMeasure::Class() { return *IfcNumericMeasure_type; }
const IfcParse::type_declaration& IfcNumericMeasure::declaration() const { return *IfcNumericMeasure_type; }
IfcNumericMeasure::IfcNumericMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcNumericMeasure::IfcNumericMeasure(double v) { data_ = new IfcEntityInstanceData(IfcNumericMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcNumericMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPHMeasure
const IfcParse::type_declaration& IfcPHMeasure::Class() { return *IfcPHMeasure_type; }
const IfcParse::type_declaration& IfcPHMeasure::declaration() const { return *IfcPHMeasure_type; }
IfcPHMeasure::IfcPHMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcPHMeasure::IfcPHMeasure(double v) { data_ = new IfcEntityInstanceData(IfcPHMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPHMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcParameterValue
const IfcParse::type_declaration& IfcParameterValue::Class() { return *IfcParameterValue_type; }
const IfcParse::type_declaration& IfcParameterValue::declaration() const { return *IfcParameterValue_type; }
IfcParameterValue::IfcParameterValue(IfcEntityInstanceData* e) { data_ = e; }
IfcParameterValue::IfcParameterValue(double v) { data_ = new IfcEntityInstanceData(IfcParameterValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcParameterValue::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPlanarForceMeasure
const IfcParse::type_declaration& IfcPlanarForceMeasure::Class() { return *IfcPlanarForceMeasure_type; }
const IfcParse::type_declaration& IfcPlanarForceMeasure::declaration() const { return *IfcPlanarForceMeasure_type; }
IfcPlanarForceMeasure::IfcPlanarForceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcPlanarForceMeasure::IfcPlanarForceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcPlanarForceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPlanarForceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPlaneAngleMeasure
const IfcParse::type_declaration& IfcPlaneAngleMeasure::Class() { return *IfcPlaneAngleMeasure_type; }
const IfcParse::type_declaration& IfcPlaneAngleMeasure::declaration() const { return *IfcPlaneAngleMeasure_type; }
IfcPlaneAngleMeasure::IfcPlaneAngleMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcPlaneAngleMeasure::IfcPlaneAngleMeasure(double v) { data_ = new IfcEntityInstanceData(IfcPlaneAngleMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPlaneAngleMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPositiveInteger
const IfcParse::type_declaration& IfcPositiveInteger::Class() { return *IfcPositiveInteger_type; }
const IfcParse::type_declaration& IfcPositiveInteger::declaration() const { return *IfcPositiveInteger_type; }
IfcPositiveInteger::IfcPositiveInteger(IfcEntityInstanceData* e) : IfcInteger((IfcEntityInstanceData*)0) { data_ = e; }
IfcPositiveInteger::IfcPositiveInteger(int v) : IfcInteger((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IfcPositiveInteger_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPositiveInteger::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcPositiveLengthMeasure
const IfcParse::type_declaration& IfcPositiveLengthMeasure::Class() { return *IfcPositiveLengthMeasure_type; }
const IfcParse::type_declaration& IfcPositiveLengthMeasure::declaration() const { return *IfcPositiveLengthMeasure_type; }
IfcPositiveLengthMeasure::IfcPositiveLengthMeasure(IfcEntityInstanceData* e) : IfcLengthMeasure((IfcEntityInstanceData*)0) { data_ = e; }
IfcPositiveLengthMeasure::IfcPositiveLengthMeasure(double v) : IfcLengthMeasure((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IfcPositiveLengthMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPositiveLengthMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPositivePlaneAngleMeasure
const IfcParse::type_declaration& IfcPositivePlaneAngleMeasure::Class() { return *IfcPositivePlaneAngleMeasure_type; }
const IfcParse::type_declaration& IfcPositivePlaneAngleMeasure::declaration() const { return *IfcPositivePlaneAngleMeasure_type; }
IfcPositivePlaneAngleMeasure::IfcPositivePlaneAngleMeasure(IfcEntityInstanceData* e) : IfcPlaneAngleMeasure((IfcEntityInstanceData*)0) { data_ = e; }
IfcPositivePlaneAngleMeasure::IfcPositivePlaneAngleMeasure(double v) : IfcPlaneAngleMeasure((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IfcPositivePlaneAngleMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPositivePlaneAngleMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPositiveRatioMeasure
const IfcParse::type_declaration& IfcPositiveRatioMeasure::Class() { return *IfcPositiveRatioMeasure_type; }
const IfcParse::type_declaration& IfcPositiveRatioMeasure::declaration() const { return *IfcPositiveRatioMeasure_type; }
IfcPositiveRatioMeasure::IfcPositiveRatioMeasure(IfcEntityInstanceData* e) : IfcRatioMeasure((IfcEntityInstanceData*)0) { data_ = e; }
IfcPositiveRatioMeasure::IfcPositiveRatioMeasure(double v) : IfcRatioMeasure((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IfcPositiveRatioMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPositiveRatioMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPowerMeasure
const IfcParse::type_declaration& IfcPowerMeasure::Class() { return *IfcPowerMeasure_type; }
const IfcParse::type_declaration& IfcPowerMeasure::declaration() const { return *IfcPowerMeasure_type; }
IfcPowerMeasure::IfcPowerMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcPowerMeasure::IfcPowerMeasure(double v) { data_ = new IfcEntityInstanceData(IfcPowerMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPowerMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPresentableText
const IfcParse::type_declaration& IfcPresentableText::Class() { return *IfcPresentableText_type; }
const IfcParse::type_declaration& IfcPresentableText::declaration() const { return *IfcPresentableText_type; }
IfcPresentableText::IfcPresentableText(IfcEntityInstanceData* e) { data_ = e; }
IfcPresentableText::IfcPresentableText(std::string v) { data_ = new IfcEntityInstanceData(IfcPresentableText_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPresentableText::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcPressureMeasure
const IfcParse::type_declaration& IfcPressureMeasure::Class() { return *IfcPressureMeasure_type; }
const IfcParse::type_declaration& IfcPressureMeasure::declaration() const { return *IfcPressureMeasure_type; }
IfcPressureMeasure::IfcPressureMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcPressureMeasure::IfcPressureMeasure(double v) { data_ = new IfcEntityInstanceData(IfcPressureMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcPressureMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPropertySetDefinitionSet
const IfcParse::type_declaration& IfcPropertySetDefinitionSet::Class() { return *IfcPropertySetDefinitionSet_type; }
const IfcParse::type_declaration& IfcPropertySetDefinitionSet::declaration() const { return *IfcPropertySetDefinitionSet_type; }
IfcPropertySetDefinitionSet::IfcPropertySetDefinitionSet(IfcEntityInstanceData* e) { data_ = e; }
IfcPropertySetDefinitionSet::IfcPropertySetDefinitionSet(IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v) { data_ = new IfcEntityInstanceData(IfcPropertySetDefinitionSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v->generalize()); data_->setArgument(0, attr);} }
IfcPropertySetDefinitionSet::operator IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcPropertySetDefinition>(); }

// Function implementations for IfcRadioActivityMeasure
const IfcParse::type_declaration& IfcRadioActivityMeasure::Class() { return *IfcRadioActivityMeasure_type; }
const IfcParse::type_declaration& IfcRadioActivityMeasure::declaration() const { return *IfcRadioActivityMeasure_type; }
IfcRadioActivityMeasure::IfcRadioActivityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcRadioActivityMeasure::IfcRadioActivityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcRadioActivityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcRadioActivityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcRatioMeasure
const IfcParse::type_declaration& IfcRatioMeasure::Class() { return *IfcRatioMeasure_type; }
const IfcParse::type_declaration& IfcRatioMeasure::declaration() const { return *IfcRatioMeasure_type; }
IfcRatioMeasure::IfcRatioMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcRatioMeasure::IfcRatioMeasure(double v) { data_ = new IfcEntityInstanceData(IfcRatioMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcRatioMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcReal
const IfcParse::type_declaration& IfcReal::Class() { return *IfcReal_type; }
const IfcParse::type_declaration& IfcReal::declaration() const { return *IfcReal_type; }
IfcReal::IfcReal(IfcEntityInstanceData* e) { data_ = e; }
IfcReal::IfcReal(double v) { data_ = new IfcEntityInstanceData(IfcReal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcReal::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcRotationalFrequencyMeasure
const IfcParse::type_declaration& IfcRotationalFrequencyMeasure::Class() { return *IfcRotationalFrequencyMeasure_type; }
const IfcParse::type_declaration& IfcRotationalFrequencyMeasure::declaration() const { return *IfcRotationalFrequencyMeasure_type; }
IfcRotationalFrequencyMeasure::IfcRotationalFrequencyMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcRotationalFrequencyMeasure::IfcRotationalFrequencyMeasure(double v) { data_ = new IfcEntityInstanceData(IfcRotationalFrequencyMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcRotationalFrequencyMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcRotationalMassMeasure
const IfcParse::type_declaration& IfcRotationalMassMeasure::Class() { return *IfcRotationalMassMeasure_type; }
const IfcParse::type_declaration& IfcRotationalMassMeasure::declaration() const { return *IfcRotationalMassMeasure_type; }
IfcRotationalMassMeasure::IfcRotationalMassMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcRotationalMassMeasure::IfcRotationalMassMeasure(double v) { data_ = new IfcEntityInstanceData(IfcRotationalMassMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcRotationalMassMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcRotationalStiffnessMeasure
const IfcParse::type_declaration& IfcRotationalStiffnessMeasure::Class() { return *IfcRotationalStiffnessMeasure_type; }
const IfcParse::type_declaration& IfcRotationalStiffnessMeasure::declaration() const { return *IfcRotationalStiffnessMeasure_type; }
IfcRotationalStiffnessMeasure::IfcRotationalStiffnessMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcRotationalStiffnessMeasure::IfcRotationalStiffnessMeasure(double v) { data_ = new IfcEntityInstanceData(IfcRotationalStiffnessMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcRotationalStiffnessMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSectionModulusMeasure
const IfcParse::type_declaration& IfcSectionModulusMeasure::Class() { return *IfcSectionModulusMeasure_type; }
const IfcParse::type_declaration& IfcSectionModulusMeasure::declaration() const { return *IfcSectionModulusMeasure_type; }
IfcSectionModulusMeasure::IfcSectionModulusMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcSectionModulusMeasure::IfcSectionModulusMeasure(double v) { data_ = new IfcEntityInstanceData(IfcSectionModulusMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSectionModulusMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSectionalAreaIntegralMeasure
const IfcParse::type_declaration& IfcSectionalAreaIntegralMeasure::Class() { return *IfcSectionalAreaIntegralMeasure_type; }
const IfcParse::type_declaration& IfcSectionalAreaIntegralMeasure::declaration() const { return *IfcSectionalAreaIntegralMeasure_type; }
IfcSectionalAreaIntegralMeasure::IfcSectionalAreaIntegralMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcSectionalAreaIntegralMeasure::IfcSectionalAreaIntegralMeasure(double v) { data_ = new IfcEntityInstanceData(IfcSectionalAreaIntegralMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSectionalAreaIntegralMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcShearModulusMeasure
const IfcParse::type_declaration& IfcShearModulusMeasure::Class() { return *IfcShearModulusMeasure_type; }
const IfcParse::type_declaration& IfcShearModulusMeasure::declaration() const { return *IfcShearModulusMeasure_type; }
IfcShearModulusMeasure::IfcShearModulusMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcShearModulusMeasure::IfcShearModulusMeasure(double v) { data_ = new IfcEntityInstanceData(IfcShearModulusMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcShearModulusMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSolidAngleMeasure
const IfcParse::type_declaration& IfcSolidAngleMeasure::Class() { return *IfcSolidAngleMeasure_type; }
const IfcParse::type_declaration& IfcSolidAngleMeasure::declaration() const { return *IfcSolidAngleMeasure_type; }
IfcSolidAngleMeasure::IfcSolidAngleMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcSolidAngleMeasure::IfcSolidAngleMeasure(double v) { data_ = new IfcEntityInstanceData(IfcSolidAngleMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSolidAngleMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSoundPowerLevelMeasure
const IfcParse::type_declaration& IfcSoundPowerLevelMeasure::Class() { return *IfcSoundPowerLevelMeasure_type; }
const IfcParse::type_declaration& IfcSoundPowerLevelMeasure::declaration() const { return *IfcSoundPowerLevelMeasure_type; }
IfcSoundPowerLevelMeasure::IfcSoundPowerLevelMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcSoundPowerLevelMeasure::IfcSoundPowerLevelMeasure(double v) { data_ = new IfcEntityInstanceData(IfcSoundPowerLevelMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSoundPowerLevelMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSoundPowerMeasure
const IfcParse::type_declaration& IfcSoundPowerMeasure::Class() { return *IfcSoundPowerMeasure_type; }
const IfcParse::type_declaration& IfcSoundPowerMeasure::declaration() const { return *IfcSoundPowerMeasure_type; }
IfcSoundPowerMeasure::IfcSoundPowerMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcSoundPowerMeasure::IfcSoundPowerMeasure(double v) { data_ = new IfcEntityInstanceData(IfcSoundPowerMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSoundPowerMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSoundPressureLevelMeasure
const IfcParse::type_declaration& IfcSoundPressureLevelMeasure::Class() { return *IfcSoundPressureLevelMeasure_type; }
const IfcParse::type_declaration& IfcSoundPressureLevelMeasure::declaration() const { return *IfcSoundPressureLevelMeasure_type; }
IfcSoundPressureLevelMeasure::IfcSoundPressureLevelMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcSoundPressureLevelMeasure::IfcSoundPressureLevelMeasure(double v) { data_ = new IfcEntityInstanceData(IfcSoundPressureLevelMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSoundPressureLevelMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSoundPressureMeasure
const IfcParse::type_declaration& IfcSoundPressureMeasure::Class() { return *IfcSoundPressureMeasure_type; }
const IfcParse::type_declaration& IfcSoundPressureMeasure::declaration() const { return *IfcSoundPressureMeasure_type; }
IfcSoundPressureMeasure::IfcSoundPressureMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcSoundPressureMeasure::IfcSoundPressureMeasure(double v) { data_ = new IfcEntityInstanceData(IfcSoundPressureMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSoundPressureMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSpecificHeatCapacityMeasure
const IfcParse::type_declaration& IfcSpecificHeatCapacityMeasure::Class() { return *IfcSpecificHeatCapacityMeasure_type; }
const IfcParse::type_declaration& IfcSpecificHeatCapacityMeasure::declaration() const { return *IfcSpecificHeatCapacityMeasure_type; }
IfcSpecificHeatCapacityMeasure::IfcSpecificHeatCapacityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcSpecificHeatCapacityMeasure::IfcSpecificHeatCapacityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcSpecificHeatCapacityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSpecificHeatCapacityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSpecularExponent
const IfcParse::type_declaration& IfcSpecularExponent::Class() { return *IfcSpecularExponent_type; }
const IfcParse::type_declaration& IfcSpecularExponent::declaration() const { return *IfcSpecularExponent_type; }
IfcSpecularExponent::IfcSpecularExponent(IfcEntityInstanceData* e) { data_ = e; }
IfcSpecularExponent::IfcSpecularExponent(double v) { data_ = new IfcEntityInstanceData(IfcSpecularExponent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSpecularExponent::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSpecularRoughness
const IfcParse::type_declaration& IfcSpecularRoughness::Class() { return *IfcSpecularRoughness_type; }
const IfcParse::type_declaration& IfcSpecularRoughness::declaration() const { return *IfcSpecularRoughness_type; }
IfcSpecularRoughness::IfcSpecularRoughness(IfcEntityInstanceData* e) { data_ = e; }
IfcSpecularRoughness::IfcSpecularRoughness(double v) { data_ = new IfcEntityInstanceData(IfcSpecularRoughness_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcSpecularRoughness::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcStrippedOptional
const IfcParse::type_declaration& IfcStrippedOptional::Class() { return *IfcStrippedOptional_type; }
const IfcParse::type_declaration& IfcStrippedOptional::declaration() const { return *IfcStrippedOptional_type; }
IfcStrippedOptional::IfcStrippedOptional(IfcEntityInstanceData* e) { data_ = e; }
IfcStrippedOptional::IfcStrippedOptional(bool v) { data_ = new IfcEntityInstanceData(IfcStrippedOptional_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcStrippedOptional::operator bool() const { return *data_->getArgument(0); }

// Function implementations for IfcTemperatureGradientMeasure
const IfcParse::type_declaration& IfcTemperatureGradientMeasure::Class() { return *IfcTemperatureGradientMeasure_type; }
const IfcParse::type_declaration& IfcTemperatureGradientMeasure::declaration() const { return *IfcTemperatureGradientMeasure_type; }
IfcTemperatureGradientMeasure::IfcTemperatureGradientMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcTemperatureGradientMeasure::IfcTemperatureGradientMeasure(double v) { data_ = new IfcEntityInstanceData(IfcTemperatureGradientMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTemperatureGradientMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcTemperatureRateOfChangeMeasure
const IfcParse::type_declaration& IfcTemperatureRateOfChangeMeasure::Class() { return *IfcTemperatureRateOfChangeMeasure_type; }
const IfcParse::type_declaration& IfcTemperatureRateOfChangeMeasure::declaration() const { return *IfcTemperatureRateOfChangeMeasure_type; }
IfcTemperatureRateOfChangeMeasure::IfcTemperatureRateOfChangeMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcTemperatureRateOfChangeMeasure::IfcTemperatureRateOfChangeMeasure(double v) { data_ = new IfcEntityInstanceData(IfcTemperatureRateOfChangeMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTemperatureRateOfChangeMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcText
const IfcParse::type_declaration& IfcText::Class() { return *IfcText_type; }
const IfcParse::type_declaration& IfcText::declaration() const { return *IfcText_type; }
IfcText::IfcText(IfcEntityInstanceData* e) { data_ = e; }
IfcText::IfcText(std::string v) { data_ = new IfcEntityInstanceData(IfcText_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcText::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcTextAlignment
const IfcParse::type_declaration& IfcTextAlignment::Class() { return *IfcTextAlignment_type; }
const IfcParse::type_declaration& IfcTextAlignment::declaration() const { return *IfcTextAlignment_type; }
IfcTextAlignment::IfcTextAlignment(IfcEntityInstanceData* e) { data_ = e; }
IfcTextAlignment::IfcTextAlignment(std::string v) { data_ = new IfcEntityInstanceData(IfcTextAlignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTextAlignment::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcTextDecoration
const IfcParse::type_declaration& IfcTextDecoration::Class() { return *IfcTextDecoration_type; }
const IfcParse::type_declaration& IfcTextDecoration::declaration() const { return *IfcTextDecoration_type; }
IfcTextDecoration::IfcTextDecoration(IfcEntityInstanceData* e) { data_ = e; }
IfcTextDecoration::IfcTextDecoration(std::string v) { data_ = new IfcEntityInstanceData(IfcTextDecoration_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTextDecoration::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcTextFontName
const IfcParse::type_declaration& IfcTextFontName::Class() { return *IfcTextFontName_type; }
const IfcParse::type_declaration& IfcTextFontName::declaration() const { return *IfcTextFontName_type; }
IfcTextFontName::IfcTextFontName(IfcEntityInstanceData* e) { data_ = e; }
IfcTextFontName::IfcTextFontName(std::string v) { data_ = new IfcEntityInstanceData(IfcTextFontName_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTextFontName::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcTextTransformation
const IfcParse::type_declaration& IfcTextTransformation::Class() { return *IfcTextTransformation_type; }
const IfcParse::type_declaration& IfcTextTransformation::declaration() const { return *IfcTextTransformation_type; }
IfcTextTransformation::IfcTextTransformation(IfcEntityInstanceData* e) { data_ = e; }
IfcTextTransformation::IfcTextTransformation(std::string v) { data_ = new IfcEntityInstanceData(IfcTextTransformation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTextTransformation::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalAdmittanceMeasure
const IfcParse::type_declaration& IfcThermalAdmittanceMeasure::Class() { return *IfcThermalAdmittanceMeasure_type; }
const IfcParse::type_declaration& IfcThermalAdmittanceMeasure::declaration() const { return *IfcThermalAdmittanceMeasure_type; }
IfcThermalAdmittanceMeasure::IfcThermalAdmittanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcThermalAdmittanceMeasure::IfcThermalAdmittanceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcThermalAdmittanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcThermalAdmittanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalConductivityMeasure
const IfcParse::type_declaration& IfcThermalConductivityMeasure::Class() { return *IfcThermalConductivityMeasure_type; }
const IfcParse::type_declaration& IfcThermalConductivityMeasure::declaration() const { return *IfcThermalConductivityMeasure_type; }
IfcThermalConductivityMeasure::IfcThermalConductivityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcThermalConductivityMeasure::IfcThermalConductivityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcThermalConductivityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcThermalConductivityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalExpansionCoefficientMeasure
const IfcParse::type_declaration& IfcThermalExpansionCoefficientMeasure::Class() { return *IfcThermalExpansionCoefficientMeasure_type; }
const IfcParse::type_declaration& IfcThermalExpansionCoefficientMeasure::declaration() const { return *IfcThermalExpansionCoefficientMeasure_type; }
IfcThermalExpansionCoefficientMeasure::IfcThermalExpansionCoefficientMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcThermalExpansionCoefficientMeasure::IfcThermalExpansionCoefficientMeasure(double v) { data_ = new IfcEntityInstanceData(IfcThermalExpansionCoefficientMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcThermalExpansionCoefficientMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalResistanceMeasure
const IfcParse::type_declaration& IfcThermalResistanceMeasure::Class() { return *IfcThermalResistanceMeasure_type; }
const IfcParse::type_declaration& IfcThermalResistanceMeasure::declaration() const { return *IfcThermalResistanceMeasure_type; }
IfcThermalResistanceMeasure::IfcThermalResistanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcThermalResistanceMeasure::IfcThermalResistanceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcThermalResistanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcThermalResistanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalTransmittanceMeasure
const IfcParse::type_declaration& IfcThermalTransmittanceMeasure::Class() { return *IfcThermalTransmittanceMeasure_type; }
const IfcParse::type_declaration& IfcThermalTransmittanceMeasure::declaration() const { return *IfcThermalTransmittanceMeasure_type; }
IfcThermalTransmittanceMeasure::IfcThermalTransmittanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcThermalTransmittanceMeasure::IfcThermalTransmittanceMeasure(double v) { data_ = new IfcEntityInstanceData(IfcThermalTransmittanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcThermalTransmittanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermodynamicTemperatureMeasure
const IfcParse::type_declaration& IfcThermodynamicTemperatureMeasure::Class() { return *IfcThermodynamicTemperatureMeasure_type; }
const IfcParse::type_declaration& IfcThermodynamicTemperatureMeasure::declaration() const { return *IfcThermodynamicTemperatureMeasure_type; }
IfcThermodynamicTemperatureMeasure::IfcThermodynamicTemperatureMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcThermodynamicTemperatureMeasure::IfcThermodynamicTemperatureMeasure(double v) { data_ = new IfcEntityInstanceData(IfcThermodynamicTemperatureMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcThermodynamicTemperatureMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcTime
const IfcParse::type_declaration& IfcTime::Class() { return *IfcTime_type; }
const IfcParse::type_declaration& IfcTime::declaration() const { return *IfcTime_type; }
IfcTime::IfcTime(IfcEntityInstanceData* e) { data_ = e; }
IfcTime::IfcTime(std::string v) { data_ = new IfcEntityInstanceData(IfcTime_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTime::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcTimeMeasure
const IfcParse::type_declaration& IfcTimeMeasure::Class() { return *IfcTimeMeasure_type; }
const IfcParse::type_declaration& IfcTimeMeasure::declaration() const { return *IfcTimeMeasure_type; }
IfcTimeMeasure::IfcTimeMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcTimeMeasure::IfcTimeMeasure(double v) { data_ = new IfcEntityInstanceData(IfcTimeMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTimeMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcTimeStamp
const IfcParse::type_declaration& IfcTimeStamp::Class() { return *IfcTimeStamp_type; }
const IfcParse::type_declaration& IfcTimeStamp::declaration() const { return *IfcTimeStamp_type; }
IfcTimeStamp::IfcTimeStamp(IfcEntityInstanceData* e) { data_ = e; }
IfcTimeStamp::IfcTimeStamp(int v) { data_ = new IfcEntityInstanceData(IfcTimeStamp_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTimeStamp::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcTorqueMeasure
const IfcParse::type_declaration& IfcTorqueMeasure::Class() { return *IfcTorqueMeasure_type; }
const IfcParse::type_declaration& IfcTorqueMeasure::declaration() const { return *IfcTorqueMeasure_type; }
IfcTorqueMeasure::IfcTorqueMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcTorqueMeasure::IfcTorqueMeasure(double v) { data_ = new IfcEntityInstanceData(IfcTorqueMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcTorqueMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcURIReference
const IfcParse::type_declaration& IfcURIReference::Class() { return *IfcURIReference_type; }
const IfcParse::type_declaration& IfcURIReference::declaration() const { return *IfcURIReference_type; }
IfcURIReference::IfcURIReference(IfcEntityInstanceData* e) { data_ = e; }
IfcURIReference::IfcURIReference(std::string v) { data_ = new IfcEntityInstanceData(IfcURIReference_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcURIReference::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcVaporPermeabilityMeasure
const IfcParse::type_declaration& IfcVaporPermeabilityMeasure::Class() { return *IfcVaporPermeabilityMeasure_type; }
const IfcParse::type_declaration& IfcVaporPermeabilityMeasure::declaration() const { return *IfcVaporPermeabilityMeasure_type; }
IfcVaporPermeabilityMeasure::IfcVaporPermeabilityMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcVaporPermeabilityMeasure::IfcVaporPermeabilityMeasure(double v) { data_ = new IfcEntityInstanceData(IfcVaporPermeabilityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcVaporPermeabilityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcVolumeMeasure
const IfcParse::type_declaration& IfcVolumeMeasure::Class() { return *IfcVolumeMeasure_type; }
const IfcParse::type_declaration& IfcVolumeMeasure::declaration() const { return *IfcVolumeMeasure_type; }
IfcVolumeMeasure::IfcVolumeMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcVolumeMeasure::IfcVolumeMeasure(double v) { data_ = new IfcEntityInstanceData(IfcVolumeMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcVolumeMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcVolumetricFlowRateMeasure
const IfcParse::type_declaration& IfcVolumetricFlowRateMeasure::Class() { return *IfcVolumetricFlowRateMeasure_type; }
const IfcParse::type_declaration& IfcVolumetricFlowRateMeasure::declaration() const { return *IfcVolumetricFlowRateMeasure_type; }
IfcVolumetricFlowRateMeasure::IfcVolumetricFlowRateMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcVolumetricFlowRateMeasure::IfcVolumetricFlowRateMeasure(double v) { data_ = new IfcEntityInstanceData(IfcVolumetricFlowRateMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcVolumetricFlowRateMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcWarpingConstantMeasure
const IfcParse::type_declaration& IfcWarpingConstantMeasure::Class() { return *IfcWarpingConstantMeasure_type; }
const IfcParse::type_declaration& IfcWarpingConstantMeasure::declaration() const { return *IfcWarpingConstantMeasure_type; }
IfcWarpingConstantMeasure::IfcWarpingConstantMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcWarpingConstantMeasure::IfcWarpingConstantMeasure(double v) { data_ = new IfcEntityInstanceData(IfcWarpingConstantMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcWarpingConstantMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcWarpingMomentMeasure
const IfcParse::type_declaration& IfcWarpingMomentMeasure::Class() { return *IfcWarpingMomentMeasure_type; }
const IfcParse::type_declaration& IfcWarpingMomentMeasure::declaration() const { return *IfcWarpingMomentMeasure_type; }
IfcWarpingMomentMeasure::IfcWarpingMomentMeasure(IfcEntityInstanceData* e) { data_ = e; }
IfcWarpingMomentMeasure::IfcWarpingMomentMeasure(double v) { data_ = new IfcEntityInstanceData(IfcWarpingMomentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
IfcWarpingMomentMeasure::operator double() const { return *data_->getArgument(0); }


// Function implementations for IfcActionRequest
bool IfcActionRequest::hasPredefinedType() const { return !data_->getArgument(6)->isNull(); }
IfcActionRequestTypeEnum::IfcActionRequestTypeEnum IfcActionRequest::PredefinedType() const { return IfcActionRequestTypeEnum::FromString(*data_->getArgument(6)); }
void IfcActionRequest::setPredefinedType(IfcActionRequestTypeEnum::IfcActionRequestTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcActionRequestTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
bool IfcActionRequest::hasStatus() const { return !data_->getArgument(7)->isNull(); }
std::string IfcActionRequest::Status() const { return *data_->getArgument(7); }
void IfcActionRequest::setStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcActionRequest::hasLongDescription() const { return !data_->getArgument(8)->isNull(); }
std::string IfcActionRequest::LongDescription() const { return *data_->getArgument(8); }
void IfcActionRequest::setLongDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcActionRequest::declaration() const { return *IfcActionRequest_type; }
const IfcParse::entity& IfcActionRequest::Class() { return *IfcActionRequest_type; }
IfcActionRequest::IfcActionRequest(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcActionRequest_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcActionRequest::IfcActionRequest(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcActionRequestTypeEnum::IfcActionRequestTypeEnum > v7_PredefinedType, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_LongDescription) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcActionRequest_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_PredefinedType,IfcActionRequestTypeEnum::ToString(*v7_PredefinedType))));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Status));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_LongDescription));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcActor
IfcActorSelect* IfcActor::TheActor() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcActor::setTheActor(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

IfcRelAssignsToActor::list::ptr IfcActor::IsActingUpon() const { return data_->getInverse(IfcRelAssignsToActor_type, 6)->as<IfcRelAssignsToActor>(); }

const IfcParse::entity& IfcActor::declaration() const { return *IfcActor_type; }
const IfcParse::entity& IfcActor::Class() { return *IfcActor_type; }
IfcActor::IfcActor(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcActor_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcActor::IfcActor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_TheActor) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcActor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TheActor));data_->setArgument(5,attr);} }

// Function implementations for IfcActorRole
IfcRoleEnum::IfcRoleEnum IfcActorRole::Role() const { return IfcRoleEnum::FromString(*data_->getArgument(0)); }
void IfcActorRole::setRole(IfcRoleEnum::IfcRoleEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRoleEnum::ToString(v)));data_->setArgument(0,attr);} }
bool IfcActorRole::hasUserDefinedRole() const { return !data_->getArgument(1)->isNull(); }
std::string IfcActorRole::UserDefinedRole() const { return *data_->getArgument(1); }
void IfcActorRole::setUserDefinedRole(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcActorRole::hasDescription() const { return !data_->getArgument(2)->isNull(); }
std::string IfcActorRole::Description() const { return *data_->getArgument(2); }
void IfcActorRole::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcActorRole::HasExternalReference() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }

const IfcParse::entity& IfcActorRole::declaration() const { return *IfcActorRole_type; }
const IfcParse::entity& IfcActorRole::Class() { return *IfcActorRole_type; }
IfcActorRole::IfcActorRole(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcActorRole_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcActorRole::IfcActorRole(IfcRoleEnum::IfcRoleEnum v1_Role, boost::optional< std::string > v2_UserDefinedRole, boost::optional< std::string > v3_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcActorRole_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Role,IfcRoleEnum::ToString(v1_Role))));data_->setArgument(0,attr);} if (v2_UserDefinedRole) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_UserDefinedRole));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcActuator
bool IfcActuator::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcActuatorTypeEnum::IfcActuatorTypeEnum IfcActuator::PredefinedType() const { return IfcActuatorTypeEnum::FromString(*data_->getArgument(8)); }
void IfcActuator::setPredefinedType(IfcActuatorTypeEnum::IfcActuatorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcActuatorTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcActuator::declaration() const { return *IfcActuator_type; }
const IfcParse::entity& IfcActuator::Class() { return *IfcActuator_type; }
IfcActuator::IfcActuator(IfcEntityInstanceData* e) : IfcDistributionControlElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcActuator_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcActuator::IfcActuator(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcActuatorTypeEnum::IfcActuatorTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcActuator_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcActuatorTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcActuatorType
IfcActuatorTypeEnum::IfcActuatorTypeEnum IfcActuatorType::PredefinedType() const { return IfcActuatorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcActuatorType::setPredefinedType(IfcActuatorTypeEnum::IfcActuatorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcActuatorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcActuatorType::declaration() const { return *IfcActuatorType_type; }
const IfcParse::entity& IfcActuatorType::Class() { return *IfcActuatorType_type; }
IfcActuatorType::IfcActuatorType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcActuatorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcActuatorType::IfcActuatorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcActuatorTypeEnum::IfcActuatorTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcActuatorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcActuatorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAddress
bool IfcAddress::hasPurpose() const { return !data_->getArgument(0)->isNull(); }
IfcAddressTypeEnum::IfcAddressTypeEnum IfcAddress::Purpose() const { return IfcAddressTypeEnum::FromString(*data_->getArgument(0)); }
void IfcAddress::setPurpose(IfcAddressTypeEnum::IfcAddressTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAddressTypeEnum::ToString(v)));data_->setArgument(0,attr);} }
bool IfcAddress::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcAddress::Description() const { return *data_->getArgument(1); }
void IfcAddress::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcAddress::hasUserDefinedPurpose() const { return !data_->getArgument(2)->isNull(); }
std::string IfcAddress::UserDefinedPurpose() const { return *data_->getArgument(2); }
void IfcAddress::setUserDefinedPurpose(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

IfcPerson::list::ptr IfcAddress::OfPerson() const { return data_->getInverse(IfcPerson_type, 7)->as<IfcPerson>(); }
IfcOrganization::list::ptr IfcAddress::OfOrganization() const { return data_->getInverse(IfcOrganization_type, 4)->as<IfcOrganization>(); }

const IfcParse::entity& IfcAddress::declaration() const { return *IfcAddress_type; }
const IfcParse::entity& IfcAddress::Class() { return *IfcAddress_type; }
IfcAddress::IfcAddress(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcAddress_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAddress::IfcAddress(boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcAddress_type);  if (v1_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v1_Purpose,IfcAddressTypeEnum::ToString(*v1_Purpose))));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedPurpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedPurpose));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcAdvancedBrep


const IfcParse::entity& IfcAdvancedBrep::declaration() const { return *IfcAdvancedBrep_type; }
const IfcParse::entity& IfcAdvancedBrep::Class() { return *IfcAdvancedBrep_type; }
IfcAdvancedBrep::IfcAdvancedBrep(IfcEntityInstanceData* e) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAdvancedBrep_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAdvancedBrep::IfcAdvancedBrep(IfcClosedShell* v1_Outer) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAdvancedBrep_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));data_->setArgument(0,attr);} }

// Function implementations for IfcAdvancedBrepWithVoids
IfcTemplatedEntityList< IfcClosedShell >::ptr IfcAdvancedBrepWithVoids::Voids() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcClosedShell>(); }
void IfcAdvancedBrepWithVoids::setVoids(IfcTemplatedEntityList< IfcClosedShell >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& IfcAdvancedBrepWithVoids::declaration() const { return *IfcAdvancedBrepWithVoids_type; }
const IfcParse::entity& IfcAdvancedBrepWithVoids::Class() { return *IfcAdvancedBrepWithVoids_type; }
IfcAdvancedBrepWithVoids::IfcAdvancedBrepWithVoids(IfcEntityInstanceData* e) : IfcAdvancedBrep((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAdvancedBrepWithVoids_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAdvancedBrepWithVoids::IfcAdvancedBrepWithVoids(IfcClosedShell* v1_Outer, IfcTemplatedEntityList< IfcClosedShell >::ptr v2_Voids) : IfcAdvancedBrep((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAdvancedBrepWithVoids_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Voids)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcAdvancedFace


const IfcParse::entity& IfcAdvancedFace::declaration() const { return *IfcAdvancedFace_type; }
const IfcParse::entity& IfcAdvancedFace::Class() { return *IfcAdvancedFace_type; }
IfcAdvancedFace::IfcAdvancedFace(IfcEntityInstanceData* e) : IfcFaceSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAdvancedFace_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAdvancedFace::IfcAdvancedFace(IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds, IfcSurface* v2_FaceSurface, bool v3_SameSense) : IfcFaceSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAdvancedFace_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bounds)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FaceSurface));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SameSense));data_->setArgument(2,attr);} }

// Function implementations for IfcAirTerminal
bool IfcAirTerminal::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum IfcAirTerminal::PredefinedType() const { return IfcAirTerminalTypeEnum::FromString(*data_->getArgument(8)); }
void IfcAirTerminal::setPredefinedType(IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAirTerminalTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcAirTerminal::declaration() const { return *IfcAirTerminal_type; }
const IfcParse::entity& IfcAirTerminal::Class() { return *IfcAirTerminal_type; }
IfcAirTerminal::IfcAirTerminal(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAirTerminal_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAirTerminal::IfcAirTerminal(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAirTerminal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcAirTerminalTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcAirTerminalBox
bool IfcAirTerminalBox::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum IfcAirTerminalBox::PredefinedType() const { return IfcAirTerminalBoxTypeEnum::FromString(*data_->getArgument(8)); }
void IfcAirTerminalBox::setPredefinedType(IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAirTerminalBoxTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcAirTerminalBox::declaration() const { return *IfcAirTerminalBox_type; }
const IfcParse::entity& IfcAirTerminalBox::Class() { return *IfcAirTerminalBox_type; }
IfcAirTerminalBox::IfcAirTerminalBox(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAirTerminalBox_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAirTerminalBox::IfcAirTerminalBox(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum > v9_PredefinedType) : IfcFlowController((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAirTerminalBox_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcAirTerminalBoxTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcAirTerminalBoxType
IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum IfcAirTerminalBoxType::PredefinedType() const { return IfcAirTerminalBoxTypeEnum::FromString(*data_->getArgument(9)); }
void IfcAirTerminalBoxType::setPredefinedType(IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAirTerminalBoxTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcAirTerminalBoxType::declaration() const { return *IfcAirTerminalBoxType_type; }
const IfcParse::entity& IfcAirTerminalBoxType::Class() { return *IfcAirTerminalBoxType_type; }
IfcAirTerminalBoxType::IfcAirTerminalBoxType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAirTerminalBoxType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAirTerminalBoxType::IfcAirTerminalBoxType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAirTerminalBoxType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcAirTerminalBoxTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAirTerminalType
IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum IfcAirTerminalType::PredefinedType() const { return IfcAirTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void IfcAirTerminalType::setPredefinedType(IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAirTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcAirTerminalType::declaration() const { return *IfcAirTerminalType_type; }
const IfcParse::entity& IfcAirTerminalType::Class() { return *IfcAirTerminalType_type; }
IfcAirTerminalType::IfcAirTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAirTerminalType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAirTerminalType::IfcAirTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAirTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcAirTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAirToAirHeatRecovery
bool IfcAirToAirHeatRecovery::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum IfcAirToAirHeatRecovery::PredefinedType() const { return IfcAirToAirHeatRecoveryTypeEnum::FromString(*data_->getArgument(8)); }
void IfcAirToAirHeatRecovery::setPredefinedType(IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAirToAirHeatRecoveryTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcAirToAirHeatRecovery::declaration() const { return *IfcAirToAirHeatRecovery_type; }
const IfcParse::entity& IfcAirToAirHeatRecovery::Class() { return *IfcAirToAirHeatRecovery_type; }
IfcAirToAirHeatRecovery::IfcAirToAirHeatRecovery(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAirToAirHeatRecovery_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAirToAirHeatRecovery::IfcAirToAirHeatRecovery(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAirToAirHeatRecovery_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcAirToAirHeatRecoveryTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcAirToAirHeatRecoveryType
IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum IfcAirToAirHeatRecoveryType::PredefinedType() const { return IfcAirToAirHeatRecoveryTypeEnum::FromString(*data_->getArgument(9)); }
void IfcAirToAirHeatRecoveryType::setPredefinedType(IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAirToAirHeatRecoveryTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcAirToAirHeatRecoveryType::declaration() const { return *IfcAirToAirHeatRecoveryType_type; }
const IfcParse::entity& IfcAirToAirHeatRecoveryType::Class() { return *IfcAirToAirHeatRecoveryType_type; }
IfcAirToAirHeatRecoveryType::IfcAirToAirHeatRecoveryType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAirToAirHeatRecoveryType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAirToAirHeatRecoveryType::IfcAirToAirHeatRecoveryType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAirToAirHeatRecoveryType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcAirToAirHeatRecoveryTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAlarm
bool IfcAlarm::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcAlarmTypeEnum::IfcAlarmTypeEnum IfcAlarm::PredefinedType() const { return IfcAlarmTypeEnum::FromString(*data_->getArgument(8)); }
void IfcAlarm::setPredefinedType(IfcAlarmTypeEnum::IfcAlarmTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAlarmTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcAlarm::declaration() const { return *IfcAlarm_type; }
const IfcParse::entity& IfcAlarm::Class() { return *IfcAlarm_type; }
IfcAlarm::IfcAlarm(IfcEntityInstanceData* e) : IfcDistributionControlElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAlarm_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAlarm::IfcAlarm(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAlarmTypeEnum::IfcAlarmTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAlarm_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcAlarmTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcAlarmType
IfcAlarmTypeEnum::IfcAlarmTypeEnum IfcAlarmType::PredefinedType() const { return IfcAlarmTypeEnum::FromString(*data_->getArgument(9)); }
void IfcAlarmType::setPredefinedType(IfcAlarmTypeEnum::IfcAlarmTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAlarmTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcAlarmType::declaration() const { return *IfcAlarmType_type; }
const IfcParse::entity& IfcAlarmType::Class() { return *IfcAlarmType_type; }
IfcAlarmType::IfcAlarmType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAlarmType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAlarmType::IfcAlarmType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAlarmTypeEnum::IfcAlarmTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAlarmType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcAlarmTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAnnotation

IfcRelContainedInSpatialStructure::list::ptr IfcAnnotation::ContainedInStructure() const { return data_->getInverse(IfcRelContainedInSpatialStructure_type, 4)->as<IfcRelContainedInSpatialStructure>(); }

const IfcParse::entity& IfcAnnotation::declaration() const { return *IfcAnnotation_type; }
const IfcParse::entity& IfcAnnotation::Class() { return *IfcAnnotation_type; }
IfcAnnotation::IfcAnnotation(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAnnotation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAnnotation::IfcAnnotation(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAnnotation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcAnnotationFillArea
IfcCurve* IfcAnnotationFillArea::OuterBoundary() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcAnnotationFillArea::setOuterBoundary(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcAnnotationFillArea::hasInnerBoundaries() const { return !data_->getArgument(1)->isNull(); }
IfcTemplatedEntityList< IfcCurve >::ptr IfcAnnotationFillArea::InnerBoundaries() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcCurve>(); }
void IfcAnnotationFillArea::setInnerBoundaries(IfcTemplatedEntityList< IfcCurve >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& IfcAnnotationFillArea::declaration() const { return *IfcAnnotationFillArea_type; }
const IfcParse::entity& IfcAnnotationFillArea::Class() { return *IfcAnnotationFillArea_type; }
IfcAnnotationFillArea::IfcAnnotationFillArea(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAnnotationFillArea_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAnnotationFillArea::IfcAnnotationFillArea(IfcCurve* v1_OuterBoundary, boost::optional< IfcTemplatedEntityList< IfcCurve >::ptr > v2_InnerBoundaries) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAnnotationFillArea_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_OuterBoundary));data_->setArgument(0,attr);} if (v2_InnerBoundaries) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_InnerBoundaries)->generalize());data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcApplication
IfcOrganization* IfcApplication::ApplicationDeveloper() const { return (IfcOrganization*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcApplication::setApplicationDeveloper(IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::string IfcApplication::Version() const { return *data_->getArgument(1); }
void IfcApplication::setVersion(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
std::string IfcApplication::ApplicationFullName() const { return *data_->getArgument(2); }
void IfcApplication::setApplicationFullName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
std::string IfcApplication::ApplicationIdentifier() const { return *data_->getArgument(3); }
void IfcApplication::setApplicationIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcApplication::declaration() const { return *IfcApplication_type; }
const IfcParse::entity& IfcApplication::Class() { return *IfcApplication_type; }
IfcApplication::IfcApplication(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcApplication_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcApplication::IfcApplication(IfcOrganization* v1_ApplicationDeveloper, std::string v2_Version, std::string v3_ApplicationFullName, std::string v4_ApplicationIdentifier) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcApplication_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ApplicationDeveloper));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Version));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ApplicationFullName));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ApplicationIdentifier));data_->setArgument(3,attr);} }

// Function implementations for IfcAppliedValue
bool IfcAppliedValue::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcAppliedValue::Name() const { return *data_->getArgument(0); }
void IfcAppliedValue::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcAppliedValue::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcAppliedValue::Description() const { return *data_->getArgument(1); }
void IfcAppliedValue::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcAppliedValue::hasAppliedValue() const { return !data_->getArgument(2)->isNull(); }
IfcAppliedValueSelect* IfcAppliedValue::AppliedValue() const { return (IfcAppliedValueSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcAppliedValue::setAppliedValue(IfcAppliedValueSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcAppliedValue::hasUnitBasis() const { return !data_->getArgument(3)->isNull(); }
IfcMeasureWithUnit* IfcAppliedValue::UnitBasis() const { return (IfcMeasureWithUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcAppliedValue::setUnitBasis(IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcAppliedValue::hasApplicableDate() const { return !data_->getArgument(4)->isNull(); }
std::string IfcAppliedValue::ApplicableDate() const { return *data_->getArgument(4); }
void IfcAppliedValue::setApplicableDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcAppliedValue::hasFixedUntilDate() const { return !data_->getArgument(5)->isNull(); }
std::string IfcAppliedValue::FixedUntilDate() const { return *data_->getArgument(5); }
void IfcAppliedValue::setFixedUntilDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcAppliedValue::hasCategory() const { return !data_->getArgument(6)->isNull(); }
std::string IfcAppliedValue::Category() const { return *data_->getArgument(6); }
void IfcAppliedValue::setCategory(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcAppliedValue::hasCondition() const { return !data_->getArgument(7)->isNull(); }
std::string IfcAppliedValue::Condition() const { return *data_->getArgument(7); }
void IfcAppliedValue::setCondition(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcAppliedValue::hasArithmeticOperator() const { return !data_->getArgument(8)->isNull(); }
IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum IfcAppliedValue::ArithmeticOperator() const { return IfcArithmeticOperatorEnum::FromString(*data_->getArgument(8)); }
void IfcAppliedValue::setArithmeticOperator(IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcArithmeticOperatorEnum::ToString(v)));data_->setArgument(8,attr);} }
bool IfcAppliedValue::hasComponents() const { return !data_->getArgument(9)->isNull(); }
IfcTemplatedEntityList< IfcAppliedValue >::ptr IfcAppliedValue::Components() const { IfcEntityList::ptr es = *data_->getArgument(9); return es->as<IfcAppliedValue>(); }
void IfcAppliedValue::setComponents(IfcTemplatedEntityList< IfcAppliedValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(9,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcAppliedValue::HasExternalReference() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }

const IfcParse::entity& IfcAppliedValue::declaration() const { return *IfcAppliedValue_type; }
const IfcParse::entity& IfcAppliedValue::Class() { return *IfcAppliedValue_type; }
IfcAppliedValue::IfcAppliedValue(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcAppliedValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAppliedValue::IfcAppliedValue(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, boost::optional< std::string > v5_ApplicableDate, boost::optional< std::string > v6_FixedUntilDate, boost::optional< std::string > v7_Category, boost::optional< std::string > v8_Condition, boost::optional< IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum > v9_ArithmeticOperator, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_Components) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcAppliedValue_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AppliedValue));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_UnitBasis));data_->setArgument(3,attr);} if (v5_ApplicableDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableDate));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_FixedUntilDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_FixedUntilDate));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Category) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Category));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Condition) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Condition));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ArithmeticOperator) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_ArithmeticOperator,IfcArithmeticOperatorEnum::ToString(*v9_ArithmeticOperator))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Components) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Components)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcApproval
bool IfcApproval::hasIdentifier() const { return !data_->getArgument(0)->isNull(); }
std::string IfcApproval::Identifier() const { return *data_->getArgument(0); }
void IfcApproval::setIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcApproval::hasName() const { return !data_->getArgument(1)->isNull(); }
std::string IfcApproval::Name() const { return *data_->getArgument(1); }
void IfcApproval::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcApproval::hasDescription() const { return !data_->getArgument(2)->isNull(); }
std::string IfcApproval::Description() const { return *data_->getArgument(2); }
void IfcApproval::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcApproval::hasTimeOfApproval() const { return !data_->getArgument(3)->isNull(); }
std::string IfcApproval::TimeOfApproval() const { return *data_->getArgument(3); }
void IfcApproval::setTimeOfApproval(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcApproval::hasStatus() const { return !data_->getArgument(4)->isNull(); }
std::string IfcApproval::Status() const { return *data_->getArgument(4); }
void IfcApproval::setStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcApproval::hasLevel() const { return !data_->getArgument(5)->isNull(); }
std::string IfcApproval::Level() const { return *data_->getArgument(5); }
void IfcApproval::setLevel(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcApproval::hasQualifier() const { return !data_->getArgument(6)->isNull(); }
std::string IfcApproval::Qualifier() const { return *data_->getArgument(6); }
void IfcApproval::setQualifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcApproval::hasRequestingApproval() const { return !data_->getArgument(7)->isNull(); }
IfcActorSelect* IfcApproval::RequestingApproval() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcApproval::setRequestingApproval(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcApproval::hasGivingApproval() const { return !data_->getArgument(8)->isNull(); }
IfcActorSelect* IfcApproval::GivingApproval() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcApproval::setGivingApproval(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcApproval::HasExternalReferences() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }
IfcRelAssociatesApproval::list::ptr IfcApproval::ApprovedObjects() const { return data_->getInverse(IfcRelAssociatesApproval_type, 5)->as<IfcRelAssociatesApproval>(); }
IfcResourceApprovalRelationship::list::ptr IfcApproval::ApprovedResources() const { return data_->getInverse(IfcResourceApprovalRelationship_type, 3)->as<IfcResourceApprovalRelationship>(); }
IfcApprovalRelationship::list::ptr IfcApproval::IsRelatedWith() const { return data_->getInverse(IfcApprovalRelationship_type, 3)->as<IfcApprovalRelationship>(); }
IfcApprovalRelationship::list::ptr IfcApproval::Relates() const { return data_->getInverse(IfcApprovalRelationship_type, 2)->as<IfcApprovalRelationship>(); }

const IfcParse::entity& IfcApproval::declaration() const { return *IfcApproval_type; }
const IfcParse::entity& IfcApproval::Class() { return *IfcApproval_type; }
IfcApproval::IfcApproval(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcApproval_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcApproval::IfcApproval(boost::optional< std::string > v1_Identifier, boost::optional< std::string > v2_Name, boost::optional< std::string > v3_Description, boost::optional< std::string > v4_TimeOfApproval, boost::optional< std::string > v5_Status, boost::optional< std::string > v6_Level, boost::optional< std::string > v7_Qualifier, IfcActorSelect* v8_RequestingApproval, IfcActorSelect* v9_GivingApproval) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcApproval_type);  if (v1_Identifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Identifier));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Name));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_TimeOfApproval) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_TimeOfApproval));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Status));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Level) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Level));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Qualifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Qualifier));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RequestingApproval));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_GivingApproval));data_->setArgument(8,attr);} }

// Function implementations for IfcApprovalRelationship
IfcApproval* IfcApprovalRelationship::RelatingApproval() const { return (IfcApproval*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcApprovalRelationship::setRelatingApproval(IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcApproval >::ptr IfcApprovalRelationship::RelatedApprovals() const { IfcEntityList::ptr es = *data_->getArgument(3); return es->as<IfcApproval>(); }
void IfcApprovalRelationship::setRelatedApprovals(IfcTemplatedEntityList< IfcApproval >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(3,attr);} }


const IfcParse::entity& IfcApprovalRelationship::declaration() const { return *IfcApprovalRelationship_type; }
const IfcParse::entity& IfcApprovalRelationship::Class() { return *IfcApprovalRelationship_type; }
IfcApprovalRelationship::IfcApprovalRelationship(IfcEntityInstanceData* e) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcApprovalRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcApprovalRelationship::IfcApprovalRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcApproval* v3_RelatingApproval, IfcTemplatedEntityList< IfcApproval >::ptr v4_RelatedApprovals) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcApprovalRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingApproval));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedApprovals)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcArbitraryClosedProfileDef
IfcCurve* IfcArbitraryClosedProfileDef::OuterCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcArbitraryClosedProfileDef::setOuterCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcArbitraryClosedProfileDef::declaration() const { return *IfcArbitraryClosedProfileDef_type; }
const IfcParse::entity& IfcArbitraryClosedProfileDef::Class() { return *IfcArbitraryClosedProfileDef_type; }
IfcArbitraryClosedProfileDef::IfcArbitraryClosedProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcArbitraryClosedProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcArbitraryClosedProfileDef::IfcArbitraryClosedProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcCurve* v3_OuterCurve) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcArbitraryClosedProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_OuterCurve));data_->setArgument(2,attr);} }

// Function implementations for IfcArbitraryOpenProfileDef
IfcBoundedCurve* IfcArbitraryOpenProfileDef::Curve() const { return (IfcBoundedCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcArbitraryOpenProfileDef::setCurve(IfcBoundedCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcArbitraryOpenProfileDef::declaration() const { return *IfcArbitraryOpenProfileDef_type; }
const IfcParse::entity& IfcArbitraryOpenProfileDef::Class() { return *IfcArbitraryOpenProfileDef_type; }
IfcArbitraryOpenProfileDef::IfcArbitraryOpenProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcArbitraryOpenProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcArbitraryOpenProfileDef::IfcArbitraryOpenProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcBoundedCurve* v3_Curve) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcArbitraryOpenProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Curve));data_->setArgument(2,attr);} }

// Function implementations for IfcArbitraryProfileDefWithVoids
IfcTemplatedEntityList< IfcCurve >::ptr IfcArbitraryProfileDefWithVoids::InnerCurves() const { IfcEntityList::ptr es = *data_->getArgument(3); return es->as<IfcCurve>(); }
void IfcArbitraryProfileDefWithVoids::setInnerCurves(IfcTemplatedEntityList< IfcCurve >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(3,attr);} }


const IfcParse::entity& IfcArbitraryProfileDefWithVoids::declaration() const { return *IfcArbitraryProfileDefWithVoids_type; }
const IfcParse::entity& IfcArbitraryProfileDefWithVoids::Class() { return *IfcArbitraryProfileDefWithVoids_type; }
IfcArbitraryProfileDefWithVoids::IfcArbitraryProfileDefWithVoids(IfcEntityInstanceData* e) : IfcArbitraryClosedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcArbitraryProfileDefWithVoids_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcArbitraryProfileDefWithVoids::IfcArbitraryProfileDefWithVoids(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcCurve* v3_OuterCurve, IfcTemplatedEntityList< IfcCurve >::ptr v4_InnerCurves) : IfcArbitraryClosedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcArbitraryProfileDefWithVoids_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_OuterCurve));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_InnerCurves)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcAsset
bool IfcAsset::hasIdentification() const { return !data_->getArgument(5)->isNull(); }
std::string IfcAsset::Identification() const { return *data_->getArgument(5); }
void IfcAsset::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcAsset::hasOriginalValue() const { return !data_->getArgument(6)->isNull(); }
IfcCostValue* IfcAsset::OriginalValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcAsset::setOriginalValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcAsset::hasCurrentValue() const { return !data_->getArgument(7)->isNull(); }
IfcCostValue* IfcAsset::CurrentValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcAsset::setCurrentValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcAsset::hasTotalReplacementCost() const { return !data_->getArgument(8)->isNull(); }
IfcCostValue* IfcAsset::TotalReplacementCost() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcAsset::setTotalReplacementCost(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcAsset::hasOwner() const { return !data_->getArgument(9)->isNull(); }
IfcActorSelect* IfcAsset::Owner() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcAsset::setOwner(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcAsset::hasUser() const { return !data_->getArgument(10)->isNull(); }
IfcActorSelect* IfcAsset::User() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(10))); }
void IfcAsset::setUser(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcAsset::hasResponsiblePerson() const { return !data_->getArgument(11)->isNull(); }
IfcPerson* IfcAsset::ResponsiblePerson() const { return (IfcPerson*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(11))); }
void IfcAsset::setResponsiblePerson(IfcPerson* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcAsset::hasIncorporationDate() const { return !data_->getArgument(12)->isNull(); }
std::string IfcAsset::IncorporationDate() const { return *data_->getArgument(12); }
void IfcAsset::setIncorporationDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcAsset::hasDepreciatedValue() const { return !data_->getArgument(13)->isNull(); }
IfcCostValue* IfcAsset::DepreciatedValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(13))); }
void IfcAsset::setDepreciatedValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }


const IfcParse::entity& IfcAsset::declaration() const { return *IfcAsset_type; }
const IfcParse::entity& IfcAsset::Class() { return *IfcAsset_type; }
IfcAsset::IfcAsset(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAsset_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAsset::IfcAsset(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, IfcCostValue* v7_OriginalValue, IfcCostValue* v8_CurrentValue, IfcCostValue* v9_TotalReplacementCost, IfcActorSelect* v10_Owner, IfcActorSelect* v11_User, IfcPerson* v12_ResponsiblePerson, boost::optional< std::string > v13_IncorporationDate, IfcCostValue* v14_DepreciatedValue) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAsset_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_OriginalValue));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_CurrentValue));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_TotalReplacementCost));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_Owner));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_User));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_ResponsiblePerson));data_->setArgument(11,attr);} if (v13_IncorporationDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_IncorporationDate));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_DepreciatedValue));data_->setArgument(13,attr);} }

// Function implementations for IfcAsymmetricIShapeProfileDef
double IfcAsymmetricIShapeProfileDef::BottomFlangeWidth() const { return *data_->getArgument(3); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcAsymmetricIShapeProfileDef::OverallDepth() const { return *data_->getArgument(4); }
void IfcAsymmetricIShapeProfileDef::setOverallDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double IfcAsymmetricIShapeProfileDef::WebThickness() const { return *data_->getArgument(5); }
void IfcAsymmetricIShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double IfcAsymmetricIShapeProfileDef::BottomFlangeThickness() const { return *data_->getArgument(6); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasBottomFlangeFilletRadius() const { return !data_->getArgument(7)->isNull(); }
double IfcAsymmetricIShapeProfileDef::BottomFlangeFilletRadius() const { return *data_->getArgument(7); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
double IfcAsymmetricIShapeProfileDef::TopFlangeWidth() const { return *data_->getArgument(8); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeThickness() const { return !data_->getArgument(9)->isNull(); }
double IfcAsymmetricIShapeProfileDef::TopFlangeThickness() const { return *data_->getArgument(9); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeFilletRadius() const { return !data_->getArgument(10)->isNull(); }
double IfcAsymmetricIShapeProfileDef::TopFlangeFilletRadius() const { return *data_->getArgument(10); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasBottomFlangeEdgeRadius() const { return !data_->getArgument(11)->isNull(); }
double IfcAsymmetricIShapeProfileDef::BottomFlangeEdgeRadius() const { return *data_->getArgument(11); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasBottomFlangeSlope() const { return !data_->getArgument(12)->isNull(); }
double IfcAsymmetricIShapeProfileDef::BottomFlangeSlope() const { return *data_->getArgument(12); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeEdgeRadius() const { return !data_->getArgument(13)->isNull(); }
double IfcAsymmetricIShapeProfileDef::TopFlangeEdgeRadius() const { return *data_->getArgument(13); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeSlope() const { return !data_->getArgument(14)->isNull(); }
double IfcAsymmetricIShapeProfileDef::TopFlangeSlope() const { return *data_->getArgument(14); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }


const IfcParse::entity& IfcAsymmetricIShapeProfileDef::declaration() const { return *IfcAsymmetricIShapeProfileDef_type; }
const IfcParse::entity& IfcAsymmetricIShapeProfileDef::Class() { return *IfcAsymmetricIShapeProfileDef_type; }
IfcAsymmetricIShapeProfileDef::IfcAsymmetricIShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAsymmetricIShapeProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAsymmetricIShapeProfileDef::IfcAsymmetricIShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_BottomFlangeWidth, double v5_OverallDepth, double v6_WebThickness, double v7_BottomFlangeThickness, boost::optional< double > v8_BottomFlangeFilletRadius, double v9_TopFlangeWidth, boost::optional< double > v10_TopFlangeThickness, boost::optional< double > v11_TopFlangeFilletRadius, boost::optional< double > v12_BottomFlangeEdgeRadius, boost::optional< double > v13_BottomFlangeSlope, boost::optional< double > v14_TopFlangeEdgeRadius, boost::optional< double > v15_TopFlangeSlope) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAsymmetricIShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_BottomFlangeWidth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_OverallDepth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_BottomFlangeThickness));data_->setArgument(6,attr);} if (v8_BottomFlangeFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_BottomFlangeFilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_TopFlangeWidth));data_->setArgument(8,attr);} if (v10_TopFlangeThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_TopFlangeThickness));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_TopFlangeFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TopFlangeFilletRadius));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_BottomFlangeEdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_BottomFlangeEdgeRadius));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_BottomFlangeSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_BottomFlangeSlope));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_TopFlangeEdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_TopFlangeEdgeRadius));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_TopFlangeSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_TopFlangeSlope));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } }

// Function implementations for IfcAudioVisualAppliance
bool IfcAudioVisualAppliance::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum IfcAudioVisualAppliance::PredefinedType() const { return IfcAudioVisualApplianceTypeEnum::FromString(*data_->getArgument(8)); }
void IfcAudioVisualAppliance::setPredefinedType(IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAudioVisualApplianceTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcAudioVisualAppliance::declaration() const { return *IfcAudioVisualAppliance_type; }
const IfcParse::entity& IfcAudioVisualAppliance::Class() { return *IfcAudioVisualAppliance_type; }
IfcAudioVisualAppliance::IfcAudioVisualAppliance(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAudioVisualAppliance_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAudioVisualAppliance::IfcAudioVisualAppliance(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAudioVisualAppliance_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcAudioVisualApplianceTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcAudioVisualApplianceType
IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum IfcAudioVisualApplianceType::PredefinedType() const { return IfcAudioVisualApplianceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcAudioVisualApplianceType::setPredefinedType(IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAudioVisualApplianceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcAudioVisualApplianceType::declaration() const { return *IfcAudioVisualApplianceType_type; }
const IfcParse::entity& IfcAudioVisualApplianceType::Class() { return *IfcAudioVisualApplianceType_type; }
IfcAudioVisualApplianceType::IfcAudioVisualApplianceType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAudioVisualApplianceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAudioVisualApplianceType::IfcAudioVisualApplianceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAudioVisualApplianceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcAudioVisualApplianceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAxis1Placement
bool IfcAxis1Placement::hasAxis() const { return !data_->getArgument(1)->isNull(); }
IfcDirection* IfcAxis1Placement::Axis() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcAxis1Placement::setAxis(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcAxis1Placement::declaration() const { return *IfcAxis1Placement_type; }
const IfcParse::entity& IfcAxis1Placement::Class() { return *IfcAxis1Placement_type; }
IfcAxis1Placement::IfcAxis1Placement(IfcEntityInstanceData* e) : IfcPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAxis1Placement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAxis1Placement::IfcAxis1Placement(IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis) : IfcPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAxis1Placement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis));data_->setArgument(1,attr);} }

// Function implementations for IfcAxis2Placement2D
bool IfcAxis2Placement2D::hasRefDirection() const { return !data_->getArgument(1)->isNull(); }
IfcDirection* IfcAxis2Placement2D::RefDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcAxis2Placement2D::setRefDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcAxis2Placement2D::declaration() const { return *IfcAxis2Placement2D_type; }
const IfcParse::entity& IfcAxis2Placement2D::Class() { return *IfcAxis2Placement2D_type; }
IfcAxis2Placement2D::IfcAxis2Placement2D(IfcEntityInstanceData* e) : IfcPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAxis2Placement2D_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAxis2Placement2D::IfcAxis2Placement2D(IfcCartesianPoint* v1_Location, IfcDirection* v2_RefDirection) : IfcPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAxis2Placement2D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RefDirection));data_->setArgument(1,attr);} }

// Function implementations for IfcAxis2Placement3D
bool IfcAxis2Placement3D::hasAxis() const { return !data_->getArgument(1)->isNull(); }
IfcDirection* IfcAxis2Placement3D::Axis() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcAxis2Placement3D::setAxis(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcAxis2Placement3D::hasRefDirection() const { return !data_->getArgument(2)->isNull(); }
IfcDirection* IfcAxis2Placement3D::RefDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcAxis2Placement3D::setRefDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcAxis2Placement3D::declaration() const { return *IfcAxis2Placement3D_type; }
const IfcParse::entity& IfcAxis2Placement3D::Class() { return *IfcAxis2Placement3D_type; }
IfcAxis2Placement3D::IfcAxis2Placement3D(IfcEntityInstanceData* e) : IfcPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcAxis2Placement3D_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcAxis2Placement3D::IfcAxis2Placement3D(IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis, IfcDirection* v3_RefDirection) : IfcPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcAxis2Placement3D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RefDirection));data_->setArgument(2,attr);} }

// Function implementations for IfcBSplineCurve
int IfcBSplineCurve::Degree() const { return *data_->getArgument(0); }
void IfcBSplineCurve::setDegree(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcCartesianPoint >::ptr IfcBSplineCurve::ControlPointsList() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcCartesianPoint>(); }
void IfcBSplineCurve::setControlPointsList(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }
IfcBSplineCurveForm::IfcBSplineCurveForm IfcBSplineCurve::CurveForm() const { return IfcBSplineCurveForm::FromString(*data_->getArgument(2)); }
void IfcBSplineCurve::setCurveForm(IfcBSplineCurveForm::IfcBSplineCurveForm v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBSplineCurveForm::ToString(v)));data_->setArgument(2,attr);} }
bool IfcBSplineCurve::ClosedCurve() const { return *data_->getArgument(3); }
void IfcBSplineCurve::setClosedCurve(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcBSplineCurve::SelfIntersect() const { return *data_->getArgument(4); }
void IfcBSplineCurve::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcBSplineCurve::declaration() const { return *IfcBSplineCurve_type; }
const IfcParse::entity& IfcBSplineCurve::Class() { return *IfcBSplineCurve_type; }
IfcBSplineCurve::IfcBSplineCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBSplineCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBSplineCurve::IfcBSplineCurve(int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect) : IfcBoundedCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBSplineCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Degree));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ControlPointsList)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_CurveForm,IfcBSplineCurveForm::ToString(v3_CurveForm))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ClosedCurve));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SelfIntersect));data_->setArgument(4,attr);} }

// Function implementations for IfcBSplineCurveWithKnots
std::vector< int > /*[2:?]*/ IfcBSplineCurveWithKnots::KnotMultiplicities() const { return *data_->getArgument(5); }
void IfcBSplineCurveWithKnots::setKnotMultiplicities(std::vector< int > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
std::vector< double > /*[2:?]*/ IfcBSplineCurveWithKnots::Knots() const { return *data_->getArgument(6); }
void IfcBSplineCurveWithKnots::setKnots(std::vector< double > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
IfcKnotType::IfcKnotType IfcBSplineCurveWithKnots::KnotSpec() const { return IfcKnotType::FromString(*data_->getArgument(7)); }
void IfcBSplineCurveWithKnots::setKnotSpec(IfcKnotType::IfcKnotType v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcKnotType::ToString(v)));data_->setArgument(7,attr);} }


const IfcParse::entity& IfcBSplineCurveWithKnots::declaration() const { return *IfcBSplineCurveWithKnots_type; }
const IfcParse::entity& IfcBSplineCurveWithKnots::Class() { return *IfcBSplineCurveWithKnots_type; }
IfcBSplineCurveWithKnots::IfcBSplineCurveWithKnots(IfcEntityInstanceData* e) : IfcBSplineCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBSplineCurveWithKnots_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBSplineCurveWithKnots::IfcBSplineCurveWithKnots(int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect, std::vector< int > /*[2:?]*/ v6_KnotMultiplicities, std::vector< double > /*[2:?]*/ v7_Knots, IfcKnotType::IfcKnotType v8_KnotSpec) : IfcBSplineCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBSplineCurveWithKnots_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Degree));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ControlPointsList)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_CurveForm,IfcBSplineCurveForm::ToString(v3_CurveForm))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ClosedCurve));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SelfIntersect));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_KnotMultiplicities));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Knots));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_KnotSpec,IfcKnotType::ToString(v8_KnotSpec))));data_->setArgument(7,attr);} }

// Function implementations for IfcBSplineSurface
int IfcBSplineSurface::UDegree() const { return *data_->getArgument(0); }
void IfcBSplineSurface::setUDegree(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
int IfcBSplineSurface::VDegree() const { return *data_->getArgument(1); }
void IfcBSplineSurface::setVDegree(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcTemplatedEntityListList< IfcCartesianPoint >::ptr IfcBSplineSurface::ControlPointsList() const { IfcEntityListList::ptr es = *data_->getArgument(2); return es->as<IfcCartesianPoint>(); }
void IfcBSplineSurface::setControlPointsList(IfcTemplatedEntityListList< IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }
IfcBSplineSurfaceForm::IfcBSplineSurfaceForm IfcBSplineSurface::SurfaceForm() const { return IfcBSplineSurfaceForm::FromString(*data_->getArgument(3)); }
void IfcBSplineSurface::setSurfaceForm(IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBSplineSurfaceForm::ToString(v)));data_->setArgument(3,attr);} }
bool IfcBSplineSurface::UClosed() const { return *data_->getArgument(4); }
void IfcBSplineSurface::setUClosed(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcBSplineSurface::VClosed() const { return *data_->getArgument(5); }
void IfcBSplineSurface::setVClosed(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcBSplineSurface::SelfIntersect() const { return *data_->getArgument(6); }
void IfcBSplineSurface::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcBSplineSurface::declaration() const { return *IfcBSplineSurface_type; }
const IfcParse::entity& IfcBSplineSurface::Class() { return *IfcBSplineSurface_type; }
IfcBSplineSurface::IfcBSplineSurface(IfcEntityInstanceData* e) : IfcBoundedSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBSplineSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBSplineSurface::IfcBSplineSurface(int v1_UDegree, int v2_VDegree, IfcTemplatedEntityListList< IfcCartesianPoint >::ptr v3_ControlPointsList, IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v4_SurfaceForm, bool v5_UClosed, bool v6_VClosed, bool v7_SelfIntersect) : IfcBoundedSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBSplineSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_UDegree));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_VDegree));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ControlPointsList)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_SurfaceForm,IfcBSplineSurfaceForm::ToString(v4_SurfaceForm))));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_UClosed));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_VClosed));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SelfIntersect));data_->setArgument(6,attr);} }

// Function implementations for IfcBSplineSurfaceWithKnots
std::vector< int > /*[2:?]*/ IfcBSplineSurfaceWithKnots::UMultiplicities() const { return *data_->getArgument(7); }
void IfcBSplineSurfaceWithKnots::setUMultiplicities(std::vector< int > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
std::vector< int > /*[2:?]*/ IfcBSplineSurfaceWithKnots::VMultiplicities() const { return *data_->getArgument(8); }
void IfcBSplineSurfaceWithKnots::setVMultiplicities(std::vector< int > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
std::vector< double > /*[2:?]*/ IfcBSplineSurfaceWithKnots::UKnots() const { return *data_->getArgument(9); }
void IfcBSplineSurfaceWithKnots::setUKnots(std::vector< double > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
std::vector< double > /*[2:?]*/ IfcBSplineSurfaceWithKnots::VKnots() const { return *data_->getArgument(10); }
void IfcBSplineSurfaceWithKnots::setVKnots(std::vector< double > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
IfcKnotType::IfcKnotType IfcBSplineSurfaceWithKnots::KnotSpec() const { return IfcKnotType::FromString(*data_->getArgument(11)); }
void IfcBSplineSurfaceWithKnots::setKnotSpec(IfcKnotType::IfcKnotType v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcKnotType::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcBSplineSurfaceWithKnots::declaration() const { return *IfcBSplineSurfaceWithKnots_type; }
const IfcParse::entity& IfcBSplineSurfaceWithKnots::Class() { return *IfcBSplineSurfaceWithKnots_type; }
IfcBSplineSurfaceWithKnots::IfcBSplineSurfaceWithKnots(IfcEntityInstanceData* e) : IfcBSplineSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBSplineSurfaceWithKnots_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBSplineSurfaceWithKnots::IfcBSplineSurfaceWithKnots(int v1_UDegree, int v2_VDegree, IfcTemplatedEntityListList< IfcCartesianPoint >::ptr v3_ControlPointsList, IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v4_SurfaceForm, bool v5_UClosed, bool v6_VClosed, bool v7_SelfIntersect, std::vector< int > /*[2:?]*/ v8_UMultiplicities, std::vector< int > /*[2:?]*/ v9_VMultiplicities, std::vector< double > /*[2:?]*/ v10_UKnots, std::vector< double > /*[2:?]*/ v11_VKnots, IfcKnotType::IfcKnotType v12_KnotSpec) : IfcBSplineSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBSplineSurfaceWithKnots_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_UDegree));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_VDegree));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ControlPointsList)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_SurfaceForm,IfcBSplineSurfaceForm::ToString(v4_SurfaceForm))));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_UClosed));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_VClosed));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SelfIntersect));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_UMultiplicities));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_VMultiplicities));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_UKnots));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_VKnots));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_KnotSpec,IfcKnotType::ToString(v12_KnotSpec))));data_->setArgument(11,attr);} }

// Function implementations for IfcBeam
bool IfcBeam::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcBeamTypeEnum::IfcBeamTypeEnum IfcBeam::PredefinedType() const { return IfcBeamTypeEnum::FromString(*data_->getArgument(8)); }
void IfcBeam::setPredefinedType(IfcBeamTypeEnum::IfcBeamTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBeamTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcBeam::declaration() const { return *IfcBeam_type; }
const IfcParse::entity& IfcBeam::Class() { return *IfcBeam_type; }
IfcBeam::IfcBeam(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBeam_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBeam::IfcBeam(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBeamTypeEnum::IfcBeamTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBeam_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcBeamTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcBeamStandardCase


const IfcParse::entity& IfcBeamStandardCase::declaration() const { return *IfcBeamStandardCase_type; }
const IfcParse::entity& IfcBeamStandardCase::Class() { return *IfcBeamStandardCase_type; }
IfcBeamStandardCase::IfcBeamStandardCase(IfcEntityInstanceData* e) : IfcBeam((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBeamStandardCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBeamStandardCase::IfcBeamStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBeamTypeEnum::IfcBeamTypeEnum > v9_PredefinedType) : IfcBeam((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBeamStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcBeamTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcBeamType
IfcBeamTypeEnum::IfcBeamTypeEnum IfcBeamType::PredefinedType() const { return IfcBeamTypeEnum::FromString(*data_->getArgument(9)); }
void IfcBeamType::setPredefinedType(IfcBeamTypeEnum::IfcBeamTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBeamTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcBeamType::declaration() const { return *IfcBeamType_type; }
const IfcParse::entity& IfcBeamType::Class() { return *IfcBeamType_type; }
IfcBeamType::IfcBeamType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBeamType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBeamType::IfcBeamType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBeamTypeEnum::IfcBeamTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBeamType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcBeamTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcBlobTexture
std::string IfcBlobTexture::RasterFormat() const { return *data_->getArgument(5); }
void IfcBlobTexture::setRasterFormat(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
boost::dynamic_bitset<> IfcBlobTexture::RasterCode() const { return *data_->getArgument(6); }
void IfcBlobTexture::setRasterCode(boost::dynamic_bitset<> v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcBlobTexture::declaration() const { return *IfcBlobTexture_type; }
const IfcParse::entity& IfcBlobTexture::Class() { return *IfcBlobTexture_type; }
IfcBlobTexture::IfcBlobTexture(IfcEntityInstanceData* e) : IfcSurfaceTexture((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBlobTexture_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBlobTexture::IfcBlobTexture(bool v1_RepeatS, bool v2_RepeatT, boost::optional< std::string > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_Parameter, std::string v6_RasterFormat, boost::dynamic_bitset<> v7_RasterCode) : IfcSurfaceTexture((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBlobTexture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));data_->setArgument(1,attr);} if (v3_Mode) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Mode));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));data_->setArgument(3,attr);} if (v5_Parameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Parameter));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RasterFormat));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RasterCode));data_->setArgument(6,attr);} }

// Function implementations for IfcBlock
double IfcBlock::XLength() const { return *data_->getArgument(1); }
void IfcBlock::setXLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcBlock::YLength() const { return *data_->getArgument(2); }
void IfcBlock::setYLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double IfcBlock::ZLength() const { return *data_->getArgument(3); }
void IfcBlock::setZLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcBlock::declaration() const { return *IfcBlock_type; }
const IfcParse::entity& IfcBlock::Class() { return *IfcBlock_type; }
IfcBlock::IfcBlock(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBlock_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBlock::IfcBlock(IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_ZLength) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBlock_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_XLength));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YLength));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ZLength));data_->setArgument(3,attr);} }

// Function implementations for IfcBoiler
bool IfcBoiler::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcBoilerTypeEnum::IfcBoilerTypeEnum IfcBoiler::PredefinedType() const { return IfcBoilerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcBoiler::setPredefinedType(IfcBoilerTypeEnum::IfcBoilerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBoilerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcBoiler::declaration() const { return *IfcBoiler_type; }
const IfcParse::entity& IfcBoiler::Class() { return *IfcBoiler_type; }
IfcBoiler::IfcBoiler(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoiler_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoiler::IfcBoiler(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBoilerTypeEnum::IfcBoilerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoiler_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcBoilerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcBoilerType
IfcBoilerTypeEnum::IfcBoilerTypeEnum IfcBoilerType::PredefinedType() const { return IfcBoilerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcBoilerType::setPredefinedType(IfcBoilerTypeEnum::IfcBoilerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBoilerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcBoilerType::declaration() const { return *IfcBoilerType_type; }
const IfcParse::entity& IfcBoilerType::Class() { return *IfcBoilerType_type; }
IfcBoilerType::IfcBoilerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoilerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoilerType::IfcBoilerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBoilerTypeEnum::IfcBoilerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoilerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcBoilerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcBooleanClippingResult


const IfcParse::entity& IfcBooleanClippingResult::declaration() const { return *IfcBooleanClippingResult_type; }
const IfcParse::entity& IfcBooleanClippingResult::Class() { return *IfcBooleanClippingResult_type; }
IfcBooleanClippingResult::IfcBooleanClippingResult(IfcEntityInstanceData* e) : IfcBooleanResult((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBooleanClippingResult_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBooleanClippingResult::IfcBooleanClippingResult(IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand* v2_FirstOperand, IfcBooleanOperand* v3_SecondOperand) : IfcBooleanResult((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBooleanClippingResult_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Operator,IfcBooleanOperator::ToString(v1_Operator))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FirstOperand));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SecondOperand));data_->setArgument(2,attr);} }

// Function implementations for IfcBooleanResult
IfcBooleanOperator::IfcBooleanOperator IfcBooleanResult::Operator() const { return IfcBooleanOperator::FromString(*data_->getArgument(0)); }
void IfcBooleanResult::setOperator(IfcBooleanOperator::IfcBooleanOperator v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBooleanOperator::ToString(v)));data_->setArgument(0,attr);} }
IfcBooleanOperand* IfcBooleanResult::FirstOperand() const { return (IfcBooleanOperand*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcBooleanResult::setFirstOperand(IfcBooleanOperand* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcBooleanOperand* IfcBooleanResult::SecondOperand() const { return (IfcBooleanOperand*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcBooleanResult::setSecondOperand(IfcBooleanOperand* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcBooleanResult::declaration() const { return *IfcBooleanResult_type; }
const IfcParse::entity& IfcBooleanResult::Class() { return *IfcBooleanResult_type; }
IfcBooleanResult::IfcBooleanResult(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBooleanResult_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBooleanResult::IfcBooleanResult(IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand* v2_FirstOperand, IfcBooleanOperand* v3_SecondOperand) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBooleanResult_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Operator,IfcBooleanOperator::ToString(v1_Operator))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FirstOperand));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SecondOperand));data_->setArgument(2,attr);} }

// Function implementations for IfcBoundaryCondition
bool IfcBoundaryCondition::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcBoundaryCondition::Name() const { return *data_->getArgument(0); }
void IfcBoundaryCondition::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcBoundaryCondition::declaration() const { return *IfcBoundaryCondition_type; }
const IfcParse::entity& IfcBoundaryCondition::Class() { return *IfcBoundaryCondition_type; }
IfcBoundaryCondition::IfcBoundaryCondition(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcBoundaryCondition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoundaryCondition::IfcBoundaryCondition(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcBoundaryCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcBoundaryCurve


const IfcParse::entity& IfcBoundaryCurve::declaration() const { return *IfcBoundaryCurve_type; }
const IfcParse::entity& IfcBoundaryCurve::Class() { return *IfcBoundaryCurve_type; }
IfcBoundaryCurve::IfcBoundaryCurve(IfcEntityInstanceData* e) : IfcCompositeCurveOnSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoundaryCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoundaryCurve::IfcBoundaryCurve(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect) : IfcCompositeCurveOnSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoundaryCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Segments)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SelfIntersect));data_->setArgument(1,attr);} }

// Function implementations for IfcBoundaryEdgeCondition
bool IfcBoundaryEdgeCondition::hasTranslationalStiffnessByLengthX() const { return !data_->getArgument(1)->isNull(); }
IfcModulusOfTranslationalSubgradeReactionSelect* IfcBoundaryEdgeCondition::TranslationalStiffnessByLengthX() const { return (IfcModulusOfTranslationalSubgradeReactionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcBoundaryEdgeCondition::setTranslationalStiffnessByLengthX(IfcModulusOfTranslationalSubgradeReactionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcBoundaryEdgeCondition::hasTranslationalStiffnessByLengthY() const { return !data_->getArgument(2)->isNull(); }
IfcModulusOfTranslationalSubgradeReactionSelect* IfcBoundaryEdgeCondition::TranslationalStiffnessByLengthY() const { return (IfcModulusOfTranslationalSubgradeReactionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcBoundaryEdgeCondition::setTranslationalStiffnessByLengthY(IfcModulusOfTranslationalSubgradeReactionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcBoundaryEdgeCondition::hasTranslationalStiffnessByLengthZ() const { return !data_->getArgument(3)->isNull(); }
IfcModulusOfTranslationalSubgradeReactionSelect* IfcBoundaryEdgeCondition::TranslationalStiffnessByLengthZ() const { return (IfcModulusOfTranslationalSubgradeReactionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcBoundaryEdgeCondition::setTranslationalStiffnessByLengthZ(IfcModulusOfTranslationalSubgradeReactionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcBoundaryEdgeCondition::hasRotationalStiffnessByLengthX() const { return !data_->getArgument(4)->isNull(); }
IfcModulusOfRotationalSubgradeReactionSelect* IfcBoundaryEdgeCondition::RotationalStiffnessByLengthX() const { return (IfcModulusOfRotationalSubgradeReactionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthX(IfcModulusOfRotationalSubgradeReactionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcBoundaryEdgeCondition::hasRotationalStiffnessByLengthY() const { return !data_->getArgument(5)->isNull(); }
IfcModulusOfRotationalSubgradeReactionSelect* IfcBoundaryEdgeCondition::RotationalStiffnessByLengthY() const { return (IfcModulusOfRotationalSubgradeReactionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthY(IfcModulusOfRotationalSubgradeReactionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcBoundaryEdgeCondition::hasRotationalStiffnessByLengthZ() const { return !data_->getArgument(6)->isNull(); }
IfcModulusOfRotationalSubgradeReactionSelect* IfcBoundaryEdgeCondition::RotationalStiffnessByLengthZ() const { return (IfcModulusOfRotationalSubgradeReactionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthZ(IfcModulusOfRotationalSubgradeReactionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcBoundaryEdgeCondition::declaration() const { return *IfcBoundaryEdgeCondition_type; }
const IfcParse::entity& IfcBoundaryEdgeCondition::Class() { return *IfcBoundaryEdgeCondition_type; }
IfcBoundaryEdgeCondition::IfcBoundaryEdgeCondition(IfcEntityInstanceData* e) : IfcBoundaryCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoundaryEdgeCondition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoundaryEdgeCondition::IfcBoundaryEdgeCondition(boost::optional< std::string > v1_Name, IfcModulusOfTranslationalSubgradeReactionSelect* v2_TranslationalStiffnessByLengthX, IfcModulusOfTranslationalSubgradeReactionSelect* v3_TranslationalStiffnessByLengthY, IfcModulusOfTranslationalSubgradeReactionSelect* v4_TranslationalStiffnessByLengthZ, IfcModulusOfRotationalSubgradeReactionSelect* v5_RotationalStiffnessByLengthX, IfcModulusOfRotationalSubgradeReactionSelect* v6_RotationalStiffnessByLengthY, IfcModulusOfRotationalSubgradeReactionSelect* v7_RotationalStiffnessByLengthZ) : IfcBoundaryCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoundaryEdgeCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TranslationalStiffnessByLengthX));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TranslationalStiffnessByLengthY));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TranslationalStiffnessByLengthZ));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RotationalStiffnessByLengthX));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RotationalStiffnessByLengthY));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RotationalStiffnessByLengthZ));data_->setArgument(6,attr);} }

// Function implementations for IfcBoundaryFaceCondition
bool IfcBoundaryFaceCondition::hasTranslationalStiffnessByAreaX() const { return !data_->getArgument(1)->isNull(); }
IfcModulusOfSubgradeReactionSelect* IfcBoundaryFaceCondition::TranslationalStiffnessByAreaX() const { return (IfcModulusOfSubgradeReactionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcBoundaryFaceCondition::setTranslationalStiffnessByAreaX(IfcModulusOfSubgradeReactionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcBoundaryFaceCondition::hasTranslationalStiffnessByAreaY() const { return !data_->getArgument(2)->isNull(); }
IfcModulusOfSubgradeReactionSelect* IfcBoundaryFaceCondition::TranslationalStiffnessByAreaY() const { return (IfcModulusOfSubgradeReactionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcBoundaryFaceCondition::setTranslationalStiffnessByAreaY(IfcModulusOfSubgradeReactionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcBoundaryFaceCondition::hasTranslationalStiffnessByAreaZ() const { return !data_->getArgument(3)->isNull(); }
IfcModulusOfSubgradeReactionSelect* IfcBoundaryFaceCondition::TranslationalStiffnessByAreaZ() const { return (IfcModulusOfSubgradeReactionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcBoundaryFaceCondition::setTranslationalStiffnessByAreaZ(IfcModulusOfSubgradeReactionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcBoundaryFaceCondition::declaration() const { return *IfcBoundaryFaceCondition_type; }
const IfcParse::entity& IfcBoundaryFaceCondition::Class() { return *IfcBoundaryFaceCondition_type; }
IfcBoundaryFaceCondition::IfcBoundaryFaceCondition(IfcEntityInstanceData* e) : IfcBoundaryCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoundaryFaceCondition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoundaryFaceCondition::IfcBoundaryFaceCondition(boost::optional< std::string > v1_Name, IfcModulusOfSubgradeReactionSelect* v2_TranslationalStiffnessByAreaX, IfcModulusOfSubgradeReactionSelect* v3_TranslationalStiffnessByAreaY, IfcModulusOfSubgradeReactionSelect* v4_TranslationalStiffnessByAreaZ) : IfcBoundaryCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoundaryFaceCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TranslationalStiffnessByAreaX));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TranslationalStiffnessByAreaY));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TranslationalStiffnessByAreaZ));data_->setArgument(3,attr);} }

// Function implementations for IfcBoundaryNodeCondition
bool IfcBoundaryNodeCondition::hasTranslationalStiffnessX() const { return !data_->getArgument(1)->isNull(); }
IfcTranslationalStiffnessSelect* IfcBoundaryNodeCondition::TranslationalStiffnessX() const { return (IfcTranslationalStiffnessSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcBoundaryNodeCondition::setTranslationalStiffnessX(IfcTranslationalStiffnessSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcBoundaryNodeCondition::hasTranslationalStiffnessY() const { return !data_->getArgument(2)->isNull(); }
IfcTranslationalStiffnessSelect* IfcBoundaryNodeCondition::TranslationalStiffnessY() const { return (IfcTranslationalStiffnessSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcBoundaryNodeCondition::setTranslationalStiffnessY(IfcTranslationalStiffnessSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcBoundaryNodeCondition::hasTranslationalStiffnessZ() const { return !data_->getArgument(3)->isNull(); }
IfcTranslationalStiffnessSelect* IfcBoundaryNodeCondition::TranslationalStiffnessZ() const { return (IfcTranslationalStiffnessSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcBoundaryNodeCondition::setTranslationalStiffnessZ(IfcTranslationalStiffnessSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcBoundaryNodeCondition::hasRotationalStiffnessX() const { return !data_->getArgument(4)->isNull(); }
IfcRotationalStiffnessSelect* IfcBoundaryNodeCondition::RotationalStiffnessX() const { return (IfcRotationalStiffnessSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcBoundaryNodeCondition::setRotationalStiffnessX(IfcRotationalStiffnessSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcBoundaryNodeCondition::hasRotationalStiffnessY() const { return !data_->getArgument(5)->isNull(); }
IfcRotationalStiffnessSelect* IfcBoundaryNodeCondition::RotationalStiffnessY() const { return (IfcRotationalStiffnessSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcBoundaryNodeCondition::setRotationalStiffnessY(IfcRotationalStiffnessSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcBoundaryNodeCondition::hasRotationalStiffnessZ() const { return !data_->getArgument(6)->isNull(); }
IfcRotationalStiffnessSelect* IfcBoundaryNodeCondition::RotationalStiffnessZ() const { return (IfcRotationalStiffnessSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcBoundaryNodeCondition::setRotationalStiffnessZ(IfcRotationalStiffnessSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcBoundaryNodeCondition::declaration() const { return *IfcBoundaryNodeCondition_type; }
const IfcParse::entity& IfcBoundaryNodeCondition::Class() { return *IfcBoundaryNodeCondition_type; }
IfcBoundaryNodeCondition::IfcBoundaryNodeCondition(IfcEntityInstanceData* e) : IfcBoundaryCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoundaryNodeCondition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoundaryNodeCondition::IfcBoundaryNodeCondition(boost::optional< std::string > v1_Name, IfcTranslationalStiffnessSelect* v2_TranslationalStiffnessX, IfcTranslationalStiffnessSelect* v3_TranslationalStiffnessY, IfcTranslationalStiffnessSelect* v4_TranslationalStiffnessZ, IfcRotationalStiffnessSelect* v5_RotationalStiffnessX, IfcRotationalStiffnessSelect* v6_RotationalStiffnessY, IfcRotationalStiffnessSelect* v7_RotationalStiffnessZ) : IfcBoundaryCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoundaryNodeCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TranslationalStiffnessX));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TranslationalStiffnessY));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TranslationalStiffnessZ));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RotationalStiffnessX));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RotationalStiffnessY));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RotationalStiffnessZ));data_->setArgument(6,attr);} }

// Function implementations for IfcBoundaryNodeConditionWarping
bool IfcBoundaryNodeConditionWarping::hasWarpingStiffness() const { return !data_->getArgument(7)->isNull(); }
IfcWarpingStiffnessSelect* IfcBoundaryNodeConditionWarping::WarpingStiffness() const { return (IfcWarpingStiffnessSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcBoundaryNodeConditionWarping::setWarpingStiffness(IfcWarpingStiffnessSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcBoundaryNodeConditionWarping::declaration() const { return *IfcBoundaryNodeConditionWarping_type; }
const IfcParse::entity& IfcBoundaryNodeConditionWarping::Class() { return *IfcBoundaryNodeConditionWarping_type; }
IfcBoundaryNodeConditionWarping::IfcBoundaryNodeConditionWarping(IfcEntityInstanceData* e) : IfcBoundaryNodeCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoundaryNodeConditionWarping_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoundaryNodeConditionWarping::IfcBoundaryNodeConditionWarping(boost::optional< std::string > v1_Name, IfcTranslationalStiffnessSelect* v2_TranslationalStiffnessX, IfcTranslationalStiffnessSelect* v3_TranslationalStiffnessY, IfcTranslationalStiffnessSelect* v4_TranslationalStiffnessZ, IfcRotationalStiffnessSelect* v5_RotationalStiffnessX, IfcRotationalStiffnessSelect* v6_RotationalStiffnessY, IfcRotationalStiffnessSelect* v7_RotationalStiffnessZ, IfcWarpingStiffnessSelect* v8_WarpingStiffness) : IfcBoundaryNodeCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoundaryNodeConditionWarping_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TranslationalStiffnessX));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TranslationalStiffnessY));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TranslationalStiffnessZ));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RotationalStiffnessX));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RotationalStiffnessY));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RotationalStiffnessZ));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_WarpingStiffness));data_->setArgument(7,attr);} }

// Function implementations for IfcBoundedCurve


const IfcParse::entity& IfcBoundedCurve::declaration() const { return *IfcBoundedCurve_type; }
const IfcParse::entity& IfcBoundedCurve::Class() { return *IfcBoundedCurve_type; }
IfcBoundedCurve::IfcBoundedCurve(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoundedCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoundedCurve::IfcBoundedCurve() : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoundedCurve_type);  }

// Function implementations for IfcBoundedSurface


const IfcParse::entity& IfcBoundedSurface::declaration() const { return *IfcBoundedSurface_type; }
const IfcParse::entity& IfcBoundedSurface::Class() { return *IfcBoundedSurface_type; }
IfcBoundedSurface::IfcBoundedSurface(IfcEntityInstanceData* e) : IfcSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoundedSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoundedSurface::IfcBoundedSurface() : IfcSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoundedSurface_type);  }

// Function implementations for IfcBoundingBox
IfcCartesianPoint* IfcBoundingBox::Corner() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcBoundingBox::setCorner(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcBoundingBox::XDim() const { return *data_->getArgument(1); }
void IfcBoundingBox::setXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcBoundingBox::YDim() const { return *data_->getArgument(2); }
void IfcBoundingBox::setYDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double IfcBoundingBox::ZDim() const { return *data_->getArgument(3); }
void IfcBoundingBox::setZDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcBoundingBox::declaration() const { return *IfcBoundingBox_type; }
const IfcParse::entity& IfcBoundingBox::Class() { return *IfcBoundingBox_type; }
IfcBoundingBox::IfcBoundingBox(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoundingBox_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoundingBox::IfcBoundingBox(IfcCartesianPoint* v1_Corner, double v2_XDim, double v3_YDim, double v4_ZDim) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoundingBox_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Corner));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_XDim));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YDim));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ZDim));data_->setArgument(3,attr);} }

// Function implementations for IfcBoxedHalfSpace
IfcBoundingBox* IfcBoxedHalfSpace::Enclosure() const { return (IfcBoundingBox*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcBoxedHalfSpace::setEnclosure(IfcBoundingBox* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcBoxedHalfSpace::declaration() const { return *IfcBoxedHalfSpace_type; }
const IfcParse::entity& IfcBoxedHalfSpace::Class() { return *IfcBoxedHalfSpace_type; }
IfcBoxedHalfSpace::IfcBoxedHalfSpace(IfcEntityInstanceData* e) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBoxedHalfSpace_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBoxedHalfSpace::IfcBoxedHalfSpace(IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcBoundingBox* v3_Enclosure) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBoxedHalfSpace_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BaseSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AgreementFlag));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Enclosure));data_->setArgument(2,attr);} }

// Function implementations for IfcBuilding
bool IfcBuilding::hasElevationOfRefHeight() const { return !data_->getArgument(9)->isNull(); }
double IfcBuilding::ElevationOfRefHeight() const { return *data_->getArgument(9); }
void IfcBuilding::setElevationOfRefHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcBuilding::hasElevationOfTerrain() const { return !data_->getArgument(10)->isNull(); }
double IfcBuilding::ElevationOfTerrain() const { return *data_->getArgument(10); }
void IfcBuilding::setElevationOfTerrain(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcBuilding::hasBuildingAddress() const { return !data_->getArgument(11)->isNull(); }
IfcPostalAddress* IfcBuilding::BuildingAddress() const { return (IfcPostalAddress*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(11))); }
void IfcBuilding::setBuildingAddress(IfcPostalAddress* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }


const IfcParse::entity& IfcBuilding::declaration() const { return *IfcBuilding_type; }
const IfcParse::entity& IfcBuilding::Class() { return *IfcBuilding_type; }
IfcBuilding::IfcBuilding(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBuilding_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBuilding::IfcBuilding(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< double > v10_ElevationOfRefHeight, boost::optional< double > v11_ElevationOfTerrain, IfcPostalAddress* v12_BuildingAddress) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBuilding_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_CompositionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_ElevationOfRefHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_ElevationOfRefHeight));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_ElevationOfTerrain) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ElevationOfTerrain));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_BuildingAddress));data_->setArgument(11,attr);} }

// Function implementations for IfcBuildingElement


const IfcParse::entity& IfcBuildingElement::declaration() const { return *IfcBuildingElement_type; }
const IfcParse::entity& IfcBuildingElement::Class() { return *IfcBuildingElement_type; }
IfcBuildingElement::IfcBuildingElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBuildingElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBuildingElement::IfcBuildingElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBuildingElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcBuildingElementPart
bool IfcBuildingElementPart::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum IfcBuildingElementPart::PredefinedType() const { return IfcBuildingElementPartTypeEnum::FromString(*data_->getArgument(8)); }
void IfcBuildingElementPart::setPredefinedType(IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBuildingElementPartTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcBuildingElementPart::declaration() const { return *IfcBuildingElementPart_type; }
const IfcParse::entity& IfcBuildingElementPart::Class() { return *IfcBuildingElementPart_type; }
IfcBuildingElementPart::IfcBuildingElementPart(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBuildingElementPart_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBuildingElementPart::IfcBuildingElementPart(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum > v9_PredefinedType) : IfcElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBuildingElementPart_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcBuildingElementPartTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcBuildingElementPartType
IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum IfcBuildingElementPartType::PredefinedType() const { return IfcBuildingElementPartTypeEnum::FromString(*data_->getArgument(9)); }
void IfcBuildingElementPartType::setPredefinedType(IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBuildingElementPartTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcBuildingElementPartType::declaration() const { return *IfcBuildingElementPartType_type; }
const IfcParse::entity& IfcBuildingElementPartType::Class() { return *IfcBuildingElementPartType_type; }
IfcBuildingElementPartType::IfcBuildingElementPartType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBuildingElementPartType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBuildingElementPartType::IfcBuildingElementPartType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum v10_PredefinedType) : IfcElementComponentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBuildingElementPartType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcBuildingElementPartTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcBuildingElementProxy
bool IfcBuildingElementProxy::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum IfcBuildingElementProxy::PredefinedType() const { return IfcBuildingElementProxyTypeEnum::FromString(*data_->getArgument(8)); }
void IfcBuildingElementProxy::setPredefinedType(IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBuildingElementProxyTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcBuildingElementProxy::declaration() const { return *IfcBuildingElementProxy_type; }
const IfcParse::entity& IfcBuildingElementProxy::Class() { return *IfcBuildingElementProxy_type; }
IfcBuildingElementProxy::IfcBuildingElementProxy(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBuildingElementProxy_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBuildingElementProxy::IfcBuildingElementProxy(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBuildingElementProxy_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcBuildingElementProxyTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcBuildingElementProxyType
IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum IfcBuildingElementProxyType::PredefinedType() const { return IfcBuildingElementProxyTypeEnum::FromString(*data_->getArgument(9)); }
void IfcBuildingElementProxyType::setPredefinedType(IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBuildingElementProxyTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcBuildingElementProxyType::declaration() const { return *IfcBuildingElementProxyType_type; }
const IfcParse::entity& IfcBuildingElementProxyType::Class() { return *IfcBuildingElementProxyType_type; }
IfcBuildingElementProxyType::IfcBuildingElementProxyType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBuildingElementProxyType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBuildingElementProxyType::IfcBuildingElementProxyType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBuildingElementProxyType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcBuildingElementProxyTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcBuildingElementType


const IfcParse::entity& IfcBuildingElementType::declaration() const { return *IfcBuildingElementType_type; }
const IfcParse::entity& IfcBuildingElementType::Class() { return *IfcBuildingElementType_type; }
IfcBuildingElementType::IfcBuildingElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBuildingElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBuildingElementType::IfcBuildingElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBuildingElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcBuildingStorey
bool IfcBuildingStorey::hasElevation() const { return !data_->getArgument(9)->isNull(); }
double IfcBuildingStorey::Elevation() const { return *data_->getArgument(9); }
void IfcBuildingStorey::setElevation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcBuildingStorey::declaration() const { return *IfcBuildingStorey_type; }
const IfcParse::entity& IfcBuildingStorey::Class() { return *IfcBuildingStorey_type; }
IfcBuildingStorey::IfcBuildingStorey(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBuildingStorey_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBuildingStorey::IfcBuildingStorey(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< double > v10_Elevation) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBuildingStorey_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_CompositionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Elevation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Elevation));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcBuildingSystem
bool IfcBuildingSystem::hasPredefinedType() const { return !data_->getArgument(5)->isNull(); }
IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum IfcBuildingSystem::PredefinedType() const { return IfcBuildingSystemTypeEnum::FromString(*data_->getArgument(5)); }
void IfcBuildingSystem::setPredefinedType(IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBuildingSystemTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
bool IfcBuildingSystem::hasLongName() const { return !data_->getArgument(6)->isNull(); }
std::string IfcBuildingSystem::LongName() const { return *data_->getArgument(6); }
void IfcBuildingSystem::setLongName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcBuildingSystem::declaration() const { return *IfcBuildingSystem_type; }
const IfcParse::entity& IfcBuildingSystem::Class() { return *IfcBuildingSystem_type; }
IfcBuildingSystem::IfcBuildingSystem(IfcEntityInstanceData* e) : IfcSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBuildingSystem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBuildingSystem::IfcBuildingSystem(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum > v6_PredefinedType, boost::optional< std::string > v7_LongName) : IfcSystem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBuildingSystem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_PredefinedType,IfcBuildingSystemTypeEnum::ToString(*v6_PredefinedType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongName));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcBurner
bool IfcBurner::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcBurnerTypeEnum::IfcBurnerTypeEnum IfcBurner::PredefinedType() const { return IfcBurnerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcBurner::setPredefinedType(IfcBurnerTypeEnum::IfcBurnerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBurnerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcBurner::declaration() const { return *IfcBurner_type; }
const IfcParse::entity& IfcBurner::Class() { return *IfcBurner_type; }
IfcBurner::IfcBurner(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBurner_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBurner::IfcBurner(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBurnerTypeEnum::IfcBurnerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBurner_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcBurnerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcBurnerType
IfcBurnerTypeEnum::IfcBurnerTypeEnum IfcBurnerType::PredefinedType() const { return IfcBurnerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcBurnerType::setPredefinedType(IfcBurnerTypeEnum::IfcBurnerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBurnerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcBurnerType::declaration() const { return *IfcBurnerType_type; }
const IfcParse::entity& IfcBurnerType::Class() { return *IfcBurnerType_type; }
IfcBurnerType::IfcBurnerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcBurnerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcBurnerType::IfcBurnerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBurnerTypeEnum::IfcBurnerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcBurnerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcBurnerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCShapeProfileDef
double IfcCShapeProfileDef::Depth() const { return *data_->getArgument(3); }
void IfcCShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcCShapeProfileDef::Width() const { return *data_->getArgument(4); }
void IfcCShapeProfileDef::setWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double IfcCShapeProfileDef::WallThickness() const { return *data_->getArgument(5); }
void IfcCShapeProfileDef::setWallThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double IfcCShapeProfileDef::Girth() const { return *data_->getArgument(6); }
void IfcCShapeProfileDef::setGirth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcCShapeProfileDef::hasInternalFilletRadius() const { return !data_->getArgument(7)->isNull(); }
double IfcCShapeProfileDef::InternalFilletRadius() const { return *data_->getArgument(7); }
void IfcCShapeProfileDef::setInternalFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcCShapeProfileDef::declaration() const { return *IfcCShapeProfileDef_type; }
const IfcParse::entity& IfcCShapeProfileDef::Class() { return *IfcCShapeProfileDef_type; }
IfcCShapeProfileDef::IfcCShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCShapeProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCShapeProfileDef::IfcCShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_Width, double v6_WallThickness, double v7_Girth, boost::optional< double > v8_InternalFilletRadius) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Width));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WallThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Girth));data_->setArgument(6,attr);} if (v8_InternalFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_InternalFilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcCableCarrierFitting
bool IfcCableCarrierFitting::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum IfcCableCarrierFitting::PredefinedType() const { return IfcCableCarrierFittingTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCableCarrierFitting::setPredefinedType(IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableCarrierFittingTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCableCarrierFitting::declaration() const { return *IfcCableCarrierFitting_type; }
const IfcParse::entity& IfcCableCarrierFitting::Class() { return *IfcCableCarrierFitting_type; }
IfcCableCarrierFitting::IfcCableCarrierFitting(IfcEntityInstanceData* e) : IfcFlowFitting((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCableCarrierFitting_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCableCarrierFitting::IfcCableCarrierFitting(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCableCarrierFitting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCableCarrierFittingTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCableCarrierFittingType
IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum IfcCableCarrierFittingType::PredefinedType() const { return IfcCableCarrierFittingTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCableCarrierFittingType::setPredefinedType(IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableCarrierFittingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCableCarrierFittingType::declaration() const { return *IfcCableCarrierFittingType_type; }
const IfcParse::entity& IfcCableCarrierFittingType::Class() { return *IfcCableCarrierFittingType_type; }
IfcCableCarrierFittingType::IfcCableCarrierFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCableCarrierFittingType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCableCarrierFittingType::IfcCableCarrierFittingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCableCarrierFittingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCableCarrierFittingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCableCarrierSegment
bool IfcCableCarrierSegment::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum IfcCableCarrierSegment::PredefinedType() const { return IfcCableCarrierSegmentTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCableCarrierSegment::setPredefinedType(IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableCarrierSegmentTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCableCarrierSegment::declaration() const { return *IfcCableCarrierSegment_type; }
const IfcParse::entity& IfcCableCarrierSegment::Class() { return *IfcCableCarrierSegment_type; }
IfcCableCarrierSegment::IfcCableCarrierSegment(IfcEntityInstanceData* e) : IfcFlowSegment((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCableCarrierSegment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCableCarrierSegment::IfcCableCarrierSegment(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum > v9_PredefinedType) : IfcFlowSegment((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCableCarrierSegment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCableCarrierSegmentTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCableCarrierSegmentType
IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum IfcCableCarrierSegmentType::PredefinedType() const { return IfcCableCarrierSegmentTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCableCarrierSegmentType::setPredefinedType(IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableCarrierSegmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCableCarrierSegmentType::declaration() const { return *IfcCableCarrierSegmentType_type; }
const IfcParse::entity& IfcCableCarrierSegmentType::Class() { return *IfcCableCarrierSegmentType_type; }
IfcCableCarrierSegmentType::IfcCableCarrierSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCableCarrierSegmentType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCableCarrierSegmentType::IfcCableCarrierSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCableCarrierSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCableCarrierSegmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCableFitting
bool IfcCableFitting::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCableFittingTypeEnum::IfcCableFittingTypeEnum IfcCableFitting::PredefinedType() const { return IfcCableFittingTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCableFitting::setPredefinedType(IfcCableFittingTypeEnum::IfcCableFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableFittingTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCableFitting::declaration() const { return *IfcCableFitting_type; }
const IfcParse::entity& IfcCableFitting::Class() { return *IfcCableFitting_type; }
IfcCableFitting::IfcCableFitting(IfcEntityInstanceData* e) : IfcFlowFitting((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCableFitting_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCableFitting::IfcCableFitting(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCableFittingTypeEnum::IfcCableFittingTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCableFitting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCableFittingTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCableFittingType
IfcCableFittingTypeEnum::IfcCableFittingTypeEnum IfcCableFittingType::PredefinedType() const { return IfcCableFittingTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCableFittingType::setPredefinedType(IfcCableFittingTypeEnum::IfcCableFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableFittingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCableFittingType::declaration() const { return *IfcCableFittingType_type; }
const IfcParse::entity& IfcCableFittingType::Class() { return *IfcCableFittingType_type; }
IfcCableFittingType::IfcCableFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCableFittingType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCableFittingType::IfcCableFittingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableFittingTypeEnum::IfcCableFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCableFittingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCableFittingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCableSegment
bool IfcCableSegment::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum IfcCableSegment::PredefinedType() const { return IfcCableSegmentTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCableSegment::setPredefinedType(IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableSegmentTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCableSegment::declaration() const { return *IfcCableSegment_type; }
const IfcParse::entity& IfcCableSegment::Class() { return *IfcCableSegment_type; }
IfcCableSegment::IfcCableSegment(IfcEntityInstanceData* e) : IfcFlowSegment((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCableSegment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCableSegment::IfcCableSegment(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum > v9_PredefinedType) : IfcFlowSegment((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCableSegment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCableSegmentTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCableSegmentType
IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum IfcCableSegmentType::PredefinedType() const { return IfcCableSegmentTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCableSegmentType::setPredefinedType(IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableSegmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCableSegmentType::declaration() const { return *IfcCableSegmentType_type; }
const IfcParse::entity& IfcCableSegmentType::Class() { return *IfcCableSegmentType_type; }
IfcCableSegmentType::IfcCableSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCableSegmentType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCableSegmentType::IfcCableSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCableSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCableSegmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCartesianPoint
std::vector< double > /*[1:3]*/ IfcCartesianPoint::Coordinates() const { return *data_->getArgument(0); }
void IfcCartesianPoint::setCoordinates(std::vector< double > /*[1:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcCartesianPoint::declaration() const { return *IfcCartesianPoint_type; }
const IfcParse::entity& IfcCartesianPoint::Class() { return *IfcCartesianPoint_type; }
IfcCartesianPoint::IfcCartesianPoint(IfcEntityInstanceData* e) : IfcPoint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCartesianPoint_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCartesianPoint::IfcCartesianPoint(std::vector< double > /*[1:3]*/ v1_Coordinates) : IfcPoint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCartesianPoint_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Coordinates));data_->setArgument(0,attr);} }

// Function implementations for IfcCartesianPointList


const IfcParse::entity& IfcCartesianPointList::declaration() const { return *IfcCartesianPointList_type; }
const IfcParse::entity& IfcCartesianPointList::Class() { return *IfcCartesianPointList_type; }
IfcCartesianPointList::IfcCartesianPointList(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCartesianPointList_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCartesianPointList::IfcCartesianPointList() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCartesianPointList_type);  }

// Function implementations for IfcCartesianPointList2D
std::vector< std::vector< double > > IfcCartesianPointList2D::CoordList() const { return *data_->getArgument(0); }
void IfcCartesianPointList2D::setCoordList(std::vector< std::vector< double > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcCartesianPointList2D::declaration() const { return *IfcCartesianPointList2D_type; }
const IfcParse::entity& IfcCartesianPointList2D::Class() { return *IfcCartesianPointList2D_type; }
IfcCartesianPointList2D::IfcCartesianPointList2D(IfcEntityInstanceData* e) : IfcCartesianPointList((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCartesianPointList2D_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCartesianPointList2D::IfcCartesianPointList2D(std::vector< std::vector< double > > v1_CoordList) : IfcCartesianPointList((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCartesianPointList2D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CoordList));data_->setArgument(0,attr);} }

// Function implementations for IfcCartesianPointList3D
std::vector< std::vector< double > > IfcCartesianPointList3D::CoordList() const { return *data_->getArgument(0); }
void IfcCartesianPointList3D::setCoordList(std::vector< std::vector< double > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcCartesianPointList3D::declaration() const { return *IfcCartesianPointList3D_type; }
const IfcParse::entity& IfcCartesianPointList3D::Class() { return *IfcCartesianPointList3D_type; }
IfcCartesianPointList3D::IfcCartesianPointList3D(IfcEntityInstanceData* e) : IfcCartesianPointList((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCartesianPointList3D_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCartesianPointList3D::IfcCartesianPointList3D(std::vector< std::vector< double > > v1_CoordList) : IfcCartesianPointList((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCartesianPointList3D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CoordList));data_->setArgument(0,attr);} }

// Function implementations for IfcCartesianTransformationOperator
bool IfcCartesianTransformationOperator::hasAxis1() const { return !data_->getArgument(0)->isNull(); }
IfcDirection* IfcCartesianTransformationOperator::Axis1() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcCartesianTransformationOperator::setAxis1(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcCartesianTransformationOperator::hasAxis2() const { return !data_->getArgument(1)->isNull(); }
IfcDirection* IfcCartesianTransformationOperator::Axis2() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcCartesianTransformationOperator::setAxis2(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcCartesianPoint* IfcCartesianTransformationOperator::LocalOrigin() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcCartesianTransformationOperator::setLocalOrigin(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcCartesianTransformationOperator::hasScale() const { return !data_->getArgument(3)->isNull(); }
double IfcCartesianTransformationOperator::Scale() const { return *data_->getArgument(3); }
void IfcCartesianTransformationOperator::setScale(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcCartesianTransformationOperator::declaration() const { return *IfcCartesianTransformationOperator_type; }
const IfcParse::entity& IfcCartesianTransformationOperator::Class() { return *IfcCartesianTransformationOperator_type; }
IfcCartesianTransformationOperator::IfcCartesianTransformationOperator(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCartesianTransformationOperator_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCartesianTransformationOperator::IfcCartesianTransformationOperator(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCartesianTransformationOperator_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcCartesianTransformationOperator2D


const IfcParse::entity& IfcCartesianTransformationOperator2D::declaration() const { return *IfcCartesianTransformationOperator2D_type; }
const IfcParse::entity& IfcCartesianTransformationOperator2D::Class() { return *IfcCartesianTransformationOperator2D_type; }
IfcCartesianTransformationOperator2D::IfcCartesianTransformationOperator2D(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCartesianTransformationOperator2D_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCartesianTransformationOperator2D::IfcCartesianTransformationOperator2D(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCartesianTransformationOperator2D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcCartesianTransformationOperator2DnonUniform
bool IfcCartesianTransformationOperator2DnonUniform::hasScale2() const { return !data_->getArgument(4)->isNull(); }
double IfcCartesianTransformationOperator2DnonUniform::Scale2() const { return *data_->getArgument(4); }
void IfcCartesianTransformationOperator2DnonUniform::setScale2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcCartesianTransformationOperator2DnonUniform::declaration() const { return *IfcCartesianTransformationOperator2DnonUniform_type; }
const IfcParse::entity& IfcCartesianTransformationOperator2DnonUniform::Class() { return *IfcCartesianTransformationOperator2DnonUniform_type; }
IfcCartesianTransformationOperator2DnonUniform::IfcCartesianTransformationOperator2DnonUniform(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator2D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCartesianTransformationOperator2DnonUniform_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCartesianTransformationOperator2DnonUniform::IfcCartesianTransformationOperator2DnonUniform(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, boost::optional< double > v5_Scale2) : IfcCartesianTransformationOperator2D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCartesianTransformationOperator2DnonUniform_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Scale2) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Scale2));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcCartesianTransformationOperator3D
bool IfcCartesianTransformationOperator3D::hasAxis3() const { return !data_->getArgument(4)->isNull(); }
IfcDirection* IfcCartesianTransformationOperator3D::Axis3() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcCartesianTransformationOperator3D::setAxis3(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcCartesianTransformationOperator3D::declaration() const { return *IfcCartesianTransformationOperator3D_type; }
const IfcParse::entity& IfcCartesianTransformationOperator3D::Class() { return *IfcCartesianTransformationOperator3D_type; }
IfcCartesianTransformationOperator3D::IfcCartesianTransformationOperator3D(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCartesianTransformationOperator3D_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCartesianTransformationOperator3D::IfcCartesianTransformationOperator3D(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCartesianTransformationOperator3D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Axis3));data_->setArgument(4,attr);} }

// Function implementations for IfcCartesianTransformationOperator3DnonUniform
bool IfcCartesianTransformationOperator3DnonUniform::hasScale2() const { return !data_->getArgument(5)->isNull(); }
double IfcCartesianTransformationOperator3DnonUniform::Scale2() const { return *data_->getArgument(5); }
void IfcCartesianTransformationOperator3DnonUniform::setScale2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcCartesianTransformationOperator3DnonUniform::hasScale3() const { return !data_->getArgument(6)->isNull(); }
double IfcCartesianTransformationOperator3DnonUniform::Scale3() const { return *data_->getArgument(6); }
void IfcCartesianTransformationOperator3DnonUniform::setScale3(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcCartesianTransformationOperator3DnonUniform::declaration() const { return *IfcCartesianTransformationOperator3DnonUniform_type; }
const IfcParse::entity& IfcCartesianTransformationOperator3DnonUniform::Class() { return *IfcCartesianTransformationOperator3DnonUniform_type; }
IfcCartesianTransformationOperator3DnonUniform::IfcCartesianTransformationOperator3DnonUniform(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCartesianTransformationOperator3DnonUniform_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCartesianTransformationOperator3DnonUniform::IfcCartesianTransformationOperator3DnonUniform(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3, boost::optional< double > v6_Scale2, boost::optional< double > v7_Scale3) : IfcCartesianTransformationOperator3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCartesianTransformationOperator3DnonUniform_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Axis3));data_->setArgument(4,attr);} if (v6_Scale2) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Scale2));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Scale3) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Scale3));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcCenterLineProfileDef
double IfcCenterLineProfileDef::Thickness() const { return *data_->getArgument(3); }
void IfcCenterLineProfileDef::setThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcCenterLineProfileDef::declaration() const { return *IfcCenterLineProfileDef_type; }
const IfcParse::entity& IfcCenterLineProfileDef::Class() { return *IfcCenterLineProfileDef_type; }
IfcCenterLineProfileDef::IfcCenterLineProfileDef(IfcEntityInstanceData* e) : IfcArbitraryOpenProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCenterLineProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCenterLineProfileDef::IfcCenterLineProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcBoundedCurve* v3_Curve, double v4_Thickness) : IfcArbitraryOpenProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCenterLineProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Curve));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Thickness));data_->setArgument(3,attr);} }

// Function implementations for IfcChiller
bool IfcChiller::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcChillerTypeEnum::IfcChillerTypeEnum IfcChiller::PredefinedType() const { return IfcChillerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcChiller::setPredefinedType(IfcChillerTypeEnum::IfcChillerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcChillerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcChiller::declaration() const { return *IfcChiller_type; }
const IfcParse::entity& IfcChiller::Class() { return *IfcChiller_type; }
IfcChiller::IfcChiller(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcChiller_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcChiller::IfcChiller(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcChillerTypeEnum::IfcChillerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcChiller_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcChillerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcChillerType
IfcChillerTypeEnum::IfcChillerTypeEnum IfcChillerType::PredefinedType() const { return IfcChillerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcChillerType::setPredefinedType(IfcChillerTypeEnum::IfcChillerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcChillerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcChillerType::declaration() const { return *IfcChillerType_type; }
const IfcParse::entity& IfcChillerType::Class() { return *IfcChillerType_type; }
IfcChillerType::IfcChillerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcChillerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcChillerType::IfcChillerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcChillerTypeEnum::IfcChillerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcChillerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcChillerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcChimney
bool IfcChimney::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcChimneyTypeEnum::IfcChimneyTypeEnum IfcChimney::PredefinedType() const { return IfcChimneyTypeEnum::FromString(*data_->getArgument(8)); }
void IfcChimney::setPredefinedType(IfcChimneyTypeEnum::IfcChimneyTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcChimneyTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcChimney::declaration() const { return *IfcChimney_type; }
const IfcParse::entity& IfcChimney::Class() { return *IfcChimney_type; }
IfcChimney::IfcChimney(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcChimney_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcChimney::IfcChimney(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcChimneyTypeEnum::IfcChimneyTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcChimney_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcChimneyTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcChimneyType
IfcChimneyTypeEnum::IfcChimneyTypeEnum IfcChimneyType::PredefinedType() const { return IfcChimneyTypeEnum::FromString(*data_->getArgument(9)); }
void IfcChimneyType::setPredefinedType(IfcChimneyTypeEnum::IfcChimneyTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcChimneyTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcChimneyType::declaration() const { return *IfcChimneyType_type; }
const IfcParse::entity& IfcChimneyType::Class() { return *IfcChimneyType_type; }
IfcChimneyType::IfcChimneyType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcChimneyType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcChimneyType::IfcChimneyType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcChimneyTypeEnum::IfcChimneyTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcChimneyType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcChimneyTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCircle
double IfcCircle::Radius() const { return *data_->getArgument(1); }
void IfcCircle::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcCircle::declaration() const { return *IfcCircle_type; }
const IfcParse::entity& IfcCircle::Class() { return *IfcCircle_type; }
IfcCircle::IfcCircle(IfcEntityInstanceData* e) : IfcConic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCircle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCircle::IfcCircle(IfcAxis2Placement* v1_Position, double v2_Radius) : IfcConic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCircle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));data_->setArgument(1,attr);} }

// Function implementations for IfcCircleHollowProfileDef
double IfcCircleHollowProfileDef::WallThickness() const { return *data_->getArgument(4); }
void IfcCircleHollowProfileDef::setWallThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcCircleHollowProfileDef::declaration() const { return *IfcCircleHollowProfileDef_type; }
const IfcParse::entity& IfcCircleHollowProfileDef::Class() { return *IfcCircleHollowProfileDef_type; }
IfcCircleHollowProfileDef::IfcCircleHollowProfileDef(IfcEntityInstanceData* e) : IfcCircleProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCircleHollowProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCircleHollowProfileDef::IfcCircleHollowProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Radius, double v5_WallThickness) : IfcCircleProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCircleHollowProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Radius));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_WallThickness));data_->setArgument(4,attr);} }

// Function implementations for IfcCircleProfileDef
double IfcCircleProfileDef::Radius() const { return *data_->getArgument(3); }
void IfcCircleProfileDef::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcCircleProfileDef::declaration() const { return *IfcCircleProfileDef_type; }
const IfcParse::entity& IfcCircleProfileDef::Class() { return *IfcCircleProfileDef_type; }
IfcCircleProfileDef::IfcCircleProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCircleProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCircleProfileDef::IfcCircleProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Radius) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCircleProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Radius));data_->setArgument(3,attr);} }

// Function implementations for IfcCivilElement


const IfcParse::entity& IfcCivilElement::declaration() const { return *IfcCivilElement_type; }
const IfcParse::entity& IfcCivilElement::Class() { return *IfcCivilElement_type; }
IfcCivilElement::IfcCivilElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCivilElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCivilElement::IfcCivilElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCivilElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcCivilElementType


const IfcParse::entity& IfcCivilElementType::declaration() const { return *IfcCivilElementType_type; }
const IfcParse::entity& IfcCivilElementType::Class() { return *IfcCivilElementType_type; }
IfcCivilElementType::IfcCivilElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCivilElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCivilElementType::IfcCivilElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCivilElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcClassification
bool IfcClassification::hasSource() const { return !data_->getArgument(0)->isNull(); }
std::string IfcClassification::Source() const { return *data_->getArgument(0); }
void IfcClassification::setSource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcClassification::hasEdition() const { return !data_->getArgument(1)->isNull(); }
std::string IfcClassification::Edition() const { return *data_->getArgument(1); }
void IfcClassification::setEdition(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcClassification::hasEditionDate() const { return !data_->getArgument(2)->isNull(); }
std::string IfcClassification::EditionDate() const { return *data_->getArgument(2); }
void IfcClassification::setEditionDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
std::string IfcClassification::Name() const { return *data_->getArgument(3); }
void IfcClassification::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcClassification::hasDescription() const { return !data_->getArgument(4)->isNull(); }
std::string IfcClassification::Description() const { return *data_->getArgument(4); }
void IfcClassification::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcClassification::hasLocation() const { return !data_->getArgument(5)->isNull(); }
std::string IfcClassification::Location() const { return *data_->getArgument(5); }
void IfcClassification::setLocation(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcClassification::hasReferenceTokens() const { return !data_->getArgument(6)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcClassification::ReferenceTokens() const { return *data_->getArgument(6); }
void IfcClassification::setReferenceTokens(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }

IfcRelAssociatesClassification::list::ptr IfcClassification::ClassificationForObjects() const { return data_->getInverse(IfcRelAssociatesClassification_type, 5)->as<IfcRelAssociatesClassification>(); }
IfcClassificationReference::list::ptr IfcClassification::HasReferences() const { return data_->getInverse(IfcClassificationReference_type, 3)->as<IfcClassificationReference>(); }

const IfcParse::entity& IfcClassification::declaration() const { return *IfcClassification_type; }
const IfcParse::entity& IfcClassification::Class() { return *IfcClassification_type; }
IfcClassification::IfcClassification(IfcEntityInstanceData* e) : IfcExternalInformation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcClassification_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcClassification::IfcClassification(boost::optional< std::string > v1_Source, boost::optional< std::string > v2_Edition, boost::optional< std::string > v3_EditionDate, std::string v4_Name, boost::optional< std::string > v5_Description, boost::optional< std::string > v6_Location, boost::optional< std::vector< std::string > /*[1:?]*/ > v7_ReferenceTokens) : IfcExternalInformation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcClassification_type);  if (v1_Source) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Source));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Edition) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Edition));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_EditionDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_EditionDate));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Name));data_->setArgument(3,attr);} if (v5_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Description));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Location));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ReferenceTokens) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ReferenceTokens));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcClassificationReference
bool IfcClassificationReference::hasReferencedSource() const { return !data_->getArgument(3)->isNull(); }
IfcClassificationReferenceSelect* IfcClassificationReference::ReferencedSource() const { return (IfcClassificationReferenceSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcClassificationReference::setReferencedSource(IfcClassificationReferenceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcClassificationReference::hasDescription() const { return !data_->getArgument(4)->isNull(); }
std::string IfcClassificationReference::Description() const { return *data_->getArgument(4); }
void IfcClassificationReference::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcClassificationReference::hasSort() const { return !data_->getArgument(5)->isNull(); }
std::string IfcClassificationReference::Sort() const { return *data_->getArgument(5); }
void IfcClassificationReference::setSort(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

IfcRelAssociatesClassification::list::ptr IfcClassificationReference::ClassificationRefForObjects() const { return data_->getInverse(IfcRelAssociatesClassification_type, 5)->as<IfcRelAssociatesClassification>(); }
IfcClassificationReference::list::ptr IfcClassificationReference::HasReferences() const { return data_->getInverse(IfcClassificationReference_type, 3)->as<IfcClassificationReference>(); }

const IfcParse::entity& IfcClassificationReference::declaration() const { return *IfcClassificationReference_type; }
const IfcParse::entity& IfcClassificationReference::Class() { return *IfcClassificationReference_type; }
IfcClassificationReference::IfcClassificationReference(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcClassificationReference_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcClassificationReference::IfcClassificationReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name, IfcClassificationReferenceSelect* v4_ReferencedSource, boost::optional< std::string > v5_Description, boost::optional< std::string > v6_Sort) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcClassificationReference_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Identification));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ReferencedSource));data_->setArgument(3,attr);} if (v5_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Description));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Sort) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Sort));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcClosedShell


const IfcParse::entity& IfcClosedShell::declaration() const { return *IfcClosedShell_type; }
const IfcParse::entity& IfcClosedShell::Class() { return *IfcClosedShell_type; }
IfcClosedShell::IfcClosedShell(IfcEntityInstanceData* e) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcClosedShell_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcClosedShell::IfcClosedShell(IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcClosedShell_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CfsFaces)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcCoil
bool IfcCoil::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCoilTypeEnum::IfcCoilTypeEnum IfcCoil::PredefinedType() const { return IfcCoilTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCoil::setPredefinedType(IfcCoilTypeEnum::IfcCoilTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoilTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCoil::declaration() const { return *IfcCoil_type; }
const IfcParse::entity& IfcCoil::Class() { return *IfcCoil_type; }
IfcCoil::IfcCoil(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCoil_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCoil::IfcCoil(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCoilTypeEnum::IfcCoilTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCoil_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCoilTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCoilType
IfcCoilTypeEnum::IfcCoilTypeEnum IfcCoilType::PredefinedType() const { return IfcCoilTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCoilType::setPredefinedType(IfcCoilTypeEnum::IfcCoilTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoilTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCoilType::declaration() const { return *IfcCoilType_type; }
const IfcParse::entity& IfcCoilType::Class() { return *IfcCoilType_type; }
IfcCoilType::IfcCoilType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCoilType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCoilType::IfcCoilType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoilTypeEnum::IfcCoilTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCoilType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCoilTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcColourRgb
double IfcColourRgb::Red() const { return *data_->getArgument(1); }
void IfcColourRgb::setRed(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcColourRgb::Green() const { return *data_->getArgument(2); }
void IfcColourRgb::setGreen(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double IfcColourRgb::Blue() const { return *data_->getArgument(3); }
void IfcColourRgb::setBlue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcColourRgb::declaration() const { return *IfcColourRgb_type; }
const IfcParse::entity& IfcColourRgb::Class() { return *IfcColourRgb_type; }
IfcColourRgb::IfcColourRgb(IfcEntityInstanceData* e) : IfcColourSpecification((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcColourRgb_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcColourRgb::IfcColourRgb(boost::optional< std::string > v1_Name, double v2_Red, double v3_Green, double v4_Blue) : IfcColourSpecification((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcColourRgb_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Red));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Green));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Blue));data_->setArgument(3,attr);} }

// Function implementations for IfcColourRgbList
std::vector< std::vector< double > > IfcColourRgbList::ColourList() const { return *data_->getArgument(0); }
void IfcColourRgbList::setColourList(std::vector< std::vector< double > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcColourRgbList::declaration() const { return *IfcColourRgbList_type; }
const IfcParse::entity& IfcColourRgbList::Class() { return *IfcColourRgbList_type; }
IfcColourRgbList::IfcColourRgbList(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcColourRgbList_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcColourRgbList::IfcColourRgbList(std::vector< std::vector< double > > v1_ColourList) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcColourRgbList_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ColourList));data_->setArgument(0,attr);} }

// Function implementations for IfcColourSpecification
bool IfcColourSpecification::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcColourSpecification::Name() const { return *data_->getArgument(0); }
void IfcColourSpecification::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcColourSpecification::declaration() const { return *IfcColourSpecification_type; }
const IfcParse::entity& IfcColourSpecification::Class() { return *IfcColourSpecification_type; }
IfcColourSpecification::IfcColourSpecification(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcColourSpecification_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcColourSpecification::IfcColourSpecification(boost::optional< std::string > v1_Name) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcColourSpecification_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcColumn
bool IfcColumn::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcColumnTypeEnum::IfcColumnTypeEnum IfcColumn::PredefinedType() const { return IfcColumnTypeEnum::FromString(*data_->getArgument(8)); }
void IfcColumn::setPredefinedType(IfcColumnTypeEnum::IfcColumnTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcColumnTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcColumn::declaration() const { return *IfcColumn_type; }
const IfcParse::entity& IfcColumn::Class() { return *IfcColumn_type; }
IfcColumn::IfcColumn(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcColumn_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcColumn::IfcColumn(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcColumnTypeEnum::IfcColumnTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcColumn_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcColumnTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcColumnStandardCase


const IfcParse::entity& IfcColumnStandardCase::declaration() const { return *IfcColumnStandardCase_type; }
const IfcParse::entity& IfcColumnStandardCase::Class() { return *IfcColumnStandardCase_type; }
IfcColumnStandardCase::IfcColumnStandardCase(IfcEntityInstanceData* e) : IfcColumn((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcColumnStandardCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcColumnStandardCase::IfcColumnStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcColumnTypeEnum::IfcColumnTypeEnum > v9_PredefinedType) : IfcColumn((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcColumnStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcColumnTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcColumnType
IfcColumnTypeEnum::IfcColumnTypeEnum IfcColumnType::PredefinedType() const { return IfcColumnTypeEnum::FromString(*data_->getArgument(9)); }
void IfcColumnType::setPredefinedType(IfcColumnTypeEnum::IfcColumnTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcColumnTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcColumnType::declaration() const { return *IfcColumnType_type; }
const IfcParse::entity& IfcColumnType::Class() { return *IfcColumnType_type; }
IfcColumnType::IfcColumnType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcColumnType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcColumnType::IfcColumnType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcColumnTypeEnum::IfcColumnTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcColumnType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcColumnTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCommunicationsAppliance
bool IfcCommunicationsAppliance::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum IfcCommunicationsAppliance::PredefinedType() const { return IfcCommunicationsApplianceTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCommunicationsAppliance::setPredefinedType(IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCommunicationsApplianceTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCommunicationsAppliance::declaration() const { return *IfcCommunicationsAppliance_type; }
const IfcParse::entity& IfcCommunicationsAppliance::Class() { return *IfcCommunicationsAppliance_type; }
IfcCommunicationsAppliance::IfcCommunicationsAppliance(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCommunicationsAppliance_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCommunicationsAppliance::IfcCommunicationsAppliance(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCommunicationsAppliance_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCommunicationsApplianceTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCommunicationsApplianceType
IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum IfcCommunicationsApplianceType::PredefinedType() const { return IfcCommunicationsApplianceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCommunicationsApplianceType::setPredefinedType(IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCommunicationsApplianceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCommunicationsApplianceType::declaration() const { return *IfcCommunicationsApplianceType_type; }
const IfcParse::entity& IfcCommunicationsApplianceType::Class() { return *IfcCommunicationsApplianceType_type; }
IfcCommunicationsApplianceType::IfcCommunicationsApplianceType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCommunicationsApplianceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCommunicationsApplianceType::IfcCommunicationsApplianceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCommunicationsApplianceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCommunicationsApplianceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcComplexProperty
std::string IfcComplexProperty::UsageName() const { return *data_->getArgument(2); }
void IfcComplexProperty::setUsageName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcProperty >::ptr IfcComplexProperty::HasProperties() const { IfcEntityList::ptr es = *data_->getArgument(3); return es->as<IfcProperty>(); }
void IfcComplexProperty::setHasProperties(IfcTemplatedEntityList< IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(3,attr);} }


const IfcParse::entity& IfcComplexProperty::declaration() const { return *IfcComplexProperty_type; }
const IfcParse::entity& IfcComplexProperty::Class() { return *IfcComplexProperty_type; }
IfcComplexProperty::IfcComplexProperty(IfcEntityInstanceData* e) : IfcProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcComplexProperty_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcComplexProperty::IfcComplexProperty(std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_UsageName, IfcTemplatedEntityList< IfcProperty >::ptr v4_HasProperties) : IfcProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcComplexProperty_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_UsageName));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_HasProperties)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcComplexPropertyTemplate
bool IfcComplexPropertyTemplate::hasUsageName() const { return !data_->getArgument(4)->isNull(); }
std::string IfcComplexPropertyTemplate::UsageName() const { return *data_->getArgument(4); }
void IfcComplexPropertyTemplate::setUsageName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcComplexPropertyTemplate::hasTemplateType() const { return !data_->getArgument(5)->isNull(); }
IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum IfcComplexPropertyTemplate::TemplateType() const { return IfcComplexPropertyTemplateTypeEnum::FromString(*data_->getArgument(5)); }
void IfcComplexPropertyTemplate::setTemplateType(IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcComplexPropertyTemplateTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
bool IfcComplexPropertyTemplate::hasHasPropertyTemplates() const { return !data_->getArgument(6)->isNull(); }
IfcTemplatedEntityList< IfcPropertyTemplate >::ptr IfcComplexPropertyTemplate::HasPropertyTemplates() const { IfcEntityList::ptr es = *data_->getArgument(6); return es->as<IfcPropertyTemplate>(); }
void IfcComplexPropertyTemplate::setHasPropertyTemplates(IfcTemplatedEntityList< IfcPropertyTemplate >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(6,attr);} }


const IfcParse::entity& IfcComplexPropertyTemplate::declaration() const { return *IfcComplexPropertyTemplate_type; }
const IfcParse::entity& IfcComplexPropertyTemplate::Class() { return *IfcComplexPropertyTemplate_type; }
IfcComplexPropertyTemplate::IfcComplexPropertyTemplate(IfcEntityInstanceData* e) : IfcPropertyTemplate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcComplexPropertyTemplate_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcComplexPropertyTemplate::IfcComplexPropertyTemplate(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_UsageName, boost::optional< IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum > v6_TemplateType, boost::optional< IfcTemplatedEntityList< IfcPropertyTemplate >::ptr > v7_HasPropertyTemplates) : IfcPropertyTemplate((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcComplexPropertyTemplate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_UsageName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_UsageName));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_TemplateType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_TemplateType,IfcComplexPropertyTemplateTypeEnum::ToString(*v6_TemplateType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_HasPropertyTemplates) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_HasPropertyTemplates)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcCompositeCurve
IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr IfcCompositeCurve::Segments() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcCompositeCurveSegment>(); }
void IfcCompositeCurve::setSegments(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }
bool IfcCompositeCurve::SelfIntersect() const { return *data_->getArgument(1); }
void IfcCompositeCurve::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcCompositeCurve::declaration() const { return *IfcCompositeCurve_type; }
const IfcParse::entity& IfcCompositeCurve::Class() { return *IfcCompositeCurve_type; }
IfcCompositeCurve::IfcCompositeCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCompositeCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCompositeCurve::IfcCompositeCurve(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect) : IfcBoundedCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCompositeCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Segments)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SelfIntersect));data_->setArgument(1,attr);} }

// Function implementations for IfcCompositeCurveOnSurface


const IfcParse::entity& IfcCompositeCurveOnSurface::declaration() const { return *IfcCompositeCurveOnSurface_type; }
const IfcParse::entity& IfcCompositeCurveOnSurface::Class() { return *IfcCompositeCurveOnSurface_type; }
IfcCompositeCurveOnSurface::IfcCompositeCurveOnSurface(IfcEntityInstanceData* e) : IfcCompositeCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCompositeCurveOnSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCompositeCurveOnSurface::IfcCompositeCurveOnSurface(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect) : IfcCompositeCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCompositeCurveOnSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Segments)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SelfIntersect));data_->setArgument(1,attr);} }

// Function implementations for IfcCompositeCurveSegment
IfcTransitionCode::IfcTransitionCode IfcCompositeCurveSegment::Transition() const { return IfcTransitionCode::FromString(*data_->getArgument(0)); }
void IfcCompositeCurveSegment::setTransition(IfcTransitionCode::IfcTransitionCode v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTransitionCode::ToString(v)));data_->setArgument(0,attr);} }
bool IfcCompositeCurveSegment::SameSense() const { return *data_->getArgument(1); }
void IfcCompositeCurveSegment::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcCurve* IfcCompositeCurveSegment::ParentCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcCompositeCurveSegment::setParentCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

IfcCompositeCurve::list::ptr IfcCompositeCurveSegment::UsingCurves() const { return data_->getInverse(IfcCompositeCurve_type, 0)->as<IfcCompositeCurve>(); }

const IfcParse::entity& IfcCompositeCurveSegment::declaration() const { return *IfcCompositeCurveSegment_type; }
const IfcParse::entity& IfcCompositeCurveSegment::Class() { return *IfcCompositeCurveSegment_type; }
IfcCompositeCurveSegment::IfcCompositeCurveSegment(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCompositeCurveSegment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCompositeCurveSegment::IfcCompositeCurveSegment(IfcTransitionCode::IfcTransitionCode v1_Transition, bool v2_SameSense, IfcCurve* v3_ParentCurve) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCompositeCurveSegment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Transition,IfcTransitionCode::ToString(v1_Transition))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SameSense));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentCurve));data_->setArgument(2,attr);} }

// Function implementations for IfcCompositeProfileDef
IfcTemplatedEntityList< IfcProfileDef >::ptr IfcCompositeProfileDef::Profiles() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcProfileDef>(); }
void IfcCompositeProfileDef::setProfiles(IfcTemplatedEntityList< IfcProfileDef >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }
bool IfcCompositeProfileDef::hasLabel() const { return !data_->getArgument(3)->isNull(); }
std::string IfcCompositeProfileDef::Label() const { return *data_->getArgument(3); }
void IfcCompositeProfileDef::setLabel(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcCompositeProfileDef::declaration() const { return *IfcCompositeProfileDef_type; }
const IfcParse::entity& IfcCompositeProfileDef::Class() { return *IfcCompositeProfileDef_type; }
IfcCompositeProfileDef::IfcCompositeProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCompositeProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCompositeProfileDef::IfcCompositeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcTemplatedEntityList< IfcProfileDef >::ptr v3_Profiles, boost::optional< std::string > v4_Label) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCompositeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Profiles)->generalize());data_->setArgument(2,attr);} if (v4_Label) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Label));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcCompressor
bool IfcCompressor::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCompressorTypeEnum::IfcCompressorTypeEnum IfcCompressor::PredefinedType() const { return IfcCompressorTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCompressor::setPredefinedType(IfcCompressorTypeEnum::IfcCompressorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCompressorTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCompressor::declaration() const { return *IfcCompressor_type; }
const IfcParse::entity& IfcCompressor::Class() { return *IfcCompressor_type; }
IfcCompressor::IfcCompressor(IfcEntityInstanceData* e) : IfcFlowMovingDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCompressor_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCompressor::IfcCompressor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCompressorTypeEnum::IfcCompressorTypeEnum > v9_PredefinedType) : IfcFlowMovingDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCompressor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCompressorTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCompressorType
IfcCompressorTypeEnum::IfcCompressorTypeEnum IfcCompressorType::PredefinedType() const { return IfcCompressorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCompressorType::setPredefinedType(IfcCompressorTypeEnum::IfcCompressorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCompressorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCompressorType::declaration() const { return *IfcCompressorType_type; }
const IfcParse::entity& IfcCompressorType::Class() { return *IfcCompressorType_type; }
IfcCompressorType::IfcCompressorType(IfcEntityInstanceData* e) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCompressorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCompressorType::IfcCompressorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCompressorTypeEnum::IfcCompressorTypeEnum v10_PredefinedType) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCompressorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCompressorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCondenser
bool IfcCondenser::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCondenserTypeEnum::IfcCondenserTypeEnum IfcCondenser::PredefinedType() const { return IfcCondenserTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCondenser::setPredefinedType(IfcCondenserTypeEnum::IfcCondenserTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCondenserTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCondenser::declaration() const { return *IfcCondenser_type; }
const IfcParse::entity& IfcCondenser::Class() { return *IfcCondenser_type; }
IfcCondenser::IfcCondenser(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCondenser_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCondenser::IfcCondenser(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCondenserTypeEnum::IfcCondenserTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCondenser_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCondenserTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCondenserType
IfcCondenserTypeEnum::IfcCondenserTypeEnum IfcCondenserType::PredefinedType() const { return IfcCondenserTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCondenserType::setPredefinedType(IfcCondenserTypeEnum::IfcCondenserTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCondenserTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCondenserType::declaration() const { return *IfcCondenserType_type; }
const IfcParse::entity& IfcCondenserType::Class() { return *IfcCondenserType_type; }
IfcCondenserType::IfcCondenserType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCondenserType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCondenserType::IfcCondenserType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCondenserTypeEnum::IfcCondenserTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCondenserType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCondenserTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcConic
IfcAxis2Placement* IfcConic::Position() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcConic::setPosition(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcConic::declaration() const { return *IfcConic_type; }
const IfcParse::entity& IfcConic::Class() { return *IfcConic_type; }
IfcConic::IfcConic(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConic_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConic::IfcConic(IfcAxis2Placement* v1_Position) : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConic_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);} }

// Function implementations for IfcConnectedFaceSet
IfcTemplatedEntityList< IfcFace >::ptr IfcConnectedFaceSet::CfsFaces() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcFace>(); }
void IfcConnectedFaceSet::setCfsFaces(IfcTemplatedEntityList< IfcFace >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& IfcConnectedFaceSet::declaration() const { return *IfcConnectedFaceSet_type; }
const IfcParse::entity& IfcConnectedFaceSet::Class() { return *IfcConnectedFaceSet_type; }
IfcConnectedFaceSet::IfcConnectedFaceSet(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConnectedFaceSet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConnectedFaceSet::IfcConnectedFaceSet(IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConnectedFaceSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CfsFaces)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcConnectionCurveGeometry
IfcCurveOrEdgeCurve* IfcConnectionCurveGeometry::CurveOnRelatingElement() const { return (IfcCurveOrEdgeCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcConnectionCurveGeometry::setCurveOnRelatingElement(IfcCurveOrEdgeCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcConnectionCurveGeometry::hasCurveOnRelatedElement() const { return !data_->getArgument(1)->isNull(); }
IfcCurveOrEdgeCurve* IfcConnectionCurveGeometry::CurveOnRelatedElement() const { return (IfcCurveOrEdgeCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcConnectionCurveGeometry::setCurveOnRelatedElement(IfcCurveOrEdgeCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcConnectionCurveGeometry::declaration() const { return *IfcConnectionCurveGeometry_type; }
const IfcParse::entity& IfcConnectionCurveGeometry::Class() { return *IfcConnectionCurveGeometry_type; }
IfcConnectionCurveGeometry::IfcConnectionCurveGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConnectionCurveGeometry_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConnectionCurveGeometry::IfcConnectionCurveGeometry(IfcCurveOrEdgeCurve* v1_CurveOnRelatingElement, IfcCurveOrEdgeCurve* v2_CurveOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConnectionCurveGeometry_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CurveOnRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CurveOnRelatedElement));data_->setArgument(1,attr);} }

// Function implementations for IfcConnectionGeometry


const IfcParse::entity& IfcConnectionGeometry::declaration() const { return *IfcConnectionGeometry_type; }
const IfcParse::entity& IfcConnectionGeometry::Class() { return *IfcConnectionGeometry_type; }
IfcConnectionGeometry::IfcConnectionGeometry(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcConnectionGeometry_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConnectionGeometry::IfcConnectionGeometry() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcConnectionGeometry_type);  }

// Function implementations for IfcConnectionPointEccentricity
bool IfcConnectionPointEccentricity::hasEccentricityInX() const { return !data_->getArgument(2)->isNull(); }
double IfcConnectionPointEccentricity::EccentricityInX() const { return *data_->getArgument(2); }
void IfcConnectionPointEccentricity::setEccentricityInX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcConnectionPointEccentricity::hasEccentricityInY() const { return !data_->getArgument(3)->isNull(); }
double IfcConnectionPointEccentricity::EccentricityInY() const { return *data_->getArgument(3); }
void IfcConnectionPointEccentricity::setEccentricityInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcConnectionPointEccentricity::hasEccentricityInZ() const { return !data_->getArgument(4)->isNull(); }
double IfcConnectionPointEccentricity::EccentricityInZ() const { return *data_->getArgument(4); }
void IfcConnectionPointEccentricity::setEccentricityInZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcConnectionPointEccentricity::declaration() const { return *IfcConnectionPointEccentricity_type; }
const IfcParse::entity& IfcConnectionPointEccentricity::Class() { return *IfcConnectionPointEccentricity_type; }
IfcConnectionPointEccentricity::IfcConnectionPointEccentricity(IfcEntityInstanceData* e) : IfcConnectionPointGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConnectionPointEccentricity_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConnectionPointEccentricity::IfcConnectionPointEccentricity(IfcPointOrVertexPoint* v1_PointOnRelatingElement, IfcPointOrVertexPoint* v2_PointOnRelatedElement, boost::optional< double > v3_EccentricityInX, boost::optional< double > v4_EccentricityInY, boost::optional< double > v5_EccentricityInZ) : IfcConnectionPointGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConnectionPointEccentricity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PointOnRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointOnRelatedElement));data_->setArgument(1,attr);} if (v3_EccentricityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_EccentricityInX));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_EccentricityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_EccentricityInY));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_EccentricityInZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_EccentricityInZ));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcConnectionPointGeometry
IfcPointOrVertexPoint* IfcConnectionPointGeometry::PointOnRelatingElement() const { return (IfcPointOrVertexPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcConnectionPointGeometry::setPointOnRelatingElement(IfcPointOrVertexPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcConnectionPointGeometry::hasPointOnRelatedElement() const { return !data_->getArgument(1)->isNull(); }
IfcPointOrVertexPoint* IfcConnectionPointGeometry::PointOnRelatedElement() const { return (IfcPointOrVertexPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcConnectionPointGeometry::setPointOnRelatedElement(IfcPointOrVertexPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcConnectionPointGeometry::declaration() const { return *IfcConnectionPointGeometry_type; }
const IfcParse::entity& IfcConnectionPointGeometry::Class() { return *IfcConnectionPointGeometry_type; }
IfcConnectionPointGeometry::IfcConnectionPointGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConnectionPointGeometry_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConnectionPointGeometry::IfcConnectionPointGeometry(IfcPointOrVertexPoint* v1_PointOnRelatingElement, IfcPointOrVertexPoint* v2_PointOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConnectionPointGeometry_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PointOnRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointOnRelatedElement));data_->setArgument(1,attr);} }

// Function implementations for IfcConnectionSurfaceGeometry
IfcSurfaceOrFaceSurface* IfcConnectionSurfaceGeometry::SurfaceOnRelatingElement() const { return (IfcSurfaceOrFaceSurface*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcConnectionSurfaceGeometry::setSurfaceOnRelatingElement(IfcSurfaceOrFaceSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcConnectionSurfaceGeometry::hasSurfaceOnRelatedElement() const { return !data_->getArgument(1)->isNull(); }
IfcSurfaceOrFaceSurface* IfcConnectionSurfaceGeometry::SurfaceOnRelatedElement() const { return (IfcSurfaceOrFaceSurface*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcConnectionSurfaceGeometry::setSurfaceOnRelatedElement(IfcSurfaceOrFaceSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcConnectionSurfaceGeometry::declaration() const { return *IfcConnectionSurfaceGeometry_type; }
const IfcParse::entity& IfcConnectionSurfaceGeometry::Class() { return *IfcConnectionSurfaceGeometry_type; }
IfcConnectionSurfaceGeometry::IfcConnectionSurfaceGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConnectionSurfaceGeometry_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConnectionSurfaceGeometry::IfcConnectionSurfaceGeometry(IfcSurfaceOrFaceSurface* v1_SurfaceOnRelatingElement, IfcSurfaceOrFaceSurface* v2_SurfaceOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConnectionSurfaceGeometry_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SurfaceOnRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SurfaceOnRelatedElement));data_->setArgument(1,attr);} }

// Function implementations for IfcConnectionVolumeGeometry
IfcSolidOrShell* IfcConnectionVolumeGeometry::VolumeOnRelatingElement() const { return (IfcSolidOrShell*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcConnectionVolumeGeometry::setVolumeOnRelatingElement(IfcSolidOrShell* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcConnectionVolumeGeometry::hasVolumeOnRelatedElement() const { return !data_->getArgument(1)->isNull(); }
IfcSolidOrShell* IfcConnectionVolumeGeometry::VolumeOnRelatedElement() const { return (IfcSolidOrShell*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcConnectionVolumeGeometry::setVolumeOnRelatedElement(IfcSolidOrShell* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcConnectionVolumeGeometry::declaration() const { return *IfcConnectionVolumeGeometry_type; }
const IfcParse::entity& IfcConnectionVolumeGeometry::Class() { return *IfcConnectionVolumeGeometry_type; }
IfcConnectionVolumeGeometry::IfcConnectionVolumeGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConnectionVolumeGeometry_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConnectionVolumeGeometry::IfcConnectionVolumeGeometry(IfcSolidOrShell* v1_VolumeOnRelatingElement, IfcSolidOrShell* v2_VolumeOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConnectionVolumeGeometry_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_VolumeOnRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_VolumeOnRelatedElement));data_->setArgument(1,attr);} }

// Function implementations for IfcConstraint
std::string IfcConstraint::Name() const { return *data_->getArgument(0); }
void IfcConstraint::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcConstraint::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcConstraint::Description() const { return *data_->getArgument(1); }
void IfcConstraint::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcConstraintEnum::IfcConstraintEnum IfcConstraint::ConstraintGrade() const { return IfcConstraintEnum::FromString(*data_->getArgument(2)); }
void IfcConstraint::setConstraintGrade(IfcConstraintEnum::IfcConstraintEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConstraintEnum::ToString(v)));data_->setArgument(2,attr);} }
bool IfcConstraint::hasConstraintSource() const { return !data_->getArgument(3)->isNull(); }
std::string IfcConstraint::ConstraintSource() const { return *data_->getArgument(3); }
void IfcConstraint::setConstraintSource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcConstraint::hasCreatingActor() const { return !data_->getArgument(4)->isNull(); }
IfcActorSelect* IfcConstraint::CreatingActor() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcConstraint::setCreatingActor(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcConstraint::hasCreationTime() const { return !data_->getArgument(5)->isNull(); }
std::string IfcConstraint::CreationTime() const { return *data_->getArgument(5); }
void IfcConstraint::setCreationTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcConstraint::hasUserDefinedGrade() const { return !data_->getArgument(6)->isNull(); }
std::string IfcConstraint::UserDefinedGrade() const { return *data_->getArgument(6); }
void IfcConstraint::setUserDefinedGrade(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcConstraint::HasExternalReferences() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }
IfcResourceConstraintRelationship::list::ptr IfcConstraint::PropertiesForConstraint() const { return data_->getInverse(IfcResourceConstraintRelationship_type, 2)->as<IfcResourceConstraintRelationship>(); }

const IfcParse::entity& IfcConstraint::declaration() const { return *IfcConstraint_type; }
const IfcParse::entity& IfcConstraint::Class() { return *IfcConstraint_type; }
IfcConstraint::IfcConstraint(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcConstraint_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConstraint::IfcConstraint(std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, boost::optional< std::string > v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcConstraint_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ConstraintGrade,IfcConstraintEnum::ToString(v3_ConstraintGrade))));data_->setArgument(2,attr);} if (v4_ConstraintSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ConstraintSource));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CreatingActor));data_->setArgument(4,attr);} if (v6_CreationTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_CreationTime));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_UserDefinedGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedGrade));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcConstructionEquipmentResource
bool IfcConstructionEquipmentResource::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum IfcConstructionEquipmentResource::PredefinedType() const { return IfcConstructionEquipmentResourceTypeEnum::FromString(*data_->getArgument(10)); }
void IfcConstructionEquipmentResource::setPredefinedType(IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConstructionEquipmentResourceTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& IfcConstructionEquipmentResource::declaration() const { return *IfcConstructionEquipmentResource_type; }
const IfcParse::entity& IfcConstructionEquipmentResource::Class() { return *IfcConstructionEquipmentResource_type; }
IfcConstructionEquipmentResource::IfcConstructionEquipmentResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConstructionEquipmentResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConstructionEquipmentResource::IfcConstructionEquipmentResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConstructionEquipmentResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Usage));data_->setArgument(7,attr);} if (v9_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_BaseCosts)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_BaseQuantity));data_->setArgument(9,attr);} if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcConstructionEquipmentResourceTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcConstructionEquipmentResourceType
IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum IfcConstructionEquipmentResourceType::PredefinedType() const { return IfcConstructionEquipmentResourceTypeEnum::FromString(*data_->getArgument(11)); }
void IfcConstructionEquipmentResourceType::setPredefinedType(IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConstructionEquipmentResourceTypeEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcConstructionEquipmentResourceType::declaration() const { return *IfcConstructionEquipmentResourceType_type; }
const IfcParse::entity& IfcConstructionEquipmentResourceType::Class() { return *IfcConstructionEquipmentResourceType_type; }
IfcConstructionEquipmentResourceType::IfcConstructionEquipmentResourceType(IfcEntityInstanceData* e) : IfcConstructionResourceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConstructionEquipmentResourceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConstructionEquipmentResourceType::IfcConstructionEquipmentResourceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConstructionEquipmentResourceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ResourceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ResourceType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_BaseCosts)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseQuantity));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcConstructionEquipmentResourceTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcConstructionMaterialResource
bool IfcConstructionMaterialResource::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum IfcConstructionMaterialResource::PredefinedType() const { return IfcConstructionMaterialResourceTypeEnum::FromString(*data_->getArgument(10)); }
void IfcConstructionMaterialResource::setPredefinedType(IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConstructionMaterialResourceTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& IfcConstructionMaterialResource::declaration() const { return *IfcConstructionMaterialResource_type; }
const IfcParse::entity& IfcConstructionMaterialResource::Class() { return *IfcConstructionMaterialResource_type; }
IfcConstructionMaterialResource::IfcConstructionMaterialResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConstructionMaterialResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConstructionMaterialResource::IfcConstructionMaterialResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConstructionMaterialResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Usage));data_->setArgument(7,attr);} if (v9_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_BaseCosts)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_BaseQuantity));data_->setArgument(9,attr);} if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcConstructionMaterialResourceTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcConstructionMaterialResourceType
IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum IfcConstructionMaterialResourceType::PredefinedType() const { return IfcConstructionMaterialResourceTypeEnum::FromString(*data_->getArgument(11)); }
void IfcConstructionMaterialResourceType::setPredefinedType(IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConstructionMaterialResourceTypeEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcConstructionMaterialResourceType::declaration() const { return *IfcConstructionMaterialResourceType_type; }
const IfcParse::entity& IfcConstructionMaterialResourceType::Class() { return *IfcConstructionMaterialResourceType_type; }
IfcConstructionMaterialResourceType::IfcConstructionMaterialResourceType(IfcEntityInstanceData* e) : IfcConstructionResourceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConstructionMaterialResourceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConstructionMaterialResourceType::IfcConstructionMaterialResourceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConstructionMaterialResourceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ResourceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ResourceType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_BaseCosts)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseQuantity));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcConstructionMaterialResourceTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcConstructionProductResource
bool IfcConstructionProductResource::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum IfcConstructionProductResource::PredefinedType() const { return IfcConstructionProductResourceTypeEnum::FromString(*data_->getArgument(10)); }
void IfcConstructionProductResource::setPredefinedType(IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConstructionProductResourceTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& IfcConstructionProductResource::declaration() const { return *IfcConstructionProductResource_type; }
const IfcParse::entity& IfcConstructionProductResource::Class() { return *IfcConstructionProductResource_type; }
IfcConstructionProductResource::IfcConstructionProductResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConstructionProductResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConstructionProductResource::IfcConstructionProductResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConstructionProductResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Usage));data_->setArgument(7,attr);} if (v9_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_BaseCosts)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_BaseQuantity));data_->setArgument(9,attr);} if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcConstructionProductResourceTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcConstructionProductResourceType
IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum IfcConstructionProductResourceType::PredefinedType() const { return IfcConstructionProductResourceTypeEnum::FromString(*data_->getArgument(11)); }
void IfcConstructionProductResourceType::setPredefinedType(IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConstructionProductResourceTypeEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcConstructionProductResourceType::declaration() const { return *IfcConstructionProductResourceType_type; }
const IfcParse::entity& IfcConstructionProductResourceType::Class() { return *IfcConstructionProductResourceType_type; }
IfcConstructionProductResourceType::IfcConstructionProductResourceType(IfcEntityInstanceData* e) : IfcConstructionResourceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConstructionProductResourceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConstructionProductResourceType::IfcConstructionProductResourceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConstructionProductResourceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ResourceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ResourceType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_BaseCosts)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseQuantity));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcConstructionProductResourceTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcConstructionResource
bool IfcConstructionResource::hasUsage() const { return !data_->getArgument(7)->isNull(); }
IfcResourceTime* IfcConstructionResource::Usage() const { return (IfcResourceTime*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcConstructionResource::setUsage(IfcResourceTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcConstructionResource::hasBaseCosts() const { return !data_->getArgument(8)->isNull(); }
IfcTemplatedEntityList< IfcAppliedValue >::ptr IfcConstructionResource::BaseCosts() const { IfcEntityList::ptr es = *data_->getArgument(8); return es->as<IfcAppliedValue>(); }
void IfcConstructionResource::setBaseCosts(IfcTemplatedEntityList< IfcAppliedValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(8,attr);} }
bool IfcConstructionResource::hasBaseQuantity() const { return !data_->getArgument(9)->isNull(); }
IfcPhysicalQuantity* IfcConstructionResource::BaseQuantity() const { return (IfcPhysicalQuantity*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcConstructionResource::setBaseQuantity(IfcPhysicalQuantity* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcConstructionResource::declaration() const { return *IfcConstructionResource_type; }
const IfcParse::entity& IfcConstructionResource::Class() { return *IfcConstructionResource_type; }
IfcConstructionResource::IfcConstructionResource(IfcEntityInstanceData* e) : IfcResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConstructionResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConstructionResource::IfcConstructionResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity) : IfcResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConstructionResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Usage));data_->setArgument(7,attr);} if (v9_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_BaseCosts)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_BaseQuantity));data_->setArgument(9,attr);} }

// Function implementations for IfcConstructionResourceType
bool IfcConstructionResourceType::hasBaseCosts() const { return !data_->getArgument(9)->isNull(); }
IfcTemplatedEntityList< IfcAppliedValue >::ptr IfcConstructionResourceType::BaseCosts() const { IfcEntityList::ptr es = *data_->getArgument(9); return es->as<IfcAppliedValue>(); }
void IfcConstructionResourceType::setBaseCosts(IfcTemplatedEntityList< IfcAppliedValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(9,attr);} }
bool IfcConstructionResourceType::hasBaseQuantity() const { return !data_->getArgument(10)->isNull(); }
IfcPhysicalQuantity* IfcConstructionResourceType::BaseQuantity() const { return (IfcPhysicalQuantity*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(10))); }
void IfcConstructionResourceType::setBaseQuantity(IfcPhysicalQuantity* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcConstructionResourceType::declaration() const { return *IfcConstructionResourceType_type; }
const IfcParse::entity& IfcConstructionResourceType::Class() { return *IfcConstructionResourceType_type; }
IfcConstructionResourceType::IfcConstructionResourceType(IfcEntityInstanceData* e) : IfcTypeResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConstructionResourceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConstructionResourceType::IfcConstructionResourceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity) : IfcTypeResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConstructionResourceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ResourceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ResourceType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_BaseCosts)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseQuantity));data_->setArgument(10,attr);} }

// Function implementations for IfcContext
bool IfcContext::hasObjectType() const { return !data_->getArgument(4)->isNull(); }
std::string IfcContext::ObjectType() const { return *data_->getArgument(4); }
void IfcContext::setObjectType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcContext::hasLongName() const { return !data_->getArgument(5)->isNull(); }
std::string IfcContext::LongName() const { return *data_->getArgument(5); }
void IfcContext::setLongName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcContext::hasPhase() const { return !data_->getArgument(6)->isNull(); }
std::string IfcContext::Phase() const { return *data_->getArgument(6); }
void IfcContext::setPhase(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcContext::hasRepresentationContexts() const { return !data_->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcRepresentationContext >::ptr IfcContext::RepresentationContexts() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcRepresentationContext>(); }
void IfcContext::setRepresentationContexts(IfcTemplatedEntityList< IfcRepresentationContext >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }
bool IfcContext::hasUnitsInContext() const { return !data_->getArgument(8)->isNull(); }
IfcUnitAssignment* IfcContext::UnitsInContext() const { return (IfcUnitAssignment*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcContext::setUnitsInContext(IfcUnitAssignment* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }

IfcRelDefinesByProperties::list::ptr IfcContext::IsDefinedBy() const { return data_->getInverse(IfcRelDefinesByProperties_type, 4)->as<IfcRelDefinesByProperties>(); }
IfcRelDeclares::list::ptr IfcContext::Declares() const { return data_->getInverse(IfcRelDeclares_type, 4)->as<IfcRelDeclares>(); }

const IfcParse::entity& IfcContext::declaration() const { return *IfcContext_type; }
const IfcParse::entity& IfcContext::Class() { return *IfcContext_type; }
IfcContext::IfcContext(IfcEntityInstanceData* e) : IfcObjectDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcContext_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcContext::IfcContext(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< std::string > v7_Phase, boost::optional< IfcTemplatedEntityList< IfcRepresentationContext >::ptr > v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext) : IfcObjectDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcContext_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LongName));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Phase) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Phase));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_RepresentationContexts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_RepresentationContexts)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_UnitsInContext));data_->setArgument(8,attr);} }

// Function implementations for IfcContextDependentUnit
std::string IfcContextDependentUnit::Name() const { return *data_->getArgument(2); }
void IfcContextDependentUnit::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcContextDependentUnit::HasExternalReference() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }

const IfcParse::entity& IfcContextDependentUnit::declaration() const { return *IfcContextDependentUnit_type; }
const IfcParse::entity& IfcContextDependentUnit::Class() { return *IfcContextDependentUnit_type; }
IfcContextDependentUnit::IfcContextDependentUnit(IfcEntityInstanceData* e) : IfcNamedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcContextDependentUnit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcContextDependentUnit::IfcContextDependentUnit(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name) : IfcNamedUnit((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcContextDependentUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Name));data_->setArgument(2,attr);} }

// Function implementations for IfcControl
bool IfcControl::hasIdentification() const { return !data_->getArgument(5)->isNull(); }
std::string IfcControl::Identification() const { return *data_->getArgument(5); }
void IfcControl::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

IfcRelAssignsToControl::list::ptr IfcControl::Controls() const { return data_->getInverse(IfcRelAssignsToControl_type, 6)->as<IfcRelAssignsToControl>(); }

const IfcParse::entity& IfcControl::declaration() const { return *IfcControl_type; }
const IfcParse::entity& IfcControl::Class() { return *IfcControl_type; }
IfcControl::IfcControl(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcControl_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcControl::IfcControl(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcControl_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcController
bool IfcController::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcControllerTypeEnum::IfcControllerTypeEnum IfcController::PredefinedType() const { return IfcControllerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcController::setPredefinedType(IfcControllerTypeEnum::IfcControllerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcControllerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcController::declaration() const { return *IfcController_type; }
const IfcParse::entity& IfcController::Class() { return *IfcController_type; }
IfcController::IfcController(IfcEntityInstanceData* e) : IfcDistributionControlElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcController_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcController::IfcController(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcControllerTypeEnum::IfcControllerTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcController_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcControllerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcControllerType
IfcControllerTypeEnum::IfcControllerTypeEnum IfcControllerType::PredefinedType() const { return IfcControllerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcControllerType::setPredefinedType(IfcControllerTypeEnum::IfcControllerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcControllerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcControllerType::declaration() const { return *IfcControllerType_type; }
const IfcParse::entity& IfcControllerType::Class() { return *IfcControllerType_type; }
IfcControllerType::IfcControllerType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcControllerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcControllerType::IfcControllerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcControllerTypeEnum::IfcControllerTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcControllerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcControllerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcConversionBasedUnit
std::string IfcConversionBasedUnit::Name() const { return *data_->getArgument(2); }
void IfcConversionBasedUnit::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcMeasureWithUnit* IfcConversionBasedUnit::ConversionFactor() const { return (IfcMeasureWithUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcConversionBasedUnit::setConversionFactor(IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcConversionBasedUnit::HasExternalReference() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }

const IfcParse::entity& IfcConversionBasedUnit::declaration() const { return *IfcConversionBasedUnit_type; }
const IfcParse::entity& IfcConversionBasedUnit::Class() { return *IfcConversionBasedUnit_type; }
IfcConversionBasedUnit::IfcConversionBasedUnit(IfcEntityInstanceData* e) : IfcNamedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConversionBasedUnit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConversionBasedUnit::IfcConversionBasedUnit(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name, IfcMeasureWithUnit* v4_ConversionFactor) : IfcNamedUnit((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConversionBasedUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Name));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ConversionFactor));data_->setArgument(3,attr);} }

// Function implementations for IfcConversionBasedUnitWithOffset
double IfcConversionBasedUnitWithOffset::ConversionOffset() const { return *data_->getArgument(4); }
void IfcConversionBasedUnitWithOffset::setConversionOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcConversionBasedUnitWithOffset::declaration() const { return *IfcConversionBasedUnitWithOffset_type; }
const IfcParse::entity& IfcConversionBasedUnitWithOffset::Class() { return *IfcConversionBasedUnitWithOffset_type; }
IfcConversionBasedUnitWithOffset::IfcConversionBasedUnitWithOffset(IfcEntityInstanceData* e) : IfcConversionBasedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcConversionBasedUnitWithOffset_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcConversionBasedUnitWithOffset::IfcConversionBasedUnitWithOffset(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name, IfcMeasureWithUnit* v4_ConversionFactor, double v5_ConversionOffset) : IfcConversionBasedUnit((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcConversionBasedUnitWithOffset_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Name));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ConversionFactor));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConversionOffset));data_->setArgument(4,attr);} }

// Function implementations for IfcCooledBeam
bool IfcCooledBeam::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum IfcCooledBeam::PredefinedType() const { return IfcCooledBeamTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCooledBeam::setPredefinedType(IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCooledBeamTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCooledBeam::declaration() const { return *IfcCooledBeam_type; }
const IfcParse::entity& IfcCooledBeam::Class() { return *IfcCooledBeam_type; }
IfcCooledBeam::IfcCooledBeam(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCooledBeam_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCooledBeam::IfcCooledBeam(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCooledBeam_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCooledBeamTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCooledBeamType
IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum IfcCooledBeamType::PredefinedType() const { return IfcCooledBeamTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCooledBeamType::setPredefinedType(IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCooledBeamTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCooledBeamType::declaration() const { return *IfcCooledBeamType_type; }
const IfcParse::entity& IfcCooledBeamType::Class() { return *IfcCooledBeamType_type; }
IfcCooledBeamType::IfcCooledBeamType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCooledBeamType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCooledBeamType::IfcCooledBeamType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCooledBeamType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCooledBeamTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCoolingTower
bool IfcCoolingTower::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum IfcCoolingTower::PredefinedType() const { return IfcCoolingTowerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCoolingTower::setPredefinedType(IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoolingTowerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCoolingTower::declaration() const { return *IfcCoolingTower_type; }
const IfcParse::entity& IfcCoolingTower::Class() { return *IfcCoolingTower_type; }
IfcCoolingTower::IfcCoolingTower(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCoolingTower_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCoolingTower::IfcCoolingTower(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCoolingTower_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCoolingTowerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCoolingTowerType
IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum IfcCoolingTowerType::PredefinedType() const { return IfcCoolingTowerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCoolingTowerType::setPredefinedType(IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoolingTowerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCoolingTowerType::declaration() const { return *IfcCoolingTowerType_type; }
const IfcParse::entity& IfcCoolingTowerType::Class() { return *IfcCoolingTowerType_type; }
IfcCoolingTowerType::IfcCoolingTowerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCoolingTowerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCoolingTowerType::IfcCoolingTowerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCoolingTowerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCoolingTowerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCoordinateOperation
IfcCoordinateReferenceSystemSelect* IfcCoordinateOperation::SourceCRS() const { return (IfcCoordinateReferenceSystemSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcCoordinateOperation::setSourceCRS(IfcCoordinateReferenceSystemSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcCoordinateReferenceSystem* IfcCoordinateOperation::TargetCRS() const { return (IfcCoordinateReferenceSystem*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcCoordinateOperation::setTargetCRS(IfcCoordinateReferenceSystem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcCoordinateOperation::declaration() const { return *IfcCoordinateOperation_type; }
const IfcParse::entity& IfcCoordinateOperation::Class() { return *IfcCoordinateOperation_type; }
IfcCoordinateOperation::IfcCoordinateOperation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcCoordinateOperation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCoordinateOperation::IfcCoordinateOperation(IfcCoordinateReferenceSystemSelect* v1_SourceCRS, IfcCoordinateReferenceSystem* v2_TargetCRS) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcCoordinateOperation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SourceCRS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TargetCRS));data_->setArgument(1,attr);} }

// Function implementations for IfcCoordinateReferenceSystem
std::string IfcCoordinateReferenceSystem::Name() const { return *data_->getArgument(0); }
void IfcCoordinateReferenceSystem::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcCoordinateReferenceSystem::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcCoordinateReferenceSystem::Description() const { return *data_->getArgument(1); }
void IfcCoordinateReferenceSystem::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcCoordinateReferenceSystem::hasGeodeticDatum() const { return !data_->getArgument(2)->isNull(); }
std::string IfcCoordinateReferenceSystem::GeodeticDatum() const { return *data_->getArgument(2); }
void IfcCoordinateReferenceSystem::setGeodeticDatum(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcCoordinateReferenceSystem::hasVerticalDatum() const { return !data_->getArgument(3)->isNull(); }
std::string IfcCoordinateReferenceSystem::VerticalDatum() const { return *data_->getArgument(3); }
void IfcCoordinateReferenceSystem::setVerticalDatum(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }

IfcCoordinateOperation::list::ptr IfcCoordinateReferenceSystem::HasCoordinateOperation() const { return data_->getInverse(IfcCoordinateOperation_type, 0)->as<IfcCoordinateOperation>(); }

const IfcParse::entity& IfcCoordinateReferenceSystem::declaration() const { return *IfcCoordinateReferenceSystem_type; }
const IfcParse::entity& IfcCoordinateReferenceSystem::Class() { return *IfcCoordinateReferenceSystem_type; }
IfcCoordinateReferenceSystem::IfcCoordinateReferenceSystem(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcCoordinateReferenceSystem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCoordinateReferenceSystem::IfcCoordinateReferenceSystem(std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_GeodeticDatum, boost::optional< std::string > v4_VerticalDatum) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcCoordinateReferenceSystem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_GeodeticDatum) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_GeodeticDatum));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_VerticalDatum) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_VerticalDatum));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcCostItem
bool IfcCostItem::hasPredefinedType() const { return !data_->getArgument(6)->isNull(); }
IfcCostItemTypeEnum::IfcCostItemTypeEnum IfcCostItem::PredefinedType() const { return IfcCostItemTypeEnum::FromString(*data_->getArgument(6)); }
void IfcCostItem::setPredefinedType(IfcCostItemTypeEnum::IfcCostItemTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCostItemTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
bool IfcCostItem::hasCostValues() const { return !data_->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcCostValue >::ptr IfcCostItem::CostValues() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcCostValue>(); }
void IfcCostItem::setCostValues(IfcTemplatedEntityList< IfcCostValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }
bool IfcCostItem::hasCostQuantities() const { return !data_->getArgument(8)->isNull(); }
IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr IfcCostItem::CostQuantities() const { IfcEntityList::ptr es = *data_->getArgument(8); return es->as<IfcPhysicalQuantity>(); }
void IfcCostItem::setCostQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCostItem::declaration() const { return *IfcCostItem_type; }
const IfcParse::entity& IfcCostItem::Class() { return *IfcCostItem_type; }
IfcCostItem::IfcCostItem(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCostItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCostItem::IfcCostItem(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcCostItemTypeEnum::IfcCostItemTypeEnum > v7_PredefinedType, boost::optional< IfcTemplatedEntityList< IfcCostValue >::ptr > v8_CostValues, boost::optional< IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr > v9_CostQuantities) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCostItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_PredefinedType,IfcCostItemTypeEnum::ToString(*v7_PredefinedType))));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_CostValues) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_CostValues)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_CostQuantities) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_CostQuantities)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCostSchedule
bool IfcCostSchedule::hasPredefinedType() const { return !data_->getArgument(6)->isNull(); }
IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum IfcCostSchedule::PredefinedType() const { return IfcCostScheduleTypeEnum::FromString(*data_->getArgument(6)); }
void IfcCostSchedule::setPredefinedType(IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCostScheduleTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
bool IfcCostSchedule::hasStatus() const { return !data_->getArgument(7)->isNull(); }
std::string IfcCostSchedule::Status() const { return *data_->getArgument(7); }
void IfcCostSchedule::setStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcCostSchedule::hasSubmittedOn() const { return !data_->getArgument(8)->isNull(); }
std::string IfcCostSchedule::SubmittedOn() const { return *data_->getArgument(8); }
void IfcCostSchedule::setSubmittedOn(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcCostSchedule::hasUpdateDate() const { return !data_->getArgument(9)->isNull(); }
std::string IfcCostSchedule::UpdateDate() const { return *data_->getArgument(9); }
void IfcCostSchedule::setUpdateDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCostSchedule::declaration() const { return *IfcCostSchedule_type; }
const IfcParse::entity& IfcCostSchedule::Class() { return *IfcCostSchedule_type; }
IfcCostSchedule::IfcCostSchedule(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCostSchedule_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCostSchedule::IfcCostSchedule(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum > v7_PredefinedType, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_SubmittedOn, boost::optional< std::string > v10_UpdateDate) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCostSchedule_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_PredefinedType,IfcCostScheduleTypeEnum::ToString(*v7_PredefinedType))));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Status));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SubmittedOn) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SubmittedOn));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_UpdateDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_UpdateDate));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcCostValue


const IfcParse::entity& IfcCostValue::declaration() const { return *IfcCostValue_type; }
const IfcParse::entity& IfcCostValue::Class() { return *IfcCostValue_type; }
IfcCostValue::IfcCostValue(IfcEntityInstanceData* e) : IfcAppliedValue((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCostValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCostValue::IfcCostValue(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, boost::optional< std::string > v5_ApplicableDate, boost::optional< std::string > v6_FixedUntilDate, boost::optional< std::string > v7_Category, boost::optional< std::string > v8_Condition, boost::optional< IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum > v9_ArithmeticOperator, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_Components) : IfcAppliedValue((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCostValue_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AppliedValue));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_UnitBasis));data_->setArgument(3,attr);} if (v5_ApplicableDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableDate));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_FixedUntilDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_FixedUntilDate));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Category) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Category));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Condition) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Condition));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ArithmeticOperator) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_ArithmeticOperator,IfcArithmeticOperatorEnum::ToString(*v9_ArithmeticOperator))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Components) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Components)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcCovering
bool IfcCovering::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCoveringTypeEnum::IfcCoveringTypeEnum IfcCovering::PredefinedType() const { return IfcCoveringTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCovering::setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoveringTypeEnum::ToString(v)));data_->setArgument(8,attr);} }

IfcRelCoversSpaces::list::ptr IfcCovering::CoversSpaces() const { return data_->getInverse(IfcRelCoversSpaces_type, 5)->as<IfcRelCoversSpaces>(); }
IfcRelCoversBldgElements::list::ptr IfcCovering::CoversElements() const { return data_->getInverse(IfcRelCoversBldgElements_type, 5)->as<IfcRelCoversBldgElements>(); }

const IfcParse::entity& IfcCovering::declaration() const { return *IfcCovering_type; }
const IfcParse::entity& IfcCovering::Class() { return *IfcCovering_type; }
IfcCovering::IfcCovering(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCovering_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCovering::IfcCovering(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCoveringTypeEnum::IfcCoveringTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCovering_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCoveringTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCoveringType
IfcCoveringTypeEnum::IfcCoveringTypeEnum IfcCoveringType::PredefinedType() const { return IfcCoveringTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCoveringType::setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoveringTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCoveringType::declaration() const { return *IfcCoveringType_type; }
const IfcParse::entity& IfcCoveringType::Class() { return *IfcCoveringType_type; }
IfcCoveringType::IfcCoveringType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCoveringType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCoveringType::IfcCoveringType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoveringTypeEnum::IfcCoveringTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCoveringType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCoveringTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCrewResource
bool IfcCrewResource::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum IfcCrewResource::PredefinedType() const { return IfcCrewResourceTypeEnum::FromString(*data_->getArgument(10)); }
void IfcCrewResource::setPredefinedType(IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCrewResourceTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& IfcCrewResource::declaration() const { return *IfcCrewResource_type; }
const IfcParse::entity& IfcCrewResource::Class() { return *IfcCrewResource_type; }
IfcCrewResource::IfcCrewResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCrewResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCrewResource::IfcCrewResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCrewResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Usage));data_->setArgument(7,attr);} if (v9_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_BaseCosts)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_BaseQuantity));data_->setArgument(9,attr);} if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcCrewResourceTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcCrewResourceType
IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum IfcCrewResourceType::PredefinedType() const { return IfcCrewResourceTypeEnum::FromString(*data_->getArgument(11)); }
void IfcCrewResourceType::setPredefinedType(IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCrewResourceTypeEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcCrewResourceType::declaration() const { return *IfcCrewResourceType_type; }
const IfcParse::entity& IfcCrewResourceType::Class() { return *IfcCrewResourceType_type; }
IfcCrewResourceType::IfcCrewResourceType(IfcEntityInstanceData* e) : IfcConstructionResourceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCrewResourceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCrewResourceType::IfcCrewResourceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCrewResourceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ResourceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ResourceType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_BaseCosts)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseQuantity));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcCrewResourceTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcCsgPrimitive3D
IfcAxis2Placement3D* IfcCsgPrimitive3D::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcCsgPrimitive3D::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcCsgPrimitive3D::declaration() const { return *IfcCsgPrimitive3D_type; }
const IfcParse::entity& IfcCsgPrimitive3D::Class() { return *IfcCsgPrimitive3D_type; }
IfcCsgPrimitive3D::IfcCsgPrimitive3D(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCsgPrimitive3D_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCsgPrimitive3D::IfcCsgPrimitive3D(IfcAxis2Placement3D* v1_Position) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCsgPrimitive3D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);} }

// Function implementations for IfcCsgSolid
IfcCsgSelect* IfcCsgSolid::TreeRootExpression() const { return (IfcCsgSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcCsgSolid::setTreeRootExpression(IfcCsgSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcCsgSolid::declaration() const { return *IfcCsgSolid_type; }
const IfcParse::entity& IfcCsgSolid::Class() { return *IfcCsgSolid_type; }
IfcCsgSolid::IfcCsgSolid(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCsgSolid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCsgSolid::IfcCsgSolid(IfcCsgSelect* v1_TreeRootExpression) : IfcSolidModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCsgSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TreeRootExpression));data_->setArgument(0,attr);} }

// Function implementations for IfcCurrencyRelationship
IfcMonetaryUnit* IfcCurrencyRelationship::RelatingMonetaryUnit() const { return (IfcMonetaryUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcCurrencyRelationship::setRelatingMonetaryUnit(IfcMonetaryUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcMonetaryUnit* IfcCurrencyRelationship::RelatedMonetaryUnit() const { return (IfcMonetaryUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcCurrencyRelationship::setRelatedMonetaryUnit(IfcMonetaryUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcCurrencyRelationship::ExchangeRate() const { return *data_->getArgument(4); }
void IfcCurrencyRelationship::setExchangeRate(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcCurrencyRelationship::hasRateDateTime() const { return !data_->getArgument(5)->isNull(); }
std::string IfcCurrencyRelationship::RateDateTime() const { return *data_->getArgument(5); }
void IfcCurrencyRelationship::setRateDateTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcCurrencyRelationship::hasRateSource() const { return !data_->getArgument(6)->isNull(); }
IfcLibraryInformation* IfcCurrencyRelationship::RateSource() const { return (IfcLibraryInformation*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcCurrencyRelationship::setRateSource(IfcLibraryInformation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcCurrencyRelationship::declaration() const { return *IfcCurrencyRelationship_type; }
const IfcParse::entity& IfcCurrencyRelationship::Class() { return *IfcCurrencyRelationship_type; }
IfcCurrencyRelationship::IfcCurrencyRelationship(IfcEntityInstanceData* e) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurrencyRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurrencyRelationship::IfcCurrencyRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMonetaryUnit* v3_RelatingMonetaryUnit, IfcMonetaryUnit* v4_RelatedMonetaryUnit, double v5_ExchangeRate, boost::optional< std::string > v6_RateDateTime, IfcLibraryInformation* v7_RateSource) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurrencyRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingMonetaryUnit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedMonetaryUnit));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ExchangeRate));data_->setArgument(4,attr);} if (v6_RateDateTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RateDateTime));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RateSource));data_->setArgument(6,attr);} }

// Function implementations for IfcCurtainWall
bool IfcCurtainWall::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum IfcCurtainWall::PredefinedType() const { return IfcCurtainWallTypeEnum::FromString(*data_->getArgument(8)); }
void IfcCurtainWall::setPredefinedType(IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCurtainWallTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcCurtainWall::declaration() const { return *IfcCurtainWall_type; }
const IfcParse::entity& IfcCurtainWall::Class() { return *IfcCurtainWall_type; }
IfcCurtainWall::IfcCurtainWall(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurtainWall_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurtainWall::IfcCurtainWall(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurtainWall_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCurtainWallTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCurtainWallType
IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum IfcCurtainWallType::PredefinedType() const { return IfcCurtainWallTypeEnum::FromString(*data_->getArgument(9)); }
void IfcCurtainWallType::setPredefinedType(IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCurtainWallTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcCurtainWallType::declaration() const { return *IfcCurtainWallType_type; }
const IfcParse::entity& IfcCurtainWallType::Class() { return *IfcCurtainWallType_type; }
IfcCurtainWallType::IfcCurtainWallType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurtainWallType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurtainWallType::IfcCurtainWallType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurtainWallType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCurtainWallTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCurve


const IfcParse::entity& IfcCurve::declaration() const { return *IfcCurve_type; }
const IfcParse::entity& IfcCurve::Class() { return *IfcCurve_type; }
IfcCurve::IfcCurve(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurve::IfcCurve() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurve_type);  }

// Function implementations for IfcCurveBoundedPlane
IfcPlane* IfcCurveBoundedPlane::BasisSurface() const { return (IfcPlane*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcCurveBoundedPlane::setBasisSurface(IfcPlane* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcCurve* IfcCurveBoundedPlane::OuterBoundary() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcCurveBoundedPlane::setOuterBoundary(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcTemplatedEntityList< IfcCurve >::ptr IfcCurveBoundedPlane::InnerBoundaries() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcCurve>(); }
void IfcCurveBoundedPlane::setInnerBoundaries(IfcTemplatedEntityList< IfcCurve >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& IfcCurveBoundedPlane::declaration() const { return *IfcCurveBoundedPlane_type; }
const IfcParse::entity& IfcCurveBoundedPlane::Class() { return *IfcCurveBoundedPlane_type; }
IfcCurveBoundedPlane::IfcCurveBoundedPlane(IfcEntityInstanceData* e) : IfcBoundedSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurveBoundedPlane_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurveBoundedPlane::IfcCurveBoundedPlane(IfcPlane* v1_BasisSurface, IfcCurve* v2_OuterBoundary, IfcTemplatedEntityList< IfcCurve >::ptr v3_InnerBoundaries) : IfcBoundedSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurveBoundedPlane_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OuterBoundary));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_InnerBoundaries)->generalize());data_->setArgument(2,attr);} }

// Function implementations for IfcCurveBoundedSurface
IfcSurface* IfcCurveBoundedSurface::BasisSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcCurveBoundedSurface::setBasisSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcBoundaryCurve >::ptr IfcCurveBoundedSurface::Boundaries() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcBoundaryCurve>(); }
void IfcCurveBoundedSurface::setBoundaries(IfcTemplatedEntityList< IfcBoundaryCurve >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }
bool IfcCurveBoundedSurface::ImplicitOuter() const { return *data_->getArgument(2); }
void IfcCurveBoundedSurface::setImplicitOuter(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcCurveBoundedSurface::declaration() const { return *IfcCurveBoundedSurface_type; }
const IfcParse::entity& IfcCurveBoundedSurface::Class() { return *IfcCurveBoundedSurface_type; }
IfcCurveBoundedSurface::IfcCurveBoundedSurface(IfcEntityInstanceData* e) : IfcBoundedSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurveBoundedSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurveBoundedSurface::IfcCurveBoundedSurface(IfcSurface* v1_BasisSurface, IfcTemplatedEntityList< IfcBoundaryCurve >::ptr v2_Boundaries, bool v3_ImplicitOuter) : IfcBoundedSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurveBoundedSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Boundaries)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ImplicitOuter));data_->setArgument(2,attr);} }

// Function implementations for IfcCurveStyle
bool IfcCurveStyle::hasCurveFont() const { return !data_->getArgument(1)->isNull(); }
IfcCurveFontOrScaledCurveFontSelect* IfcCurveStyle::CurveFont() const { return (IfcCurveFontOrScaledCurveFontSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcCurveStyle::setCurveFont(IfcCurveFontOrScaledCurveFontSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcCurveStyle::hasCurveWidth() const { return !data_->getArgument(2)->isNull(); }
IfcSizeSelect* IfcCurveStyle::CurveWidth() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcCurveStyle::setCurveWidth(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcCurveStyle::hasCurveColour() const { return !data_->getArgument(3)->isNull(); }
IfcColour* IfcCurveStyle::CurveColour() const { return (IfcColour*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcCurveStyle::setCurveColour(IfcColour* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcCurveStyle::hasModelOrDraughting() const { return !data_->getArgument(4)->isNull(); }
bool IfcCurveStyle::ModelOrDraughting() const { return *data_->getArgument(4); }
void IfcCurveStyle::setModelOrDraughting(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcCurveStyle::declaration() const { return *IfcCurveStyle_type; }
const IfcParse::entity& IfcCurveStyle::Class() { return *IfcCurveStyle_type; }
IfcCurveStyle::IfcCurveStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurveStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurveStyle::IfcCurveStyle(boost::optional< std::string > v1_Name, IfcCurveFontOrScaledCurveFontSelect* v2_CurveFont, IfcSizeSelect* v3_CurveWidth, IfcColour* v4_CurveColour, boost::optional< bool > v5_ModelOrDraughting) : IfcPresentationStyle((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurveStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CurveFont));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CurveWidth));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_CurveColour));data_->setArgument(3,attr);} if (v5_ModelOrDraughting) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ModelOrDraughting));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcCurveStyleFont
bool IfcCurveStyleFont::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcCurveStyleFont::Name() const { return *data_->getArgument(0); }
void IfcCurveStyleFont::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr IfcCurveStyleFont::PatternList() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcCurveStyleFontPattern>(); }
void IfcCurveStyleFont::setPatternList(IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& IfcCurveStyleFont::declaration() const { return *IfcCurveStyleFont_type; }
const IfcParse::entity& IfcCurveStyleFont::Class() { return *IfcCurveStyleFont_type; }
IfcCurveStyleFont::IfcCurveStyleFont(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurveStyleFont_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurveStyleFont::IfcCurveStyleFont(boost::optional< std::string > v1_Name, IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr v2_PatternList) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurveStyleFont_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PatternList)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcCurveStyleFontAndScaling
bool IfcCurveStyleFontAndScaling::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcCurveStyleFontAndScaling::Name() const { return *data_->getArgument(0); }
void IfcCurveStyleFontAndScaling::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcCurveStyleFontSelect* IfcCurveStyleFontAndScaling::CurveFont() const { return (IfcCurveStyleFontSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcCurveStyleFontAndScaling::setCurveFont(IfcCurveStyleFontSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcCurveStyleFontAndScaling::CurveFontScaling() const { return *data_->getArgument(2); }
void IfcCurveStyleFontAndScaling::setCurveFontScaling(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcCurveStyleFontAndScaling::declaration() const { return *IfcCurveStyleFontAndScaling_type; }
const IfcParse::entity& IfcCurveStyleFontAndScaling::Class() { return *IfcCurveStyleFontAndScaling_type; }
IfcCurveStyleFontAndScaling::IfcCurveStyleFontAndScaling(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurveStyleFontAndScaling_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurveStyleFontAndScaling::IfcCurveStyleFontAndScaling(boost::optional< std::string > v1_Name, IfcCurveStyleFontSelect* v2_CurveFont, double v3_CurveFontScaling) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurveStyleFontAndScaling_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CurveFont));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CurveFontScaling));data_->setArgument(2,attr);} }

// Function implementations for IfcCurveStyleFontPattern
double IfcCurveStyleFontPattern::VisibleSegmentLength() const { return *data_->getArgument(0); }
void IfcCurveStyleFontPattern::setVisibleSegmentLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcCurveStyleFontPattern::InvisibleSegmentLength() const { return *data_->getArgument(1); }
void IfcCurveStyleFontPattern::setInvisibleSegmentLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcCurveStyleFontPattern::declaration() const { return *IfcCurveStyleFontPattern_type; }
const IfcParse::entity& IfcCurveStyleFontPattern::Class() { return *IfcCurveStyleFontPattern_type; }
IfcCurveStyleFontPattern::IfcCurveStyleFontPattern(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCurveStyleFontPattern_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCurveStyleFontPattern::IfcCurveStyleFontPattern(double v1_VisibleSegmentLength, double v2_InvisibleSegmentLength) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCurveStyleFontPattern_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_VisibleSegmentLength));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_InvisibleSegmentLength));data_->setArgument(1,attr);} }

// Function implementations for IfcCylindricalSurface
double IfcCylindricalSurface::Radius() const { return *data_->getArgument(1); }
void IfcCylindricalSurface::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcCylindricalSurface::declaration() const { return *IfcCylindricalSurface_type; }
const IfcParse::entity& IfcCylindricalSurface::Class() { return *IfcCylindricalSurface_type; }
IfcCylindricalSurface::IfcCylindricalSurface(IfcEntityInstanceData* e) : IfcElementarySurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcCylindricalSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcCylindricalSurface::IfcCylindricalSurface(IfcAxis2Placement3D* v1_Position, double v2_Radius) : IfcElementarySurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcCylindricalSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));data_->setArgument(1,attr);} }

// Function implementations for IfcDamper
bool IfcDamper::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcDamperTypeEnum::IfcDamperTypeEnum IfcDamper::PredefinedType() const { return IfcDamperTypeEnum::FromString(*data_->getArgument(8)); }
void IfcDamper::setPredefinedType(IfcDamperTypeEnum::IfcDamperTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDamperTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcDamper::declaration() const { return *IfcDamper_type; }
const IfcParse::entity& IfcDamper::Class() { return *IfcDamper_type; }
IfcDamper::IfcDamper(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDamper_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDamper::IfcDamper(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDamperTypeEnum::IfcDamperTypeEnum > v9_PredefinedType) : IfcFlowController((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDamper_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcDamperTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDamperType
IfcDamperTypeEnum::IfcDamperTypeEnum IfcDamperType::PredefinedType() const { return IfcDamperTypeEnum::FromString(*data_->getArgument(9)); }
void IfcDamperType::setPredefinedType(IfcDamperTypeEnum::IfcDamperTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDamperTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcDamperType::declaration() const { return *IfcDamperType_type; }
const IfcParse::entity& IfcDamperType::Class() { return *IfcDamperType_type; }
IfcDamperType::IfcDamperType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDamperType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDamperType::IfcDamperType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDamperTypeEnum::IfcDamperTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDamperType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDamperTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcDerivedProfileDef
IfcProfileDef* IfcDerivedProfileDef::ParentProfile() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcDerivedProfileDef::setParentProfile(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcCartesianTransformationOperator2D* IfcDerivedProfileDef::Operator() const { return (IfcCartesianTransformationOperator2D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcDerivedProfileDef::setOperator(IfcCartesianTransformationOperator2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcDerivedProfileDef::hasLabel() const { return !data_->getArgument(4)->isNull(); }
std::string IfcDerivedProfileDef::Label() const { return *data_->getArgument(4); }
void IfcDerivedProfileDef::setLabel(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcDerivedProfileDef::declaration() const { return *IfcDerivedProfileDef_type; }
const IfcParse::entity& IfcDerivedProfileDef::Class() { return *IfcDerivedProfileDef_type; }
IfcDerivedProfileDef::IfcDerivedProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDerivedProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDerivedProfileDef::IfcDerivedProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcProfileDef* v3_ParentProfile, IfcCartesianTransformationOperator2D* v4_Operator, boost::optional< std::string > v5_Label) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDerivedProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentProfile));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Operator));data_->setArgument(3,attr);} if (v5_Label) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Label));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcDerivedUnit
IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr IfcDerivedUnit::Elements() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcDerivedUnitElement>(); }
void IfcDerivedUnit::setElements(IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }
IfcDerivedUnitEnum::IfcDerivedUnitEnum IfcDerivedUnit::UnitType() const { return IfcDerivedUnitEnum::FromString(*data_->getArgument(1)); }
void IfcDerivedUnit::setUnitType(IfcDerivedUnitEnum::IfcDerivedUnitEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDerivedUnitEnum::ToString(v)));data_->setArgument(1,attr);} }
bool IfcDerivedUnit::hasUserDefinedType() const { return !data_->getArgument(2)->isNull(); }
std::string IfcDerivedUnit::UserDefinedType() const { return *data_->getArgument(2); }
void IfcDerivedUnit::setUserDefinedType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcDerivedUnit::declaration() const { return *IfcDerivedUnit_type; }
const IfcParse::entity& IfcDerivedUnit::Class() { return *IfcDerivedUnit_type; }
IfcDerivedUnit::IfcDerivedUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcDerivedUnit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDerivedUnit::IfcDerivedUnit(IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr v1_Elements, IfcDerivedUnitEnum::IfcDerivedUnitEnum v2_UnitType, boost::optional< std::string > v3_UserDefinedType) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcDerivedUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Elements)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcDerivedUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);} if (v3_UserDefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcDerivedUnitElement
IfcNamedUnit* IfcDerivedUnitElement::Unit() const { return (IfcNamedUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcDerivedUnitElement::setUnit(IfcNamedUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
int IfcDerivedUnitElement::Exponent() const { return *data_->getArgument(1); }
void IfcDerivedUnitElement::setExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcDerivedUnitElement::declaration() const { return *IfcDerivedUnitElement_type; }
const IfcParse::entity& IfcDerivedUnitElement::Class() { return *IfcDerivedUnitElement_type; }
IfcDerivedUnitElement::IfcDerivedUnitElement(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcDerivedUnitElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDerivedUnitElement::IfcDerivedUnitElement(IfcNamedUnit* v1_Unit, int v2_Exponent) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcDerivedUnitElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Unit));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Exponent));data_->setArgument(1,attr);} }

// Function implementations for IfcDimensionalExponents
int IfcDimensionalExponents::LengthExponent() const { return *data_->getArgument(0); }
void IfcDimensionalExponents::setLengthExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
int IfcDimensionalExponents::MassExponent() const { return *data_->getArgument(1); }
void IfcDimensionalExponents::setMassExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
int IfcDimensionalExponents::TimeExponent() const { return *data_->getArgument(2); }
void IfcDimensionalExponents::setTimeExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
int IfcDimensionalExponents::ElectricCurrentExponent() const { return *data_->getArgument(3); }
void IfcDimensionalExponents::setElectricCurrentExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
int IfcDimensionalExponents::ThermodynamicTemperatureExponent() const { return *data_->getArgument(4); }
void IfcDimensionalExponents::setThermodynamicTemperatureExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
int IfcDimensionalExponents::AmountOfSubstanceExponent() const { return *data_->getArgument(5); }
void IfcDimensionalExponents::setAmountOfSubstanceExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
int IfcDimensionalExponents::LuminousIntensityExponent() const { return *data_->getArgument(6); }
void IfcDimensionalExponents::setLuminousIntensityExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcDimensionalExponents::declaration() const { return *IfcDimensionalExponents_type; }
const IfcParse::entity& IfcDimensionalExponents::Class() { return *IfcDimensionalExponents_type; }
IfcDimensionalExponents::IfcDimensionalExponents(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcDimensionalExponents_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDimensionalExponents::IfcDimensionalExponents(int v1_LengthExponent, int v2_MassExponent, int v3_TimeExponent, int v4_ElectricCurrentExponent, int v5_ThermodynamicTemperatureExponent, int v6_AmountOfSubstanceExponent, int v7_LuminousIntensityExponent) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcDimensionalExponents_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LengthExponent));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MassExponent));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TimeExponent));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ElectricCurrentExponent));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ThermodynamicTemperatureExponent));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_AmountOfSubstanceExponent));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LuminousIntensityExponent));data_->setArgument(6,attr);} }

// Function implementations for IfcDirection
std::vector< double > /*[2:3]*/ IfcDirection::DirectionRatios() const { return *data_->getArgument(0); }
void IfcDirection::setDirectionRatios(std::vector< double > /*[2:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcDirection::declaration() const { return *IfcDirection_type; }
const IfcParse::entity& IfcDirection::Class() { return *IfcDirection_type; }
IfcDirection::IfcDirection(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDirection_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDirection::IfcDirection(std::vector< double > /*[2:3]*/ v1_DirectionRatios) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDirection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DirectionRatios));data_->setArgument(0,attr);} }

// Function implementations for IfcDiscreteAccessory
bool IfcDiscreteAccessory::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum IfcDiscreteAccessory::PredefinedType() const { return IfcDiscreteAccessoryTypeEnum::FromString(*data_->getArgument(8)); }
void IfcDiscreteAccessory::setPredefinedType(IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDiscreteAccessoryTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcDiscreteAccessory::declaration() const { return *IfcDiscreteAccessory_type; }
const IfcParse::entity& IfcDiscreteAccessory::Class() { return *IfcDiscreteAccessory_type; }
IfcDiscreteAccessory::IfcDiscreteAccessory(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDiscreteAccessory_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDiscreteAccessory::IfcDiscreteAccessory(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum > v9_PredefinedType) : IfcElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDiscreteAccessory_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcDiscreteAccessoryTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDiscreteAccessoryType
IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum IfcDiscreteAccessoryType::PredefinedType() const { return IfcDiscreteAccessoryTypeEnum::FromString(*data_->getArgument(9)); }
void IfcDiscreteAccessoryType::setPredefinedType(IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDiscreteAccessoryTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcDiscreteAccessoryType::declaration() const { return *IfcDiscreteAccessoryType_type; }
const IfcParse::entity& IfcDiscreteAccessoryType::Class() { return *IfcDiscreteAccessoryType_type; }
IfcDiscreteAccessoryType::IfcDiscreteAccessoryType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDiscreteAccessoryType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDiscreteAccessoryType::IfcDiscreteAccessoryType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum v10_PredefinedType) : IfcElementComponentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDiscreteAccessoryType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDiscreteAccessoryTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcDistributionChamberElement
bool IfcDistributionChamberElement::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum IfcDistributionChamberElement::PredefinedType() const { return IfcDistributionChamberElementTypeEnum::FromString(*data_->getArgument(8)); }
void IfcDistributionChamberElement::setPredefinedType(IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDistributionChamberElementTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcDistributionChamberElement::declaration() const { return *IfcDistributionChamberElement_type; }
const IfcParse::entity& IfcDistributionChamberElement::Class() { return *IfcDistributionChamberElement_type; }
IfcDistributionChamberElement::IfcDistributionChamberElement(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionChamberElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionChamberElement::IfcDistributionChamberElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum > v9_PredefinedType) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionChamberElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcDistributionChamberElementTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDistributionChamberElementType
IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum IfcDistributionChamberElementType::PredefinedType() const { return IfcDistributionChamberElementTypeEnum::FromString(*data_->getArgument(9)); }
void IfcDistributionChamberElementType::setPredefinedType(IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDistributionChamberElementTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcDistributionChamberElementType::declaration() const { return *IfcDistributionChamberElementType_type; }
const IfcParse::entity& IfcDistributionChamberElementType::Class() { return *IfcDistributionChamberElementType_type; }
IfcDistributionChamberElementType::IfcDistributionChamberElementType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionChamberElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionChamberElementType::IfcDistributionChamberElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v10_PredefinedType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionChamberElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDistributionChamberElementTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcDistributionCircuit


const IfcParse::entity& IfcDistributionCircuit::declaration() const { return *IfcDistributionCircuit_type; }
const IfcParse::entity& IfcDistributionCircuit::Class() { return *IfcDistributionCircuit_type; }
IfcDistributionCircuit::IfcDistributionCircuit(IfcEntityInstanceData* e) : IfcDistributionSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionCircuit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionCircuit::IfcDistributionCircuit(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< IfcDistributionSystemEnum::IfcDistributionSystemEnum > v7_PredefinedType) : IfcDistributionSystem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionCircuit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LongName));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_PredefinedType,IfcDistributionSystemEnum::ToString(*v7_PredefinedType))));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcDistributionControlElement

IfcRelFlowControlElements::list::ptr IfcDistributionControlElement::AssignedToFlowElement() const { return data_->getInverse(IfcRelFlowControlElements_type, 4)->as<IfcRelFlowControlElements>(); }

const IfcParse::entity& IfcDistributionControlElement::declaration() const { return *IfcDistributionControlElement_type; }
const IfcParse::entity& IfcDistributionControlElement::Class() { return *IfcDistributionControlElement_type; }
IfcDistributionControlElement::IfcDistributionControlElement(IfcEntityInstanceData* e) : IfcDistributionElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionControlElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionControlElement::IfcDistributionControlElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionControlElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcDistributionControlElementType


const IfcParse::entity& IfcDistributionControlElementType::declaration() const { return *IfcDistributionControlElementType_type; }
const IfcParse::entity& IfcDistributionControlElementType::Class() { return *IfcDistributionControlElementType_type; }
IfcDistributionControlElementType::IfcDistributionControlElementType(IfcEntityInstanceData* e) : IfcDistributionElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionControlElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionControlElementType::IfcDistributionControlElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionControlElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDistributionElement

IfcRelConnectsPortToElement::list::ptr IfcDistributionElement::HasPorts() const { return data_->getInverse(IfcRelConnectsPortToElement_type, 5)->as<IfcRelConnectsPortToElement>(); }

const IfcParse::entity& IfcDistributionElement::declaration() const { return *IfcDistributionElement_type; }
const IfcParse::entity& IfcDistributionElement::Class() { return *IfcDistributionElement_type; }
IfcDistributionElement::IfcDistributionElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionElement::IfcDistributionElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcDistributionElementType


const IfcParse::entity& IfcDistributionElementType::declaration() const { return *IfcDistributionElementType_type; }
const IfcParse::entity& IfcDistributionElementType::Class() { return *IfcDistributionElementType_type; }
IfcDistributionElementType::IfcDistributionElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionElementType::IfcDistributionElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDistributionFlowElement

IfcRelFlowControlElements::list::ptr IfcDistributionFlowElement::HasControlElements() const { return data_->getInverse(IfcRelFlowControlElements_type, 5)->as<IfcRelFlowControlElements>(); }

const IfcParse::entity& IfcDistributionFlowElement::declaration() const { return *IfcDistributionFlowElement_type; }
const IfcParse::entity& IfcDistributionFlowElement::Class() { return *IfcDistributionFlowElement_type; }
IfcDistributionFlowElement::IfcDistributionFlowElement(IfcEntityInstanceData* e) : IfcDistributionElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionFlowElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionFlowElement::IfcDistributionFlowElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionFlowElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcDistributionFlowElementType


const IfcParse::entity& IfcDistributionFlowElementType::declaration() const { return *IfcDistributionFlowElementType_type; }
const IfcParse::entity& IfcDistributionFlowElementType::Class() { return *IfcDistributionFlowElementType_type; }
IfcDistributionFlowElementType::IfcDistributionFlowElementType(IfcEntityInstanceData* e) : IfcDistributionElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionFlowElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionFlowElementType::IfcDistributionFlowElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionFlowElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDistributionPort
bool IfcDistributionPort::hasFlowDirection() const { return !data_->getArgument(7)->isNull(); }
IfcFlowDirectionEnum::IfcFlowDirectionEnum IfcDistributionPort::FlowDirection() const { return IfcFlowDirectionEnum::FromString(*data_->getArgument(7)); }
void IfcDistributionPort::setFlowDirection(IfcFlowDirectionEnum::IfcFlowDirectionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFlowDirectionEnum::ToString(v)));data_->setArgument(7,attr);} }
bool IfcDistributionPort::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum IfcDistributionPort::PredefinedType() const { return IfcDistributionPortTypeEnum::FromString(*data_->getArgument(8)); }
void IfcDistributionPort::setPredefinedType(IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDistributionPortTypeEnum::ToString(v)));data_->setArgument(8,attr);} }
bool IfcDistributionPort::hasSystemType() const { return !data_->getArgument(9)->isNull(); }
IfcDistributionSystemEnum::IfcDistributionSystemEnum IfcDistributionPort::SystemType() const { return IfcDistributionSystemEnum::FromString(*data_->getArgument(9)); }
void IfcDistributionPort::setSystemType(IfcDistributionSystemEnum::IfcDistributionSystemEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDistributionSystemEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcDistributionPort::declaration() const { return *IfcDistributionPort_type; }
const IfcParse::entity& IfcDistributionPort::Class() { return *IfcDistributionPort_type; }
IfcDistributionPort::IfcDistributionPort(IfcEntityInstanceData* e) : IfcPort((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionPort_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionPort::IfcDistributionPort(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcFlowDirectionEnum::IfcFlowDirectionEnum > v8_FlowDirection, boost::optional< IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum > v9_PredefinedType, boost::optional< IfcDistributionSystemEnum::IfcDistributionSystemEnum > v10_SystemType) : IfcPort((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionPort_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_FlowDirection) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_FlowDirection,IfcFlowDirectionEnum::ToString(*v8_FlowDirection))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcDistributionPortTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_SystemType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v10_SystemType,IfcDistributionSystemEnum::ToString(*v10_SystemType))));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcDistributionSystem
bool IfcDistributionSystem::hasLongName() const { return !data_->getArgument(5)->isNull(); }
std::string IfcDistributionSystem::LongName() const { return *data_->getArgument(5); }
void IfcDistributionSystem::setLongName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcDistributionSystem::hasPredefinedType() const { return !data_->getArgument(6)->isNull(); }
IfcDistributionSystemEnum::IfcDistributionSystemEnum IfcDistributionSystem::PredefinedType() const { return IfcDistributionSystemEnum::FromString(*data_->getArgument(6)); }
void IfcDistributionSystem::setPredefinedType(IfcDistributionSystemEnum::IfcDistributionSystemEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDistributionSystemEnum::ToString(v)));data_->setArgument(6,attr);} }


const IfcParse::entity& IfcDistributionSystem::declaration() const { return *IfcDistributionSystem_type; }
const IfcParse::entity& IfcDistributionSystem::Class() { return *IfcDistributionSystem_type; }
IfcDistributionSystem::IfcDistributionSystem(IfcEntityInstanceData* e) : IfcSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDistributionSystem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDistributionSystem::IfcDistributionSystem(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< IfcDistributionSystemEnum::IfcDistributionSystemEnum > v7_PredefinedType) : IfcSystem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDistributionSystem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LongName));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_PredefinedType,IfcDistributionSystemEnum::ToString(*v7_PredefinedType))));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcDocumentInformation
std::string IfcDocumentInformation::Identification() const { return *data_->getArgument(0); }
void IfcDocumentInformation::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::string IfcDocumentInformation::Name() const { return *data_->getArgument(1); }
void IfcDocumentInformation::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcDocumentInformation::hasDescription() const { return !data_->getArgument(2)->isNull(); }
std::string IfcDocumentInformation::Description() const { return *data_->getArgument(2); }
void IfcDocumentInformation::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcDocumentInformation::hasLocation() const { return !data_->getArgument(3)->isNull(); }
std::string IfcDocumentInformation::Location() const { return *data_->getArgument(3); }
void IfcDocumentInformation::setLocation(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcDocumentInformation::hasPurpose() const { return !data_->getArgument(4)->isNull(); }
std::string IfcDocumentInformation::Purpose() const { return *data_->getArgument(4); }
void IfcDocumentInformation::setPurpose(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcDocumentInformation::hasIntendedUse() const { return !data_->getArgument(5)->isNull(); }
std::string IfcDocumentInformation::IntendedUse() const { return *data_->getArgument(5); }
void IfcDocumentInformation::setIntendedUse(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcDocumentInformation::hasScope() const { return !data_->getArgument(6)->isNull(); }
std::string IfcDocumentInformation::Scope() const { return *data_->getArgument(6); }
void IfcDocumentInformation::setScope(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcDocumentInformation::hasRevision() const { return !data_->getArgument(7)->isNull(); }
std::string IfcDocumentInformation::Revision() const { return *data_->getArgument(7); }
void IfcDocumentInformation::setRevision(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcDocumentInformation::hasDocumentOwner() const { return !data_->getArgument(8)->isNull(); }
IfcActorSelect* IfcDocumentInformation::DocumentOwner() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcDocumentInformation::setDocumentOwner(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcDocumentInformation::hasEditors() const { return !data_->getArgument(9)->isNull(); }
IfcEntityList::ptr IfcDocumentInformation::Editors() const { return *data_->getArgument(9); }
void IfcDocumentInformation::setEditors(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcDocumentInformation::hasCreationTime() const { return !data_->getArgument(10)->isNull(); }
std::string IfcDocumentInformation::CreationTime() const { return *data_->getArgument(10); }
void IfcDocumentInformation::setCreationTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcDocumentInformation::hasLastRevisionTime() const { return !data_->getArgument(11)->isNull(); }
std::string IfcDocumentInformation::LastRevisionTime() const { return *data_->getArgument(11); }
void IfcDocumentInformation::setLastRevisionTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcDocumentInformation::hasElectronicFormat() const { return !data_->getArgument(12)->isNull(); }
std::string IfcDocumentInformation::ElectronicFormat() const { return *data_->getArgument(12); }
void IfcDocumentInformation::setElectronicFormat(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcDocumentInformation::hasValidFrom() const { return !data_->getArgument(13)->isNull(); }
std::string IfcDocumentInformation::ValidFrom() const { return *data_->getArgument(13); }
void IfcDocumentInformation::setValidFrom(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
bool IfcDocumentInformation::hasValidUntil() const { return !data_->getArgument(14)->isNull(); }
std::string IfcDocumentInformation::ValidUntil() const { return *data_->getArgument(14); }
void IfcDocumentInformation::setValidUntil(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
bool IfcDocumentInformation::hasConfidentiality() const { return !data_->getArgument(15)->isNull(); }
IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum IfcDocumentInformation::Confidentiality() const { return IfcDocumentConfidentialityEnum::FromString(*data_->getArgument(15)); }
void IfcDocumentInformation::setConfidentiality(IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDocumentConfidentialityEnum::ToString(v)));data_->setArgument(15,attr);} }
bool IfcDocumentInformation::hasStatus() const { return !data_->getArgument(16)->isNull(); }
IfcDocumentStatusEnum::IfcDocumentStatusEnum IfcDocumentInformation::Status() const { return IfcDocumentStatusEnum::FromString(*data_->getArgument(16)); }
void IfcDocumentInformation::setStatus(IfcDocumentStatusEnum::IfcDocumentStatusEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDocumentStatusEnum::ToString(v)));data_->setArgument(16,attr);} }

IfcRelAssociatesDocument::list::ptr IfcDocumentInformation::DocumentInfoForObjects() const { return data_->getInverse(IfcRelAssociatesDocument_type, 5)->as<IfcRelAssociatesDocument>(); }
IfcDocumentReference::list::ptr IfcDocumentInformation::HasDocumentReferences() const { return data_->getInverse(IfcDocumentReference_type, 4)->as<IfcDocumentReference>(); }
IfcDocumentInformationRelationship::list::ptr IfcDocumentInformation::IsPointedTo() const { return data_->getInverse(IfcDocumentInformationRelationship_type, 3)->as<IfcDocumentInformationRelationship>(); }
IfcDocumentInformationRelationship::list::ptr IfcDocumentInformation::IsPointer() const { return data_->getInverse(IfcDocumentInformationRelationship_type, 2)->as<IfcDocumentInformationRelationship>(); }

const IfcParse::entity& IfcDocumentInformation::declaration() const { return *IfcDocumentInformation_type; }
const IfcParse::entity& IfcDocumentInformation::Class() { return *IfcDocumentInformation_type; }
IfcDocumentInformation::IfcDocumentInformation(IfcEntityInstanceData* e) : IfcExternalInformation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDocumentInformation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDocumentInformation::IfcDocumentInformation(std::string v1_Identification, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< std::string > v4_Location, boost::optional< std::string > v5_Purpose, boost::optional< std::string > v6_IntendedUse, boost::optional< std::string > v7_Scope, boost::optional< std::string > v8_Revision, IfcActorSelect* v9_DocumentOwner, boost::optional< IfcEntityList::ptr > v10_Editors, boost::optional< std::string > v11_CreationTime, boost::optional< std::string > v12_LastRevisionTime, boost::optional< std::string > v13_ElectronicFormat, boost::optional< std::string > v14_ValidFrom, boost::optional< std::string > v15_ValidUntil, boost::optional< IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum > v16_Confidentiality, boost::optional< IfcDocumentStatusEnum::IfcDocumentStatusEnum > v17_Status) : IfcExternalInformation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDocumentInformation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Identification));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Name));data_->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Location));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Purpose));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_IntendedUse) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_IntendedUse));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Scope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Scope));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Revision) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Revision));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_DocumentOwner));data_->setArgument(8,attr);} if (v10_Editors) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Editors));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_CreationTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_CreationTime));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_LastRevisionTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_LastRevisionTime));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_ElectronicFormat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_ElectronicFormat));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_ValidFrom) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_ValidFrom));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_ValidUntil) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_ValidUntil));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_Confidentiality) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v16_Confidentiality,IfcDocumentConfidentialityEnum::ToString(*v16_Confidentiality))));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v17_Status,IfcDocumentStatusEnum::ToString(*v17_Status))));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } }

// Function implementations for IfcDocumentInformationRelationship
IfcDocumentInformation* IfcDocumentInformationRelationship::RelatingDocument() const { return (IfcDocumentInformation*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcDocumentInformationRelationship::setRelatingDocument(IfcDocumentInformation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcDocumentInformation >::ptr IfcDocumentInformationRelationship::RelatedDocuments() const { IfcEntityList::ptr es = *data_->getArgument(3); return es->as<IfcDocumentInformation>(); }
void IfcDocumentInformationRelationship::setRelatedDocuments(IfcTemplatedEntityList< IfcDocumentInformation >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(3,attr);} }
bool IfcDocumentInformationRelationship::hasRelationshipType() const { return !data_->getArgument(4)->isNull(); }
std::string IfcDocumentInformationRelationship::RelationshipType() const { return *data_->getArgument(4); }
void IfcDocumentInformationRelationship::setRelationshipType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcDocumentInformationRelationship::declaration() const { return *IfcDocumentInformationRelationship_type; }
const IfcParse::entity& IfcDocumentInformationRelationship::Class() { return *IfcDocumentInformationRelationship_type; }
IfcDocumentInformationRelationship::IfcDocumentInformationRelationship(IfcEntityInstanceData* e) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDocumentInformationRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDocumentInformationRelationship::IfcDocumentInformationRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcDocumentInformation* v3_RelatingDocument, IfcTemplatedEntityList< IfcDocumentInformation >::ptr v4_RelatedDocuments, boost::optional< std::string > v5_RelationshipType) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDocumentInformationRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingDocument));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedDocuments)->generalize());data_->setArgument(3,attr);} if (v5_RelationshipType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RelationshipType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcDocumentReference
bool IfcDocumentReference::hasDescription() const { return !data_->getArgument(3)->isNull(); }
std::string IfcDocumentReference::Description() const { return *data_->getArgument(3); }
void IfcDocumentReference::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcDocumentReference::hasReferencedDocument() const { return !data_->getArgument(4)->isNull(); }
IfcDocumentInformation* IfcDocumentReference::ReferencedDocument() const { return (IfcDocumentInformation*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcDocumentReference::setReferencedDocument(IfcDocumentInformation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }

IfcRelAssociatesDocument::list::ptr IfcDocumentReference::DocumentRefForObjects() const { return data_->getInverse(IfcRelAssociatesDocument_type, 5)->as<IfcRelAssociatesDocument>(); }

const IfcParse::entity& IfcDocumentReference::declaration() const { return *IfcDocumentReference_type; }
const IfcParse::entity& IfcDocumentReference::Class() { return *IfcDocumentReference_type; }
IfcDocumentReference::IfcDocumentReference(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDocumentReference_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDocumentReference::IfcDocumentReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcDocumentInformation* v5_ReferencedDocument) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDocumentReference_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Identification));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ReferencedDocument));data_->setArgument(4,attr);} }

// Function implementations for IfcDoor
bool IfcDoor::hasOverallHeight() const { return !data_->getArgument(8)->isNull(); }
double IfcDoor::OverallHeight() const { return *data_->getArgument(8); }
void IfcDoor::setOverallHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcDoor::hasOverallWidth() const { return !data_->getArgument(9)->isNull(); }
double IfcDoor::OverallWidth() const { return *data_->getArgument(9); }
void IfcDoor::setOverallWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcDoor::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcDoorTypeEnum::IfcDoorTypeEnum IfcDoor::PredefinedType() const { return IfcDoorTypeEnum::FromString(*data_->getArgument(10)); }
void IfcDoor::setPredefinedType(IfcDoorTypeEnum::IfcDoorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorTypeEnum::ToString(v)));data_->setArgument(10,attr);} }
bool IfcDoor::hasOperationType() const { return !data_->getArgument(11)->isNull(); }
IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum IfcDoor::OperationType() const { return IfcDoorTypeOperationEnum::FromString(*data_->getArgument(11)); }
void IfcDoor::setOperationType(IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorTypeOperationEnum::ToString(v)));data_->setArgument(11,attr);} }
bool IfcDoor::hasUserDefinedOperationType() const { return !data_->getArgument(12)->isNull(); }
std::string IfcDoor::UserDefinedOperationType() const { return *data_->getArgument(12); }
void IfcDoor::setUserDefinedOperationType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& IfcDoor::declaration() const { return *IfcDoor_type; }
const IfcParse::entity& IfcDoor::Class() { return *IfcDoor_type; }
IfcDoor::IfcDoor(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDoor_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDoor::IfcDoor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth, boost::optional< IfcDoorTypeEnum::IfcDoorTypeEnum > v11_PredefinedType, boost::optional< IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum > v12_OperationType, boost::optional< std::string > v13_UserDefinedOperationType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDoor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_OverallHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_OverallHeight));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_OverallWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_OverallWidth));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcDoorTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_OperationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v12_OperationType,IfcDoorTypeOperationEnum::ToString(*v12_OperationType))));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_UserDefinedOperationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_UserDefinedOperationType));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcDoorLiningProperties
bool IfcDoorLiningProperties::hasLiningDepth() const { return !data_->getArgument(4)->isNull(); }
double IfcDoorLiningProperties::LiningDepth() const { return *data_->getArgument(4); }
void IfcDoorLiningProperties::setLiningDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcDoorLiningProperties::hasLiningThickness() const { return !data_->getArgument(5)->isNull(); }
double IfcDoorLiningProperties::LiningThickness() const { return *data_->getArgument(5); }
void IfcDoorLiningProperties::setLiningThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcDoorLiningProperties::hasThresholdDepth() const { return !data_->getArgument(6)->isNull(); }
double IfcDoorLiningProperties::ThresholdDepth() const { return *data_->getArgument(6); }
void IfcDoorLiningProperties::setThresholdDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcDoorLiningProperties::hasThresholdThickness() const { return !data_->getArgument(7)->isNull(); }
double IfcDoorLiningProperties::ThresholdThickness() const { return *data_->getArgument(7); }
void IfcDoorLiningProperties::setThresholdThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcDoorLiningProperties::hasTransomThickness() const { return !data_->getArgument(8)->isNull(); }
double IfcDoorLiningProperties::TransomThickness() const { return *data_->getArgument(8); }
void IfcDoorLiningProperties::setTransomThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcDoorLiningProperties::hasTransomOffset() const { return !data_->getArgument(9)->isNull(); }
double IfcDoorLiningProperties::TransomOffset() const { return *data_->getArgument(9); }
void IfcDoorLiningProperties::setTransomOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcDoorLiningProperties::hasLiningOffset() const { return !data_->getArgument(10)->isNull(); }
double IfcDoorLiningProperties::LiningOffset() const { return *data_->getArgument(10); }
void IfcDoorLiningProperties::setLiningOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcDoorLiningProperties::hasThresholdOffset() const { return !data_->getArgument(11)->isNull(); }
double IfcDoorLiningProperties::ThresholdOffset() const { return *data_->getArgument(11); }
void IfcDoorLiningProperties::setThresholdOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcDoorLiningProperties::hasCasingThickness() const { return !data_->getArgument(12)->isNull(); }
double IfcDoorLiningProperties::CasingThickness() const { return *data_->getArgument(12); }
void IfcDoorLiningProperties::setCasingThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcDoorLiningProperties::hasCasingDepth() const { return !data_->getArgument(13)->isNull(); }
double IfcDoorLiningProperties::CasingDepth() const { return *data_->getArgument(13); }
void IfcDoorLiningProperties::setCasingDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
bool IfcDoorLiningProperties::hasShapeAspectStyle() const { return !data_->getArgument(14)->isNull(); }
IfcShapeAspect* IfcDoorLiningProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(14))); }
void IfcDoorLiningProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
bool IfcDoorLiningProperties::hasLiningToPanelOffsetX() const { return !data_->getArgument(15)->isNull(); }
double IfcDoorLiningProperties::LiningToPanelOffsetX() const { return *data_->getArgument(15); }
void IfcDoorLiningProperties::setLiningToPanelOffsetX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }
bool IfcDoorLiningProperties::hasLiningToPanelOffsetY() const { return !data_->getArgument(16)->isNull(); }
double IfcDoorLiningProperties::LiningToPanelOffsetY() const { return *data_->getArgument(16); }
void IfcDoorLiningProperties::setLiningToPanelOffsetY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(16,attr);} }


const IfcParse::entity& IfcDoorLiningProperties::declaration() const { return *IfcDoorLiningProperties_type; }
const IfcParse::entity& IfcDoorLiningProperties::Class() { return *IfcDoorLiningProperties_type; }
IfcDoorLiningProperties::IfcDoorLiningProperties(IfcEntityInstanceData* e) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDoorLiningProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDoorLiningProperties::IfcDoorLiningProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_ThresholdDepth, boost::optional< double > v8_ThresholdThickness, boost::optional< double > v9_TransomThickness, boost::optional< double > v10_TransomOffset, boost::optional< double > v11_LiningOffset, boost::optional< double > v12_ThresholdOffset, boost::optional< double > v13_CasingThickness, boost::optional< double > v14_CasingDepth, IfcShapeAspect* v15_ShapeAspectStyle, boost::optional< double > v16_LiningToPanelOffsetX, boost::optional< double > v17_LiningToPanelOffsetY) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDoorLiningProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_LiningDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LiningDepth));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LiningThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LiningThickness));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ThresholdDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ThresholdDepth));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ThresholdThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_ThresholdThickness));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_TransomThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_TransomThickness));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_TransomOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_TransomOffset));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_LiningOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_LiningOffset));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_ThresholdOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_ThresholdOffset));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_CasingThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_CasingThickness));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_CasingDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_CasingDepth));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v15_ShapeAspectStyle));data_->setArgument(14,attr);} if (v16_LiningToPanelOffsetX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_LiningToPanelOffsetX));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_LiningToPanelOffsetY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_LiningToPanelOffsetY));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } }

// Function implementations for IfcDoorPanelProperties
bool IfcDoorPanelProperties::hasPanelDepth() const { return !data_->getArgument(4)->isNull(); }
double IfcDoorPanelProperties::PanelDepth() const { return *data_->getArgument(4); }
void IfcDoorPanelProperties::setPanelDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum IfcDoorPanelProperties::PanelOperation() const { return IfcDoorPanelOperationEnum::FromString(*data_->getArgument(5)); }
void IfcDoorPanelProperties::setPanelOperation(IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorPanelOperationEnum::ToString(v)));data_->setArgument(5,attr);} }
bool IfcDoorPanelProperties::hasPanelWidth() const { return !data_->getArgument(6)->isNull(); }
double IfcDoorPanelProperties::PanelWidth() const { return *data_->getArgument(6); }
void IfcDoorPanelProperties::setPanelWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum IfcDoorPanelProperties::PanelPosition() const { return IfcDoorPanelPositionEnum::FromString(*data_->getArgument(7)); }
void IfcDoorPanelProperties::setPanelPosition(IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorPanelPositionEnum::ToString(v)));data_->setArgument(7,attr);} }
bool IfcDoorPanelProperties::hasShapeAspectStyle() const { return !data_->getArgument(8)->isNull(); }
IfcShapeAspect* IfcDoorPanelProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcDoorPanelProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcDoorPanelProperties::declaration() const { return *IfcDoorPanelProperties_type; }
const IfcParse::entity& IfcDoorPanelProperties::Class() { return *IfcDoorPanelProperties_type; }
IfcDoorPanelProperties::IfcDoorPanelProperties(IfcEntityInstanceData* e) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDoorPanelProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDoorPanelProperties::IfcDoorPanelProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_PanelDepth, IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v6_PanelOperation, boost::optional< double > v7_PanelWidth, IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v8_PanelPosition, IfcShapeAspect* v9_ShapeAspectStyle) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDoorPanelProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_PanelDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PanelDepth));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PanelOperation,IfcDoorPanelOperationEnum::ToString(v6_PanelOperation))));data_->setArgument(5,attr);} if (v7_PanelWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_PanelWidth));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PanelPosition,IfcDoorPanelPositionEnum::ToString(v8_PanelPosition))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ShapeAspectStyle));data_->setArgument(8,attr);} }

// Function implementations for IfcDoorStandardCase


const IfcParse::entity& IfcDoorStandardCase::declaration() const { return *IfcDoorStandardCase_type; }
const IfcParse::entity& IfcDoorStandardCase::Class() { return *IfcDoorStandardCase_type; }
IfcDoorStandardCase::IfcDoorStandardCase(IfcEntityInstanceData* e) : IfcDoor((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDoorStandardCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDoorStandardCase::IfcDoorStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth, boost::optional< IfcDoorTypeEnum::IfcDoorTypeEnum > v11_PredefinedType, boost::optional< IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum > v12_OperationType, boost::optional< std::string > v13_UserDefinedOperationType) : IfcDoor((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDoorStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_OverallHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_OverallHeight));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_OverallWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_OverallWidth));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcDoorTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_OperationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v12_OperationType,IfcDoorTypeOperationEnum::ToString(*v12_OperationType))));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_UserDefinedOperationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_UserDefinedOperationType));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcDoorStyle
IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum IfcDoorStyle::OperationType() const { return IfcDoorStyleOperationEnum::FromString(*data_->getArgument(8)); }
void IfcDoorStyle::setOperationType(IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorStyleOperationEnum::ToString(v)));data_->setArgument(8,attr);} }
IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum IfcDoorStyle::ConstructionType() const { return IfcDoorStyleConstructionEnum::FromString(*data_->getArgument(9)); }
void IfcDoorStyle::setConstructionType(IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorStyleConstructionEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcDoorStyle::ParameterTakesPrecedence() const { return *data_->getArgument(10); }
void IfcDoorStyle::setParameterTakesPrecedence(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcDoorStyle::Sizeable() const { return *data_->getArgument(11); }
void IfcDoorStyle::setSizeable(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }


const IfcParse::entity& IfcDoorStyle::declaration() const { return *IfcDoorStyle_type; }
const IfcParse::entity& IfcDoorStyle::Class() { return *IfcDoorStyle_type; }
IfcDoorStyle::IfcDoorStyle(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDoorStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDoorStyle::IfcDoorStyle(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v9_OperationType, IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v10_ConstructionType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable) : IfcTypeProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDoorStyle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_OperationType,IfcDoorStyleOperationEnum::ToString(v9_OperationType))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_ConstructionType,IfcDoorStyleConstructionEnum::ToString(v10_ConstructionType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ParameterTakesPrecedence));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_Sizeable));data_->setArgument(11,attr);} }

// Function implementations for IfcDoorType
IfcDoorTypeEnum::IfcDoorTypeEnum IfcDoorType::PredefinedType() const { return IfcDoorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcDoorType::setPredefinedType(IfcDoorTypeEnum::IfcDoorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum IfcDoorType::OperationType() const { return IfcDoorTypeOperationEnum::FromString(*data_->getArgument(10)); }
void IfcDoorType::setOperationType(IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorTypeOperationEnum::ToString(v)));data_->setArgument(10,attr);} }
bool IfcDoorType::hasParameterTakesPrecedence() const { return !data_->getArgument(11)->isNull(); }
bool IfcDoorType::ParameterTakesPrecedence() const { return *data_->getArgument(11); }
void IfcDoorType::setParameterTakesPrecedence(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcDoorType::hasUserDefinedOperationType() const { return !data_->getArgument(12)->isNull(); }
std::string IfcDoorType::UserDefinedOperationType() const { return *data_->getArgument(12); }
void IfcDoorType::setUserDefinedOperationType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& IfcDoorType::declaration() const { return *IfcDoorType_type; }
const IfcParse::entity& IfcDoorType::Class() { return *IfcDoorType_type; }
IfcDoorType::IfcDoorType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDoorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDoorType::IfcDoorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDoorTypeEnum::IfcDoorTypeEnum v10_PredefinedType, IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum v11_OperationType, boost::optional< bool > v12_ParameterTakesPrecedence, boost::optional< std::string > v13_UserDefinedOperationType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDoorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDoorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v11_OperationType,IfcDoorTypeOperationEnum::ToString(v11_OperationType))));data_->setArgument(10,attr);} if (v12_ParameterTakesPrecedence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_ParameterTakesPrecedence));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_UserDefinedOperationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_UserDefinedOperationType));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcDraughtingPreDefinedColour


const IfcParse::entity& IfcDraughtingPreDefinedColour::declaration() const { return *IfcDraughtingPreDefinedColour_type; }
const IfcParse::entity& IfcDraughtingPreDefinedColour::Class() { return *IfcDraughtingPreDefinedColour_type; }
IfcDraughtingPreDefinedColour::IfcDraughtingPreDefinedColour(IfcEntityInstanceData* e) : IfcPreDefinedColour((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDraughtingPreDefinedColour_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDraughtingPreDefinedColour::IfcDraughtingPreDefinedColour(std::string v1_Name) : IfcPreDefinedColour((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDraughtingPreDefinedColour_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcDraughtingPreDefinedCurveFont


const IfcParse::entity& IfcDraughtingPreDefinedCurveFont::declaration() const { return *IfcDraughtingPreDefinedCurveFont_type; }
const IfcParse::entity& IfcDraughtingPreDefinedCurveFont::Class() { return *IfcDraughtingPreDefinedCurveFont_type; }
IfcDraughtingPreDefinedCurveFont::IfcDraughtingPreDefinedCurveFont(IfcEntityInstanceData* e) : IfcPreDefinedCurveFont((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDraughtingPreDefinedCurveFont_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDraughtingPreDefinedCurveFont::IfcDraughtingPreDefinedCurveFont(std::string v1_Name) : IfcPreDefinedCurveFont((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDraughtingPreDefinedCurveFont_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcDuctFitting
bool IfcDuctFitting::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum IfcDuctFitting::PredefinedType() const { return IfcDuctFittingTypeEnum::FromString(*data_->getArgument(8)); }
void IfcDuctFitting::setPredefinedType(IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDuctFittingTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcDuctFitting::declaration() const { return *IfcDuctFitting_type; }
const IfcParse::entity& IfcDuctFitting::Class() { return *IfcDuctFitting_type; }
IfcDuctFitting::IfcDuctFitting(IfcEntityInstanceData* e) : IfcFlowFitting((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDuctFitting_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDuctFitting::IfcDuctFitting(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDuctFitting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcDuctFittingTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDuctFittingType
IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum IfcDuctFittingType::PredefinedType() const { return IfcDuctFittingTypeEnum::FromString(*data_->getArgument(9)); }
void IfcDuctFittingType::setPredefinedType(IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDuctFittingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcDuctFittingType::declaration() const { return *IfcDuctFittingType_type; }
const IfcParse::entity& IfcDuctFittingType::Class() { return *IfcDuctFittingType_type; }
IfcDuctFittingType::IfcDuctFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDuctFittingType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDuctFittingType::IfcDuctFittingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDuctFittingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDuctFittingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcDuctSegment
bool IfcDuctSegment::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum IfcDuctSegment::PredefinedType() const { return IfcDuctSegmentTypeEnum::FromString(*data_->getArgument(8)); }
void IfcDuctSegment::setPredefinedType(IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDuctSegmentTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcDuctSegment::declaration() const { return *IfcDuctSegment_type; }
const IfcParse::entity& IfcDuctSegment::Class() { return *IfcDuctSegment_type; }
IfcDuctSegment::IfcDuctSegment(IfcEntityInstanceData* e) : IfcFlowSegment((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDuctSegment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDuctSegment::IfcDuctSegment(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum > v9_PredefinedType) : IfcFlowSegment((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDuctSegment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcDuctSegmentTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDuctSegmentType
IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum IfcDuctSegmentType::PredefinedType() const { return IfcDuctSegmentTypeEnum::FromString(*data_->getArgument(9)); }
void IfcDuctSegmentType::setPredefinedType(IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDuctSegmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcDuctSegmentType::declaration() const { return *IfcDuctSegmentType_type; }
const IfcParse::entity& IfcDuctSegmentType::Class() { return *IfcDuctSegmentType_type; }
IfcDuctSegmentType::IfcDuctSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDuctSegmentType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDuctSegmentType::IfcDuctSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDuctSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDuctSegmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcDuctSilencer
bool IfcDuctSilencer::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum IfcDuctSilencer::PredefinedType() const { return IfcDuctSilencerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcDuctSilencer::setPredefinedType(IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDuctSilencerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcDuctSilencer::declaration() const { return *IfcDuctSilencer_type; }
const IfcParse::entity& IfcDuctSilencer::Class() { return *IfcDuctSilencer_type; }
IfcDuctSilencer::IfcDuctSilencer(IfcEntityInstanceData* e) : IfcFlowTreatmentDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDuctSilencer_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDuctSilencer::IfcDuctSilencer(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum > v9_PredefinedType) : IfcFlowTreatmentDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDuctSilencer_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcDuctSilencerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDuctSilencerType
IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum IfcDuctSilencerType::PredefinedType() const { return IfcDuctSilencerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcDuctSilencerType::setPredefinedType(IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDuctSilencerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcDuctSilencerType::declaration() const { return *IfcDuctSilencerType_type; }
const IfcParse::entity& IfcDuctSilencerType::Class() { return *IfcDuctSilencerType_type; }
IfcDuctSilencerType::IfcDuctSilencerType(IfcEntityInstanceData* e) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcDuctSilencerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcDuctSilencerType::IfcDuctSilencerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcDuctSilencerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDuctSilencerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcEdge
IfcVertex* IfcEdge::EdgeStart() const { return (IfcVertex*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcEdge::setEdgeStart(IfcVertex* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcVertex* IfcEdge::EdgeEnd() const { return (IfcVertex*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcEdge::setEdgeEnd(IfcVertex* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcEdge::declaration() const { return *IfcEdge_type; }
const IfcParse::entity& IfcEdge::Class() { return *IfcEdge_type; }
IfcEdge::IfcEdge(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEdge_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEdge::IfcEdge(IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEdge_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeStart));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EdgeEnd));data_->setArgument(1,attr);} }

// Function implementations for IfcEdgeCurve
IfcCurve* IfcEdgeCurve::EdgeGeometry() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcEdgeCurve::setEdgeGeometry(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcEdgeCurve::SameSense() const { return *data_->getArgument(3); }
void IfcEdgeCurve::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcEdgeCurve::declaration() const { return *IfcEdgeCurve_type; }
const IfcParse::entity& IfcEdgeCurve::Class() { return *IfcEdgeCurve_type; }
IfcEdgeCurve::IfcEdgeCurve(IfcEntityInstanceData* e) : IfcEdge((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEdgeCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEdgeCurve::IfcEdgeCurve(IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcCurve* v3_EdgeGeometry, bool v4_SameSense) : IfcEdge((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEdgeCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeStart));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EdgeEnd));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EdgeGeometry));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_SameSense));data_->setArgument(3,attr);} }

// Function implementations for IfcEdgeLoop
IfcTemplatedEntityList< IfcOrientedEdge >::ptr IfcEdgeLoop::EdgeList() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcOrientedEdge>(); }
void IfcEdgeLoop::setEdgeList(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& IfcEdgeLoop::declaration() const { return *IfcEdgeLoop_type; }
const IfcParse::entity& IfcEdgeLoop::Class() { return *IfcEdgeLoop_type; }
IfcEdgeLoop::IfcEdgeLoop(IfcEntityInstanceData* e) : IfcLoop((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEdgeLoop_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEdgeLoop::IfcEdgeLoop(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v1_EdgeList) : IfcLoop((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEdgeLoop_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeList)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcElectricAppliance
bool IfcElectricAppliance::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum IfcElectricAppliance::PredefinedType() const { return IfcElectricApplianceTypeEnum::FromString(*data_->getArgument(8)); }
void IfcElectricAppliance::setPredefinedType(IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricApplianceTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcElectricAppliance::declaration() const { return *IfcElectricAppliance_type; }
const IfcParse::entity& IfcElectricAppliance::Class() { return *IfcElectricAppliance_type; }
IfcElectricAppliance::IfcElectricAppliance(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricAppliance_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricAppliance::IfcElectricAppliance(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricAppliance_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcElectricApplianceTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElectricApplianceType
IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum IfcElectricApplianceType::PredefinedType() const { return IfcElectricApplianceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcElectricApplianceType::setPredefinedType(IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricApplianceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcElectricApplianceType::declaration() const { return *IfcElectricApplianceType_type; }
const IfcParse::entity& IfcElectricApplianceType::Class() { return *IfcElectricApplianceType_type; }
IfcElectricApplianceType::IfcElectricApplianceType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricApplianceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricApplianceType::IfcElectricApplianceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricApplianceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricApplianceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricDistributionBoard
bool IfcElectricDistributionBoard::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum IfcElectricDistributionBoard::PredefinedType() const { return IfcElectricDistributionBoardTypeEnum::FromString(*data_->getArgument(8)); }
void IfcElectricDistributionBoard::setPredefinedType(IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricDistributionBoardTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcElectricDistributionBoard::declaration() const { return *IfcElectricDistributionBoard_type; }
const IfcParse::entity& IfcElectricDistributionBoard::Class() { return *IfcElectricDistributionBoard_type; }
IfcElectricDistributionBoard::IfcElectricDistributionBoard(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricDistributionBoard_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricDistributionBoard::IfcElectricDistributionBoard(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum > v9_PredefinedType) : IfcFlowController((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricDistributionBoard_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcElectricDistributionBoardTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElectricDistributionBoardType
IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum IfcElectricDistributionBoardType::PredefinedType() const { return IfcElectricDistributionBoardTypeEnum::FromString(*data_->getArgument(9)); }
void IfcElectricDistributionBoardType::setPredefinedType(IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricDistributionBoardTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcElectricDistributionBoardType::declaration() const { return *IfcElectricDistributionBoardType_type; }
const IfcParse::entity& IfcElectricDistributionBoardType::Class() { return *IfcElectricDistributionBoardType_type; }
IfcElectricDistributionBoardType::IfcElectricDistributionBoardType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricDistributionBoardType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricDistributionBoardType::IfcElectricDistributionBoardType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricDistributionBoardType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricDistributionBoardTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricFlowStorageDevice
bool IfcElectricFlowStorageDevice::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum IfcElectricFlowStorageDevice::PredefinedType() const { return IfcElectricFlowStorageDeviceTypeEnum::FromString(*data_->getArgument(8)); }
void IfcElectricFlowStorageDevice::setPredefinedType(IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricFlowStorageDeviceTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcElectricFlowStorageDevice::declaration() const { return *IfcElectricFlowStorageDevice_type; }
const IfcParse::entity& IfcElectricFlowStorageDevice::Class() { return *IfcElectricFlowStorageDevice_type; }
IfcElectricFlowStorageDevice::IfcElectricFlowStorageDevice(IfcEntityInstanceData* e) : IfcFlowStorageDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricFlowStorageDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricFlowStorageDevice::IfcElectricFlowStorageDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum > v9_PredefinedType) : IfcFlowStorageDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricFlowStorageDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcElectricFlowStorageDeviceTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElectricFlowStorageDeviceType
IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum IfcElectricFlowStorageDeviceType::PredefinedType() const { return IfcElectricFlowStorageDeviceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcElectricFlowStorageDeviceType::setPredefinedType(IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricFlowStorageDeviceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcElectricFlowStorageDeviceType::declaration() const { return *IfcElectricFlowStorageDeviceType_type; }
const IfcParse::entity& IfcElectricFlowStorageDeviceType::Class() { return *IfcElectricFlowStorageDeviceType_type; }
IfcElectricFlowStorageDeviceType::IfcElectricFlowStorageDeviceType(IfcEntityInstanceData* e) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricFlowStorageDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricFlowStorageDeviceType::IfcElectricFlowStorageDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v10_PredefinedType) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricFlowStorageDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricFlowStorageDeviceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricGenerator
bool IfcElectricGenerator::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum IfcElectricGenerator::PredefinedType() const { return IfcElectricGeneratorTypeEnum::FromString(*data_->getArgument(8)); }
void IfcElectricGenerator::setPredefinedType(IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricGeneratorTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcElectricGenerator::declaration() const { return *IfcElectricGenerator_type; }
const IfcParse::entity& IfcElectricGenerator::Class() { return *IfcElectricGenerator_type; }
IfcElectricGenerator::IfcElectricGenerator(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricGenerator_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricGenerator::IfcElectricGenerator(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricGenerator_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcElectricGeneratorTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElectricGeneratorType
IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum IfcElectricGeneratorType::PredefinedType() const { return IfcElectricGeneratorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcElectricGeneratorType::setPredefinedType(IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricGeneratorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcElectricGeneratorType::declaration() const { return *IfcElectricGeneratorType_type; }
const IfcParse::entity& IfcElectricGeneratorType::Class() { return *IfcElectricGeneratorType_type; }
IfcElectricGeneratorType::IfcElectricGeneratorType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricGeneratorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricGeneratorType::IfcElectricGeneratorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricGeneratorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricGeneratorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricMotor
bool IfcElectricMotor::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum IfcElectricMotor::PredefinedType() const { return IfcElectricMotorTypeEnum::FromString(*data_->getArgument(8)); }
void IfcElectricMotor::setPredefinedType(IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricMotorTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcElectricMotor::declaration() const { return *IfcElectricMotor_type; }
const IfcParse::entity& IfcElectricMotor::Class() { return *IfcElectricMotor_type; }
IfcElectricMotor::IfcElectricMotor(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricMotor_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricMotor::IfcElectricMotor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricMotor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcElectricMotorTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElectricMotorType
IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum IfcElectricMotorType::PredefinedType() const { return IfcElectricMotorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcElectricMotorType::setPredefinedType(IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricMotorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcElectricMotorType::declaration() const { return *IfcElectricMotorType_type; }
const IfcParse::entity& IfcElectricMotorType::Class() { return *IfcElectricMotorType_type; }
IfcElectricMotorType::IfcElectricMotorType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricMotorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricMotorType::IfcElectricMotorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricMotorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricMotorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricTimeControl
bool IfcElectricTimeControl::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum IfcElectricTimeControl::PredefinedType() const { return IfcElectricTimeControlTypeEnum::FromString(*data_->getArgument(8)); }
void IfcElectricTimeControl::setPredefinedType(IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricTimeControlTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcElectricTimeControl::declaration() const { return *IfcElectricTimeControl_type; }
const IfcParse::entity& IfcElectricTimeControl::Class() { return *IfcElectricTimeControl_type; }
IfcElectricTimeControl::IfcElectricTimeControl(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricTimeControl_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricTimeControl::IfcElectricTimeControl(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum > v9_PredefinedType) : IfcFlowController((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricTimeControl_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcElectricTimeControlTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElectricTimeControlType
IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum IfcElectricTimeControlType::PredefinedType() const { return IfcElectricTimeControlTypeEnum::FromString(*data_->getArgument(9)); }
void IfcElectricTimeControlType::setPredefinedType(IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricTimeControlTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcElectricTimeControlType::declaration() const { return *IfcElectricTimeControlType_type; }
const IfcParse::entity& IfcElectricTimeControlType::Class() { return *IfcElectricTimeControlType_type; }
IfcElectricTimeControlType::IfcElectricTimeControlType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElectricTimeControlType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElectricTimeControlType::IfcElectricTimeControlType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElectricTimeControlType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricTimeControlTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElement
bool IfcElement::hasTag() const { return !data_->getArgument(7)->isNull(); }
std::string IfcElement::Tag() const { return *data_->getArgument(7); }
void IfcElement::setTag(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }

IfcRelFillsElement::list::ptr IfcElement::FillsVoids() const { return data_->getInverse(IfcRelFillsElement_type, 5)->as<IfcRelFillsElement>(); }
IfcRelConnectsElements::list::ptr IfcElement::ConnectedTo() const { return data_->getInverse(IfcRelConnectsElements_type, 5)->as<IfcRelConnectsElements>(); }
IfcRelInterferesElements::list::ptr IfcElement::IsInterferedByElements() const { return data_->getInverse(IfcRelInterferesElements_type, 5)->as<IfcRelInterferesElements>(); }
IfcRelInterferesElements::list::ptr IfcElement::InterferesElements() const { return data_->getInverse(IfcRelInterferesElements_type, 4)->as<IfcRelInterferesElements>(); }
IfcRelProjectsElement::list::ptr IfcElement::HasProjections() const { return data_->getInverse(IfcRelProjectsElement_type, 4)->as<IfcRelProjectsElement>(); }
IfcRelReferencedInSpatialStructure::list::ptr IfcElement::ReferencedInStructures() const { return data_->getInverse(IfcRelReferencedInSpatialStructure_type, 4)->as<IfcRelReferencedInSpatialStructure>(); }
IfcRelVoidsElement::list::ptr IfcElement::HasOpenings() const { return data_->getInverse(IfcRelVoidsElement_type, 4)->as<IfcRelVoidsElement>(); }
IfcRelConnectsWithRealizingElements::list::ptr IfcElement::IsConnectionRealization() const { return data_->getInverse(IfcRelConnectsWithRealizingElements_type, 7)->as<IfcRelConnectsWithRealizingElements>(); }
IfcRelSpaceBoundary::list::ptr IfcElement::ProvidesBoundaries() const { return data_->getInverse(IfcRelSpaceBoundary_type, 5)->as<IfcRelSpaceBoundary>(); }
IfcRelConnectsElements::list::ptr IfcElement::ConnectedFrom() const { return data_->getInverse(IfcRelConnectsElements_type, 6)->as<IfcRelConnectsElements>(); }
IfcRelContainedInSpatialStructure::list::ptr IfcElement::ContainedInStructure() const { return data_->getInverse(IfcRelContainedInSpatialStructure_type, 4)->as<IfcRelContainedInSpatialStructure>(); }
IfcRelCoversBldgElements::list::ptr IfcElement::HasCoverings() const { return data_->getInverse(IfcRelCoversBldgElements_type, 4)->as<IfcRelCoversBldgElements>(); }

const IfcParse::entity& IfcElement::declaration() const { return *IfcElement_type; }
const IfcParse::entity& IfcElement::Class() { return *IfcElement_type; }
IfcElement::IfcElement(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElement::IfcElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcElementAssembly
bool IfcElementAssembly::hasAssemblyPlace() const { return !data_->getArgument(8)->isNull(); }
IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum IfcElementAssembly::AssemblyPlace() const { return IfcAssemblyPlaceEnum::FromString(*data_->getArgument(8)); }
void IfcElementAssembly::setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAssemblyPlaceEnum::ToString(v)));data_->setArgument(8,attr);} }
bool IfcElementAssembly::hasPredefinedType() const { return !data_->getArgument(9)->isNull(); }
IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum IfcElementAssembly::PredefinedType() const { return IfcElementAssemblyTypeEnum::FromString(*data_->getArgument(9)); }
void IfcElementAssembly::setPredefinedType(IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElementAssemblyTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcElementAssembly::declaration() const { return *IfcElementAssembly_type; }
const IfcParse::entity& IfcElementAssembly::Class() { return *IfcElementAssembly_type; }
IfcElementAssembly::IfcElementAssembly(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElementAssembly_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElementAssembly::IfcElementAssembly(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum > v9_AssemblyPlace, boost::optional< IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum > v10_PredefinedType) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElementAssembly_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_AssemblyPlace) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_AssemblyPlace,IfcAssemblyPlaceEnum::ToString(*v9_AssemblyPlace))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v10_PredefinedType,IfcElementAssemblyTypeEnum::ToString(*v10_PredefinedType))));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcElementAssemblyType
IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum IfcElementAssemblyType::PredefinedType() const { return IfcElementAssemblyTypeEnum::FromString(*data_->getArgument(9)); }
void IfcElementAssemblyType::setPredefinedType(IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElementAssemblyTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcElementAssemblyType::declaration() const { return *IfcElementAssemblyType_type; }
const IfcParse::entity& IfcElementAssemblyType::Class() { return *IfcElementAssemblyType_type; }
IfcElementAssemblyType::IfcElementAssemblyType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElementAssemblyType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElementAssemblyType::IfcElementAssemblyType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v10_PredefinedType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElementAssemblyType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElementAssemblyTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElementComponent


const IfcParse::entity& IfcElementComponent::declaration() const { return *IfcElementComponent_type; }
const IfcParse::entity& IfcElementComponent::Class() { return *IfcElementComponent_type; }
IfcElementComponent::IfcElementComponent(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElementComponent_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElementComponent::IfcElementComponent(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElementComponent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcElementComponentType


const IfcParse::entity& IfcElementComponentType::declaration() const { return *IfcElementComponentType_type; }
const IfcParse::entity& IfcElementComponentType::Class() { return *IfcElementComponentType_type; }
IfcElementComponentType::IfcElementComponentType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElementComponentType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElementComponentType::IfcElementComponentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElementComponentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElementQuantity
bool IfcElementQuantity::hasMethodOfMeasurement() const { return !data_->getArgument(4)->isNull(); }
std::string IfcElementQuantity::MethodOfMeasurement() const { return *data_->getArgument(4); }
void IfcElementQuantity::setMethodOfMeasurement(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr IfcElementQuantity::Quantities() const { IfcEntityList::ptr es = *data_->getArgument(5); return es->as<IfcPhysicalQuantity>(); }
void IfcElementQuantity::setQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& IfcElementQuantity::declaration() const { return *IfcElementQuantity_type; }
const IfcParse::entity& IfcElementQuantity::Class() { return *IfcElementQuantity_type; }
IfcElementQuantity::IfcElementQuantity(IfcEntityInstanceData* e) : IfcQuantitySet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElementQuantity_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElementQuantity::IfcElementQuantity(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_MethodOfMeasurement, IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v6_Quantities) : IfcQuantitySet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElementQuantity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MethodOfMeasurement) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MethodOfMeasurement));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Quantities)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcElementType
bool IfcElementType::hasElementType() const { return !data_->getArgument(8)->isNull(); }
std::string IfcElementType::ElementType() const { return *data_->getArgument(8); }
void IfcElementType::setElementType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcElementType::declaration() const { return *IfcElementType_type; }
const IfcParse::entity& IfcElementType::Class() { return *IfcElementType_type; }
IfcElementType::IfcElementType(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElementType::IfcElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcTypeProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElementarySurface
IfcAxis2Placement3D* IfcElementarySurface::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcElementarySurface::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcElementarySurface::declaration() const { return *IfcElementarySurface_type; }
const IfcParse::entity& IfcElementarySurface::Class() { return *IfcElementarySurface_type; }
IfcElementarySurface::IfcElementarySurface(IfcEntityInstanceData* e) : IfcSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcElementarySurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcElementarySurface::IfcElementarySurface(IfcAxis2Placement3D* v1_Position) : IfcSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcElementarySurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);} }

// Function implementations for IfcEllipse
double IfcEllipse::SemiAxis1() const { return *data_->getArgument(1); }
void IfcEllipse::setSemiAxis1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcEllipse::SemiAxis2() const { return *data_->getArgument(2); }
void IfcEllipse::setSemiAxis2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcEllipse::declaration() const { return *IfcEllipse_type; }
const IfcParse::entity& IfcEllipse::Class() { return *IfcEllipse_type; }
IfcEllipse::IfcEllipse(IfcEntityInstanceData* e) : IfcConic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEllipse_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEllipse::IfcEllipse(IfcAxis2Placement* v1_Position, double v2_SemiAxis1, double v3_SemiAxis2) : IfcConic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEllipse_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SemiAxis1));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SemiAxis2));data_->setArgument(2,attr);} }

// Function implementations for IfcEllipseProfileDef
double IfcEllipseProfileDef::SemiAxis1() const { return *data_->getArgument(3); }
void IfcEllipseProfileDef::setSemiAxis1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcEllipseProfileDef::SemiAxis2() const { return *data_->getArgument(4); }
void IfcEllipseProfileDef::setSemiAxis2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcEllipseProfileDef::declaration() const { return *IfcEllipseProfileDef_type; }
const IfcParse::entity& IfcEllipseProfileDef::Class() { return *IfcEllipseProfileDef_type; }
IfcEllipseProfileDef::IfcEllipseProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEllipseProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEllipseProfileDef::IfcEllipseProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_SemiAxis1, double v5_SemiAxis2) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEllipseProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_SemiAxis1));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SemiAxis2));data_->setArgument(4,attr);} }

// Function implementations for IfcEnergyConversionDevice


const IfcParse::entity& IfcEnergyConversionDevice::declaration() const { return *IfcEnergyConversionDevice_type; }
const IfcParse::entity& IfcEnergyConversionDevice::Class() { return *IfcEnergyConversionDevice_type; }
IfcEnergyConversionDevice::IfcEnergyConversionDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEnergyConversionDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEnergyConversionDevice::IfcEnergyConversionDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEnergyConversionDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcEnergyConversionDeviceType


const IfcParse::entity& IfcEnergyConversionDeviceType::declaration() const { return *IfcEnergyConversionDeviceType_type; }
const IfcParse::entity& IfcEnergyConversionDeviceType::Class() { return *IfcEnergyConversionDeviceType_type; }
IfcEnergyConversionDeviceType::IfcEnergyConversionDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEnergyConversionDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEnergyConversionDeviceType::IfcEnergyConversionDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEnergyConversionDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcEngine
bool IfcEngine::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcEngineTypeEnum::IfcEngineTypeEnum IfcEngine::PredefinedType() const { return IfcEngineTypeEnum::FromString(*data_->getArgument(8)); }
void IfcEngine::setPredefinedType(IfcEngineTypeEnum::IfcEngineTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEngineTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcEngine::declaration() const { return *IfcEngine_type; }
const IfcParse::entity& IfcEngine::Class() { return *IfcEngine_type; }
IfcEngine::IfcEngine(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEngine_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEngine::IfcEngine(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcEngineTypeEnum::IfcEngineTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEngine_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcEngineTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcEngineType
IfcEngineTypeEnum::IfcEngineTypeEnum IfcEngineType::PredefinedType() const { return IfcEngineTypeEnum::FromString(*data_->getArgument(9)); }
void IfcEngineType::setPredefinedType(IfcEngineTypeEnum::IfcEngineTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEngineTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcEngineType::declaration() const { return *IfcEngineType_type; }
const IfcParse::entity& IfcEngineType::Class() { return *IfcEngineType_type; }
IfcEngineType::IfcEngineType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEngineType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEngineType::IfcEngineType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEngineTypeEnum::IfcEngineTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEngineType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcEngineTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcEvaporativeCooler
bool IfcEvaporativeCooler::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum IfcEvaporativeCooler::PredefinedType() const { return IfcEvaporativeCoolerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcEvaporativeCooler::setPredefinedType(IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEvaporativeCoolerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcEvaporativeCooler::declaration() const { return *IfcEvaporativeCooler_type; }
const IfcParse::entity& IfcEvaporativeCooler::Class() { return *IfcEvaporativeCooler_type; }
IfcEvaporativeCooler::IfcEvaporativeCooler(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEvaporativeCooler_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEvaporativeCooler::IfcEvaporativeCooler(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEvaporativeCooler_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcEvaporativeCoolerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcEvaporativeCoolerType
IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum IfcEvaporativeCoolerType::PredefinedType() const { return IfcEvaporativeCoolerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcEvaporativeCoolerType::setPredefinedType(IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEvaporativeCoolerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcEvaporativeCoolerType::declaration() const { return *IfcEvaporativeCoolerType_type; }
const IfcParse::entity& IfcEvaporativeCoolerType::Class() { return *IfcEvaporativeCoolerType_type; }
IfcEvaporativeCoolerType::IfcEvaporativeCoolerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEvaporativeCoolerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEvaporativeCoolerType::IfcEvaporativeCoolerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEvaporativeCoolerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcEvaporativeCoolerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcEvaporator
bool IfcEvaporator::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum IfcEvaporator::PredefinedType() const { return IfcEvaporatorTypeEnum::FromString(*data_->getArgument(8)); }
void IfcEvaporator::setPredefinedType(IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEvaporatorTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcEvaporator::declaration() const { return *IfcEvaporator_type; }
const IfcParse::entity& IfcEvaporator::Class() { return *IfcEvaporator_type; }
IfcEvaporator::IfcEvaporator(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEvaporator_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEvaporator::IfcEvaporator(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEvaporator_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcEvaporatorTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcEvaporatorType
IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum IfcEvaporatorType::PredefinedType() const { return IfcEvaporatorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcEvaporatorType::setPredefinedType(IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEvaporatorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcEvaporatorType::declaration() const { return *IfcEvaporatorType_type; }
const IfcParse::entity& IfcEvaporatorType::Class() { return *IfcEvaporatorType_type; }
IfcEvaporatorType::IfcEvaporatorType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEvaporatorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEvaporatorType::IfcEvaporatorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEvaporatorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcEvaporatorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcEvent
bool IfcEvent::hasPredefinedType() const { return !data_->getArgument(7)->isNull(); }
IfcEventTypeEnum::IfcEventTypeEnum IfcEvent::PredefinedType() const { return IfcEventTypeEnum::FromString(*data_->getArgument(7)); }
void IfcEvent::setPredefinedType(IfcEventTypeEnum::IfcEventTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEventTypeEnum::ToString(v)));data_->setArgument(7,attr);} }
bool IfcEvent::hasEventTriggerType() const { return !data_->getArgument(8)->isNull(); }
IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum IfcEvent::EventTriggerType() const { return IfcEventTriggerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcEvent::setEventTriggerType(IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEventTriggerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }
bool IfcEvent::hasUserDefinedEventTriggerType() const { return !data_->getArgument(9)->isNull(); }
std::string IfcEvent::UserDefinedEventTriggerType() const { return *data_->getArgument(9); }
void IfcEvent::setUserDefinedEventTriggerType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcEvent::hasEventOccurenceTime() const { return !data_->getArgument(10)->isNull(); }
IfcEventTime* IfcEvent::EventOccurenceTime() const { return (IfcEventTime*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(10))); }
void IfcEvent::setEventOccurenceTime(IfcEventTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcEvent::declaration() const { return *IfcEvent_type; }
const IfcParse::entity& IfcEvent::Class() { return *IfcEvent_type; }
IfcEvent::IfcEvent(IfcEntityInstanceData* e) : IfcProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEvent_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEvent::IfcEvent(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, boost::optional< IfcEventTypeEnum::IfcEventTypeEnum > v8_PredefinedType, boost::optional< IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum > v9_EventTriggerType, boost::optional< std::string > v10_UserDefinedEventTriggerType, IfcEventTime* v11_EventOccurenceTime) : IfcProcess((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEvent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_PredefinedType,IfcEventTypeEnum::ToString(*v8_PredefinedType))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_EventTriggerType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_EventTriggerType,IfcEventTriggerTypeEnum::ToString(*v9_EventTriggerType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_UserDefinedEventTriggerType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_UserDefinedEventTriggerType));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_EventOccurenceTime));data_->setArgument(10,attr);} }

// Function implementations for IfcEventTime
bool IfcEventTime::hasActualDate() const { return !data_->getArgument(3)->isNull(); }
std::string IfcEventTime::ActualDate() const { return *data_->getArgument(3); }
void IfcEventTime::setActualDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcEventTime::hasEarlyDate() const { return !data_->getArgument(4)->isNull(); }
std::string IfcEventTime::EarlyDate() const { return *data_->getArgument(4); }
void IfcEventTime::setEarlyDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcEventTime::hasLateDate() const { return !data_->getArgument(5)->isNull(); }
std::string IfcEventTime::LateDate() const { return *data_->getArgument(5); }
void IfcEventTime::setLateDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcEventTime::hasScheduleDate() const { return !data_->getArgument(6)->isNull(); }
std::string IfcEventTime::ScheduleDate() const { return *data_->getArgument(6); }
void IfcEventTime::setScheduleDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcEventTime::declaration() const { return *IfcEventTime_type; }
const IfcParse::entity& IfcEventTime::Class() { return *IfcEventTime_type; }
IfcEventTime::IfcEventTime(IfcEntityInstanceData* e) : IfcSchedulingTime((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEventTime_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEventTime::IfcEventTime(boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, boost::optional< std::string > v4_ActualDate, boost::optional< std::string > v5_EarlyDate, boost::optional< std::string > v6_LateDate, boost::optional< std::string > v7_ScheduleDate) : IfcSchedulingTime((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEventTime_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin))));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedDataOrigin));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ActualDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ActualDate));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_EarlyDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_EarlyDate));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LateDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LateDate));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ScheduleDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ScheduleDate));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcEventType
IfcEventTypeEnum::IfcEventTypeEnum IfcEventType::PredefinedType() const { return IfcEventTypeEnum::FromString(*data_->getArgument(9)); }
void IfcEventType::setPredefinedType(IfcEventTypeEnum::IfcEventTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEventTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum IfcEventType::EventTriggerType() const { return IfcEventTriggerTypeEnum::FromString(*data_->getArgument(10)); }
void IfcEventType::setEventTriggerType(IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEventTriggerTypeEnum::ToString(v)));data_->setArgument(10,attr);} }
bool IfcEventType::hasUserDefinedEventTriggerType() const { return !data_->getArgument(11)->isNull(); }
std::string IfcEventType::UserDefinedEventTriggerType() const { return *data_->getArgument(11); }
void IfcEventType::setUserDefinedEventTriggerType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }


const IfcParse::entity& IfcEventType::declaration() const { return *IfcEventType_type; }
const IfcParse::entity& IfcEventType::Class() { return *IfcEventType_type; }
IfcEventType::IfcEventType(IfcEntityInstanceData* e) : IfcTypeProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcEventType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcEventType::IfcEventType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ProcessType, IfcEventTypeEnum::IfcEventTypeEnum v10_PredefinedType, IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum v11_EventTriggerType, boost::optional< std::string > v12_UserDefinedEventTriggerType) : IfcTypeProcess((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcEventType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ProcessType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ProcessType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcEventTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v11_EventTriggerType,IfcEventTriggerTypeEnum::ToString(v11_EventTriggerType))));data_->setArgument(10,attr);} if (v12_UserDefinedEventTriggerType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_UserDefinedEventTriggerType));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } }

// Function implementations for IfcExtendedProperties
bool IfcExtendedProperties::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcExtendedProperties::Name() const { return *data_->getArgument(0); }
void IfcExtendedProperties::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcExtendedProperties::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcExtendedProperties::Description() const { return *data_->getArgument(1); }
void IfcExtendedProperties::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcTemplatedEntityList< IfcProperty >::ptr IfcExtendedProperties::Properties() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcProperty>(); }
void IfcExtendedProperties::setProperties(IfcTemplatedEntityList< IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& IfcExtendedProperties::declaration() const { return *IfcExtendedProperties_type; }
const IfcParse::entity& IfcExtendedProperties::Class() { return *IfcExtendedProperties_type; }
IfcExtendedProperties::IfcExtendedProperties(IfcEntityInstanceData* e) : IfcPropertyAbstraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcExtendedProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExtendedProperties::IfcExtendedProperties(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcProperty >::ptr v3_Properties) : IfcPropertyAbstraction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcExtendedProperties_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Properties)->generalize());data_->setArgument(2,attr);} }

// Function implementations for IfcExternalInformation


const IfcParse::entity& IfcExternalInformation::declaration() const { return *IfcExternalInformation_type; }
const IfcParse::entity& IfcExternalInformation::Class() { return *IfcExternalInformation_type; }
IfcExternalInformation::IfcExternalInformation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcExternalInformation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExternalInformation::IfcExternalInformation() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcExternalInformation_type);  }

// Function implementations for IfcExternalReference
bool IfcExternalReference::hasLocation() const { return !data_->getArgument(0)->isNull(); }
std::string IfcExternalReference::Location() const { return *data_->getArgument(0); }
void IfcExternalReference::setLocation(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcExternalReference::hasIdentification() const { return !data_->getArgument(1)->isNull(); }
std::string IfcExternalReference::Identification() const { return *data_->getArgument(1); }
void IfcExternalReference::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcExternalReference::hasName() const { return !data_->getArgument(2)->isNull(); }
std::string IfcExternalReference::Name() const { return *data_->getArgument(2); }
void IfcExternalReference::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcExternalReference::ExternalReferenceForResources() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 2)->as<IfcExternalReferenceRelationship>(); }

const IfcParse::entity& IfcExternalReference::declaration() const { return *IfcExternalReference_type; }
const IfcParse::entity& IfcExternalReference::Class() { return *IfcExternalReference_type; }
IfcExternalReference::IfcExternalReference(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcExternalReference_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExternalReference::IfcExternalReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcExternalReference_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Identification));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcExternalReferenceRelationship
IfcExternalReference* IfcExternalReferenceRelationship::RelatingReference() const { return (IfcExternalReference*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcExternalReferenceRelationship::setRelatingReference(IfcExternalReference* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcEntityList::ptr IfcExternalReferenceRelationship::RelatedResourceObjects() const { return *data_->getArgument(3); }
void IfcExternalReferenceRelationship::setRelatedResourceObjects(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcExternalReferenceRelationship::declaration() const { return *IfcExternalReferenceRelationship_type; }
const IfcParse::entity& IfcExternalReferenceRelationship::Class() { return *IfcExternalReferenceRelationship_type; }
IfcExternalReferenceRelationship::IfcExternalReferenceRelationship(IfcEntityInstanceData* e) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcExternalReferenceRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExternalReferenceRelationship::IfcExternalReferenceRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcExternalReference* v3_RelatingReference, IfcEntityList::ptr v4_RelatedResourceObjects) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcExternalReferenceRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingReference));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedResourceObjects));data_->setArgument(3,attr);} }

// Function implementations for IfcExternalSpatialElement
bool IfcExternalSpatialElement::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum IfcExternalSpatialElement::PredefinedType() const { return IfcExternalSpatialElementTypeEnum::FromString(*data_->getArgument(8)); }
void IfcExternalSpatialElement::setPredefinedType(IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcExternalSpatialElementTypeEnum::ToString(v)));data_->setArgument(8,attr);} }

IfcRelSpaceBoundary::list::ptr IfcExternalSpatialElement::BoundedBy() const { return data_->getInverse(IfcRelSpaceBoundary_type, 4)->as<IfcRelSpaceBoundary>(); }

const IfcParse::entity& IfcExternalSpatialElement::declaration() const { return *IfcExternalSpatialElement_type; }
const IfcParse::entity& IfcExternalSpatialElement::Class() { return *IfcExternalSpatialElement_type; }
IfcExternalSpatialElement::IfcExternalSpatialElement(IfcEntityInstanceData* e) : IfcExternalSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcExternalSpatialElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExternalSpatialElement::IfcExternalSpatialElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum > v9_PredefinedType) : IfcExternalSpatialStructureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcExternalSpatialElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcExternalSpatialElementTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcExternalSpatialStructureElement


const IfcParse::entity& IfcExternalSpatialStructureElement::declaration() const { return *IfcExternalSpatialStructureElement_type; }
const IfcParse::entity& IfcExternalSpatialStructureElement::Class() { return *IfcExternalSpatialStructureElement_type; }
IfcExternalSpatialStructureElement::IfcExternalSpatialStructureElement(IfcEntityInstanceData* e) : IfcSpatialElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcExternalSpatialStructureElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExternalSpatialStructureElement::IfcExternalSpatialStructureElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName) : IfcSpatialElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcExternalSpatialStructureElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcExternallyDefinedHatchStyle


const IfcParse::entity& IfcExternallyDefinedHatchStyle::declaration() const { return *IfcExternallyDefinedHatchStyle_type; }
const IfcParse::entity& IfcExternallyDefinedHatchStyle::Class() { return *IfcExternallyDefinedHatchStyle_type; }
IfcExternallyDefinedHatchStyle::IfcExternallyDefinedHatchStyle(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcExternallyDefinedHatchStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExternallyDefinedHatchStyle::IfcExternallyDefinedHatchStyle(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcExternallyDefinedHatchStyle_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Identification));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedSurfaceStyle


const IfcParse::entity& IfcExternallyDefinedSurfaceStyle::declaration() const { return *IfcExternallyDefinedSurfaceStyle_type; }
const IfcParse::entity& IfcExternallyDefinedSurfaceStyle::Class() { return *IfcExternallyDefinedSurfaceStyle_type; }
IfcExternallyDefinedSurfaceStyle::IfcExternallyDefinedSurfaceStyle(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcExternallyDefinedSurfaceStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExternallyDefinedSurfaceStyle::IfcExternallyDefinedSurfaceStyle(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcExternallyDefinedSurfaceStyle_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Identification));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedTextFont


const IfcParse::entity& IfcExternallyDefinedTextFont::declaration() const { return *IfcExternallyDefinedTextFont_type; }
const IfcParse::entity& IfcExternallyDefinedTextFont::Class() { return *IfcExternallyDefinedTextFont_type; }
IfcExternallyDefinedTextFont::IfcExternallyDefinedTextFont(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcExternallyDefinedTextFont_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExternallyDefinedTextFont::IfcExternallyDefinedTextFont(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcExternallyDefinedTextFont_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Identification));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcExtrudedAreaSolid
IfcDirection* IfcExtrudedAreaSolid::ExtrudedDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcExtrudedAreaSolid::setExtrudedDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double IfcExtrudedAreaSolid::Depth() const { return *data_->getArgument(3); }
void IfcExtrudedAreaSolid::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcExtrudedAreaSolid::declaration() const { return *IfcExtrudedAreaSolid_type; }
const IfcParse::entity& IfcExtrudedAreaSolid::Class() { return *IfcExtrudedAreaSolid_type; }
IfcExtrudedAreaSolid::IfcExtrudedAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcExtrudedAreaSolid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExtrudedAreaSolid::IfcExtrudedAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcExtrudedAreaSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ExtrudedDirection));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);} }

// Function implementations for IfcExtrudedAreaSolidTapered
IfcProfileDef* IfcExtrudedAreaSolidTapered::EndSweptArea() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcExtrudedAreaSolidTapered::setEndSweptArea(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcExtrudedAreaSolidTapered::declaration() const { return *IfcExtrudedAreaSolidTapered_type; }
const IfcParse::entity& IfcExtrudedAreaSolidTapered::Class() { return *IfcExtrudedAreaSolidTapered_type; }
IfcExtrudedAreaSolidTapered::IfcExtrudedAreaSolidTapered(IfcEntityInstanceData* e) : IfcExtrudedAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcExtrudedAreaSolidTapered_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcExtrudedAreaSolidTapered::IfcExtrudedAreaSolidTapered(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth, IfcProfileDef* v5_EndSweptArea) : IfcExtrudedAreaSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcExtrudedAreaSolidTapered_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ExtrudedDirection));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_EndSweptArea));data_->setArgument(4,attr);} }

// Function implementations for IfcFace
IfcTemplatedEntityList< IfcFaceBound >::ptr IfcFace::Bounds() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcFaceBound>(); }
void IfcFace::setBounds(IfcTemplatedEntityList< IfcFaceBound >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }

IfcTextureMap::list::ptr IfcFace::HasTextureMaps() const { return data_->getInverse(IfcTextureMap_type, 2)->as<IfcTextureMap>(); }

const IfcParse::entity& IfcFace::declaration() const { return *IfcFace_type; }
const IfcParse::entity& IfcFace::Class() { return *IfcFace_type; }
IfcFace::IfcFace(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFace_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFace::IfcFace(IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFace_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bounds)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcFaceBasedSurfaceModel
IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr IfcFaceBasedSurfaceModel::FbsmFaces() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcConnectedFaceSet>(); }
void IfcFaceBasedSurfaceModel::setFbsmFaces(IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& IfcFaceBasedSurfaceModel::declaration() const { return *IfcFaceBasedSurfaceModel_type; }
const IfcParse::entity& IfcFaceBasedSurfaceModel::Class() { return *IfcFaceBasedSurfaceModel_type; }
IfcFaceBasedSurfaceModel::IfcFaceBasedSurfaceModel(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFaceBasedSurfaceModel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFaceBasedSurfaceModel::IfcFaceBasedSurfaceModel(IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr v1_FbsmFaces) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFaceBasedSurfaceModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_FbsmFaces)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcFaceBound
IfcLoop* IfcFaceBound::Bound() const { return (IfcLoop*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcFaceBound::setBound(IfcLoop* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcFaceBound::Orientation() const { return *data_->getArgument(1); }
void IfcFaceBound::setOrientation(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcFaceBound::declaration() const { return *IfcFaceBound_type; }
const IfcParse::entity& IfcFaceBound::Class() { return *IfcFaceBound_type; }
IfcFaceBound::IfcFaceBound(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFaceBound_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFaceBound::IfcFaceBound(IfcLoop* v1_Bound, bool v2_Orientation) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFaceBound_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bound));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Orientation));data_->setArgument(1,attr);} }

// Function implementations for IfcFaceOuterBound


const IfcParse::entity& IfcFaceOuterBound::declaration() const { return *IfcFaceOuterBound_type; }
const IfcParse::entity& IfcFaceOuterBound::Class() { return *IfcFaceOuterBound_type; }
IfcFaceOuterBound::IfcFaceOuterBound(IfcEntityInstanceData* e) : IfcFaceBound((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFaceOuterBound_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFaceOuterBound::IfcFaceOuterBound(IfcLoop* v1_Bound, bool v2_Orientation) : IfcFaceBound((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFaceOuterBound_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bound));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Orientation));data_->setArgument(1,attr);} }

// Function implementations for IfcFaceSurface
IfcSurface* IfcFaceSurface::FaceSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcFaceSurface::setFaceSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcFaceSurface::SameSense() const { return *data_->getArgument(2); }
void IfcFaceSurface::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcFaceSurface::declaration() const { return *IfcFaceSurface_type; }
const IfcParse::entity& IfcFaceSurface::Class() { return *IfcFaceSurface_type; }
IfcFaceSurface::IfcFaceSurface(IfcEntityInstanceData* e) : IfcFace((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFaceSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFaceSurface::IfcFaceSurface(IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds, IfcSurface* v2_FaceSurface, bool v3_SameSense) : IfcFace((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFaceSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bounds)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FaceSurface));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SameSense));data_->setArgument(2,attr);} }

// Function implementations for IfcFacetedBrep


const IfcParse::entity& IfcFacetedBrep::declaration() const { return *IfcFacetedBrep_type; }
const IfcParse::entity& IfcFacetedBrep::Class() { return *IfcFacetedBrep_type; }
IfcFacetedBrep::IfcFacetedBrep(IfcEntityInstanceData* e) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFacetedBrep_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFacetedBrep::IfcFacetedBrep(IfcClosedShell* v1_Outer) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFacetedBrep_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));data_->setArgument(0,attr);} }

// Function implementations for IfcFacetedBrepWithVoids
IfcTemplatedEntityList< IfcClosedShell >::ptr IfcFacetedBrepWithVoids::Voids() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcClosedShell>(); }
void IfcFacetedBrepWithVoids::setVoids(IfcTemplatedEntityList< IfcClosedShell >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& IfcFacetedBrepWithVoids::declaration() const { return *IfcFacetedBrepWithVoids_type; }
const IfcParse::entity& IfcFacetedBrepWithVoids::Class() { return *IfcFacetedBrepWithVoids_type; }
IfcFacetedBrepWithVoids::IfcFacetedBrepWithVoids(IfcEntityInstanceData* e) : IfcFacetedBrep((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFacetedBrepWithVoids_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFacetedBrepWithVoids::IfcFacetedBrepWithVoids(IfcClosedShell* v1_Outer, IfcTemplatedEntityList< IfcClosedShell >::ptr v2_Voids) : IfcFacetedBrep((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFacetedBrepWithVoids_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Voids)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcFailureConnectionCondition
bool IfcFailureConnectionCondition::hasTensionFailureX() const { return !data_->getArgument(1)->isNull(); }
double IfcFailureConnectionCondition::TensionFailureX() const { return *data_->getArgument(1); }
void IfcFailureConnectionCondition::setTensionFailureX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcFailureConnectionCondition::hasTensionFailureY() const { return !data_->getArgument(2)->isNull(); }
double IfcFailureConnectionCondition::TensionFailureY() const { return *data_->getArgument(2); }
void IfcFailureConnectionCondition::setTensionFailureY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcFailureConnectionCondition::hasTensionFailureZ() const { return !data_->getArgument(3)->isNull(); }
double IfcFailureConnectionCondition::TensionFailureZ() const { return *data_->getArgument(3); }
void IfcFailureConnectionCondition::setTensionFailureZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcFailureConnectionCondition::hasCompressionFailureX() const { return !data_->getArgument(4)->isNull(); }
double IfcFailureConnectionCondition::CompressionFailureX() const { return *data_->getArgument(4); }
void IfcFailureConnectionCondition::setCompressionFailureX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcFailureConnectionCondition::hasCompressionFailureY() const { return !data_->getArgument(5)->isNull(); }
double IfcFailureConnectionCondition::CompressionFailureY() const { return *data_->getArgument(5); }
void IfcFailureConnectionCondition::setCompressionFailureY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcFailureConnectionCondition::hasCompressionFailureZ() const { return !data_->getArgument(6)->isNull(); }
double IfcFailureConnectionCondition::CompressionFailureZ() const { return *data_->getArgument(6); }
void IfcFailureConnectionCondition::setCompressionFailureZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcFailureConnectionCondition::declaration() const { return *IfcFailureConnectionCondition_type; }
const IfcParse::entity& IfcFailureConnectionCondition::Class() { return *IfcFailureConnectionCondition_type; }
IfcFailureConnectionCondition::IfcFailureConnectionCondition(IfcEntityInstanceData* e) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFailureConnectionCondition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFailureConnectionCondition::IfcFailureConnectionCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_TensionFailureX, boost::optional< double > v3_TensionFailureY, boost::optional< double > v4_TensionFailureZ, boost::optional< double > v5_CompressionFailureX, boost::optional< double > v6_CompressionFailureY, boost::optional< double > v7_CompressionFailureZ) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFailureConnectionCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_TensionFailureX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_TensionFailureX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_TensionFailureY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_TensionFailureY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_TensionFailureZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_TensionFailureZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_CompressionFailureX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_CompressionFailureX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_CompressionFailureY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_CompressionFailureY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_CompressionFailureZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CompressionFailureZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcFan
bool IfcFan::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcFanTypeEnum::IfcFanTypeEnum IfcFan::PredefinedType() const { return IfcFanTypeEnum::FromString(*data_->getArgument(8)); }
void IfcFan::setPredefinedType(IfcFanTypeEnum::IfcFanTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFanTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcFan::declaration() const { return *IfcFan_type; }
const IfcParse::entity& IfcFan::Class() { return *IfcFan_type; }
IfcFan::IfcFan(IfcEntityInstanceData* e) : IfcFlowMovingDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFan_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFan::IfcFan(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFanTypeEnum::IfcFanTypeEnum > v9_PredefinedType) : IfcFlowMovingDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFan_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcFanTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFanType
IfcFanTypeEnum::IfcFanTypeEnum IfcFanType::PredefinedType() const { return IfcFanTypeEnum::FromString(*data_->getArgument(9)); }
void IfcFanType::setPredefinedType(IfcFanTypeEnum::IfcFanTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFanTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcFanType::declaration() const { return *IfcFanType_type; }
const IfcParse::entity& IfcFanType::Class() { return *IfcFanType_type; }
IfcFanType::IfcFanType(IfcEntityInstanceData* e) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFanType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFanType::IfcFanType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFanTypeEnum::IfcFanTypeEnum v10_PredefinedType) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFanType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFanTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFastener
bool IfcFastener::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcFastenerTypeEnum::IfcFastenerTypeEnum IfcFastener::PredefinedType() const { return IfcFastenerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcFastener::setPredefinedType(IfcFastenerTypeEnum::IfcFastenerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFastenerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcFastener::declaration() const { return *IfcFastener_type; }
const IfcParse::entity& IfcFastener::Class() { return *IfcFastener_type; }
IfcFastener::IfcFastener(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFastener_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFastener::IfcFastener(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFastenerTypeEnum::IfcFastenerTypeEnum > v9_PredefinedType) : IfcElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFastener_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcFastenerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFastenerType
IfcFastenerTypeEnum::IfcFastenerTypeEnum IfcFastenerType::PredefinedType() const { return IfcFastenerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcFastenerType::setPredefinedType(IfcFastenerTypeEnum::IfcFastenerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFastenerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcFastenerType::declaration() const { return *IfcFastenerType_type; }
const IfcParse::entity& IfcFastenerType::Class() { return *IfcFastenerType_type; }
IfcFastenerType::IfcFastenerType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFastenerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFastenerType::IfcFastenerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFastenerTypeEnum::IfcFastenerTypeEnum v10_PredefinedType) : IfcElementComponentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFastenerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFastenerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFeatureElement


const IfcParse::entity& IfcFeatureElement::declaration() const { return *IfcFeatureElement_type; }
const IfcParse::entity& IfcFeatureElement::Class() { return *IfcFeatureElement_type; }
IfcFeatureElement::IfcFeatureElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFeatureElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFeatureElement::IfcFeatureElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFeatureElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFeatureElementAddition

IfcRelProjectsElement::list::ptr IfcFeatureElementAddition::ProjectsElements() const { return data_->getInverse(IfcRelProjectsElement_type, 5)->as<IfcRelProjectsElement>(); }

const IfcParse::entity& IfcFeatureElementAddition::declaration() const { return *IfcFeatureElementAddition_type; }
const IfcParse::entity& IfcFeatureElementAddition::Class() { return *IfcFeatureElementAddition_type; }
IfcFeatureElementAddition::IfcFeatureElementAddition(IfcEntityInstanceData* e) : IfcFeatureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFeatureElementAddition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFeatureElementAddition::IfcFeatureElementAddition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFeatureElementAddition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFeatureElementSubtraction

IfcRelVoidsElement::list::ptr IfcFeatureElementSubtraction::VoidsElements() const { return data_->getInverse(IfcRelVoidsElement_type, 5)->as<IfcRelVoidsElement>(); }

const IfcParse::entity& IfcFeatureElementSubtraction::declaration() const { return *IfcFeatureElementSubtraction_type; }
const IfcParse::entity& IfcFeatureElementSubtraction::Class() { return *IfcFeatureElementSubtraction_type; }
IfcFeatureElementSubtraction::IfcFeatureElementSubtraction(IfcEntityInstanceData* e) : IfcFeatureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFeatureElementSubtraction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFeatureElementSubtraction::IfcFeatureElementSubtraction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFeatureElementSubtraction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFillAreaStyle
IfcEntityList::ptr IfcFillAreaStyle::FillStyles() const { return *data_->getArgument(1); }
void IfcFillAreaStyle::setFillStyles(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcFillAreaStyle::hasModelorDraughting() const { return !data_->getArgument(2)->isNull(); }
bool IfcFillAreaStyle::ModelorDraughting() const { return *data_->getArgument(2); }
void IfcFillAreaStyle::setModelorDraughting(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcFillAreaStyle::declaration() const { return *IfcFillAreaStyle_type; }
const IfcParse::entity& IfcFillAreaStyle::Class() { return *IfcFillAreaStyle_type; }
IfcFillAreaStyle::IfcFillAreaStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFillAreaStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFillAreaStyle::IfcFillAreaStyle(boost::optional< std::string > v1_Name, IfcEntityList::ptr v2_FillStyles, boost::optional< bool > v3_ModelorDraughting) : IfcPresentationStyle((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFillAreaStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FillStyles));data_->setArgument(1,attr);} if (v3_ModelorDraughting) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ModelorDraughting));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcFillAreaStyleHatching
IfcCurveStyle* IfcFillAreaStyleHatching::HatchLineAppearance() const { return (IfcCurveStyle*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcFillAreaStyleHatching::setHatchLineAppearance(IfcCurveStyle* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcHatchLineDistanceSelect* IfcFillAreaStyleHatching::StartOfNextHatchLine() const { return (IfcHatchLineDistanceSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcFillAreaStyleHatching::setStartOfNextHatchLine(IfcHatchLineDistanceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcFillAreaStyleHatching::hasPointOfReferenceHatchLine() const { return !data_->getArgument(2)->isNull(); }
IfcCartesianPoint* IfcFillAreaStyleHatching::PointOfReferenceHatchLine() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcFillAreaStyleHatching::setPointOfReferenceHatchLine(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcFillAreaStyleHatching::hasPatternStart() const { return !data_->getArgument(3)->isNull(); }
IfcCartesianPoint* IfcFillAreaStyleHatching::PatternStart() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcFillAreaStyleHatching::setPatternStart(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcFillAreaStyleHatching::HatchLineAngle() const { return *data_->getArgument(4); }
void IfcFillAreaStyleHatching::setHatchLineAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcFillAreaStyleHatching::declaration() const { return *IfcFillAreaStyleHatching_type; }
const IfcParse::entity& IfcFillAreaStyleHatching::Class() { return *IfcFillAreaStyleHatching_type; }
IfcFillAreaStyleHatching::IfcFillAreaStyleHatching(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFillAreaStyleHatching_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFillAreaStyleHatching::IfcFillAreaStyleHatching(IfcCurveStyle* v1_HatchLineAppearance, IfcHatchLineDistanceSelect* v2_StartOfNextHatchLine, IfcCartesianPoint* v3_PointOfReferenceHatchLine, IfcCartesianPoint* v4_PatternStart, double v5_HatchLineAngle) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFillAreaStyleHatching_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_HatchLineAppearance));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_StartOfNextHatchLine));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_PointOfReferenceHatchLine));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_PatternStart));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_HatchLineAngle));data_->setArgument(4,attr);} }

// Function implementations for IfcFillAreaStyleTiles
IfcTemplatedEntityList< IfcVector >::ptr IfcFillAreaStyleTiles::TilingPattern() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcVector>(); }
void IfcFillAreaStyleTiles::setTilingPattern(IfcTemplatedEntityList< IfcVector >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcStyledItem >::ptr IfcFillAreaStyleTiles::Tiles() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcStyledItem>(); }
void IfcFillAreaStyleTiles::setTiles(IfcTemplatedEntityList< IfcStyledItem >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }
double IfcFillAreaStyleTiles::TilingScale() const { return *data_->getArgument(2); }
void IfcFillAreaStyleTiles::setTilingScale(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcFillAreaStyleTiles::declaration() const { return *IfcFillAreaStyleTiles_type; }
const IfcParse::entity& IfcFillAreaStyleTiles::Class() { return *IfcFillAreaStyleTiles_type; }
IfcFillAreaStyleTiles::IfcFillAreaStyleTiles(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFillAreaStyleTiles_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFillAreaStyleTiles::IfcFillAreaStyleTiles(IfcTemplatedEntityList< IfcVector >::ptr v1_TilingPattern, IfcTemplatedEntityList< IfcStyledItem >::ptr v2_Tiles, double v3_TilingScale) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFillAreaStyleTiles_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TilingPattern)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Tiles)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TilingScale));data_->setArgument(2,attr);} }

// Function implementations for IfcFilter
bool IfcFilter::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcFilterTypeEnum::IfcFilterTypeEnum IfcFilter::PredefinedType() const { return IfcFilterTypeEnum::FromString(*data_->getArgument(8)); }
void IfcFilter::setPredefinedType(IfcFilterTypeEnum::IfcFilterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFilterTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcFilter::declaration() const { return *IfcFilter_type; }
const IfcParse::entity& IfcFilter::Class() { return *IfcFilter_type; }
IfcFilter::IfcFilter(IfcEntityInstanceData* e) : IfcFlowTreatmentDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFilter_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFilter::IfcFilter(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFilterTypeEnum::IfcFilterTypeEnum > v9_PredefinedType) : IfcFlowTreatmentDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFilter_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcFilterTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFilterType
IfcFilterTypeEnum::IfcFilterTypeEnum IfcFilterType::PredefinedType() const { return IfcFilterTypeEnum::FromString(*data_->getArgument(9)); }
void IfcFilterType::setPredefinedType(IfcFilterTypeEnum::IfcFilterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFilterTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcFilterType::declaration() const { return *IfcFilterType_type; }
const IfcParse::entity& IfcFilterType::Class() { return *IfcFilterType_type; }
IfcFilterType::IfcFilterType(IfcEntityInstanceData* e) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFilterType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFilterType::IfcFilterType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFilterTypeEnum::IfcFilterTypeEnum v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFilterType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFilterTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFireSuppressionTerminal
bool IfcFireSuppressionTerminal::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum IfcFireSuppressionTerminal::PredefinedType() const { return IfcFireSuppressionTerminalTypeEnum::FromString(*data_->getArgument(8)); }
void IfcFireSuppressionTerminal::setPredefinedType(IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFireSuppressionTerminalTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcFireSuppressionTerminal::declaration() const { return *IfcFireSuppressionTerminal_type; }
const IfcParse::entity& IfcFireSuppressionTerminal::Class() { return *IfcFireSuppressionTerminal_type; }
IfcFireSuppressionTerminal::IfcFireSuppressionTerminal(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFireSuppressionTerminal_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFireSuppressionTerminal::IfcFireSuppressionTerminal(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFireSuppressionTerminal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcFireSuppressionTerminalTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFireSuppressionTerminalType
IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum IfcFireSuppressionTerminalType::PredefinedType() const { return IfcFireSuppressionTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void IfcFireSuppressionTerminalType::setPredefinedType(IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFireSuppressionTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcFireSuppressionTerminalType::declaration() const { return *IfcFireSuppressionTerminalType_type; }
const IfcParse::entity& IfcFireSuppressionTerminalType::Class() { return *IfcFireSuppressionTerminalType_type; }
IfcFireSuppressionTerminalType::IfcFireSuppressionTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFireSuppressionTerminalType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFireSuppressionTerminalType::IfcFireSuppressionTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFireSuppressionTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFireSuppressionTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFixedReferenceSweptAreaSolid
IfcCurve* IfcFixedReferenceSweptAreaSolid::Directrix() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcFixedReferenceSweptAreaSolid::setDirectrix(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcFixedReferenceSweptAreaSolid::hasStartParam() const { return !data_->getArgument(3)->isNull(); }
double IfcFixedReferenceSweptAreaSolid::StartParam() const { return *data_->getArgument(3); }
void IfcFixedReferenceSweptAreaSolid::setStartParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcFixedReferenceSweptAreaSolid::hasEndParam() const { return !data_->getArgument(4)->isNull(); }
double IfcFixedReferenceSweptAreaSolid::EndParam() const { return *data_->getArgument(4); }
void IfcFixedReferenceSweptAreaSolid::setEndParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcDirection* IfcFixedReferenceSweptAreaSolid::FixedReference() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcFixedReferenceSweptAreaSolid::setFixedReference(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcFixedReferenceSweptAreaSolid::declaration() const { return *IfcFixedReferenceSweptAreaSolid_type; }
const IfcParse::entity& IfcFixedReferenceSweptAreaSolid::Class() { return *IfcFixedReferenceSweptAreaSolid_type; }
IfcFixedReferenceSweptAreaSolid::IfcFixedReferenceSweptAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFixedReferenceSweptAreaSolid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFixedReferenceSweptAreaSolid::IfcFixedReferenceSweptAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcCurve* v3_Directrix, boost::optional< double > v4_StartParam, boost::optional< double > v5_EndParam, IfcDirection* v6_FixedReference) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFixedReferenceSweptAreaSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Directrix));data_->setArgument(2,attr);} if (v4_StartParam) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_StartParam));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_EndParam) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_EndParam));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FixedReference));data_->setArgument(5,attr);} }

// Function implementations for IfcFlowController


const IfcParse::entity& IfcFlowController::declaration() const { return *IfcFlowController_type; }
const IfcParse::entity& IfcFlowController::Class() { return *IfcFlowController_type; }
IfcFlowController::IfcFlowController(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowController_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowController::IfcFlowController(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowController_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowControllerType


const IfcParse::entity& IfcFlowControllerType::declaration() const { return *IfcFlowControllerType_type; }
const IfcParse::entity& IfcFlowControllerType::Class() { return *IfcFlowControllerType_type; }
IfcFlowControllerType::IfcFlowControllerType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowControllerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowControllerType::IfcFlowControllerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowControllerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowFitting


const IfcParse::entity& IfcFlowFitting::declaration() const { return *IfcFlowFitting_type; }
const IfcParse::entity& IfcFlowFitting::Class() { return *IfcFlowFitting_type; }
IfcFlowFitting::IfcFlowFitting(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowFitting_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowFitting::IfcFlowFitting(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowFitting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowFittingType


const IfcParse::entity& IfcFlowFittingType::declaration() const { return *IfcFlowFittingType_type; }
const IfcParse::entity& IfcFlowFittingType::Class() { return *IfcFlowFittingType_type; }
IfcFlowFittingType::IfcFlowFittingType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowFittingType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowFittingType::IfcFlowFittingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowFittingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowInstrument
bool IfcFlowInstrument::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum IfcFlowInstrument::PredefinedType() const { return IfcFlowInstrumentTypeEnum::FromString(*data_->getArgument(8)); }
void IfcFlowInstrument::setPredefinedType(IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFlowInstrumentTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcFlowInstrument::declaration() const { return *IfcFlowInstrument_type; }
const IfcParse::entity& IfcFlowInstrument::Class() { return *IfcFlowInstrument_type; }
IfcFlowInstrument::IfcFlowInstrument(IfcEntityInstanceData* e) : IfcDistributionControlElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowInstrument_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowInstrument::IfcFlowInstrument(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowInstrument_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcFlowInstrumentTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowInstrumentType
IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum IfcFlowInstrumentType::PredefinedType() const { return IfcFlowInstrumentTypeEnum::FromString(*data_->getArgument(9)); }
void IfcFlowInstrumentType::setPredefinedType(IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFlowInstrumentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcFlowInstrumentType::declaration() const { return *IfcFlowInstrumentType_type; }
const IfcParse::entity& IfcFlowInstrumentType::Class() { return *IfcFlowInstrumentType_type; }
IfcFlowInstrumentType::IfcFlowInstrumentType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowInstrumentType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowInstrumentType::IfcFlowInstrumentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowInstrumentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFlowInstrumentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFlowMeter
bool IfcFlowMeter::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum IfcFlowMeter::PredefinedType() const { return IfcFlowMeterTypeEnum::FromString(*data_->getArgument(8)); }
void IfcFlowMeter::setPredefinedType(IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFlowMeterTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcFlowMeter::declaration() const { return *IfcFlowMeter_type; }
const IfcParse::entity& IfcFlowMeter::Class() { return *IfcFlowMeter_type; }
IfcFlowMeter::IfcFlowMeter(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowMeter_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowMeter::IfcFlowMeter(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum > v9_PredefinedType) : IfcFlowController((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowMeter_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcFlowMeterTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowMeterType
IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum IfcFlowMeterType::PredefinedType() const { return IfcFlowMeterTypeEnum::FromString(*data_->getArgument(9)); }
void IfcFlowMeterType::setPredefinedType(IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFlowMeterTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcFlowMeterType::declaration() const { return *IfcFlowMeterType_type; }
const IfcParse::entity& IfcFlowMeterType::Class() { return *IfcFlowMeterType_type; }
IfcFlowMeterType::IfcFlowMeterType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowMeterType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowMeterType::IfcFlowMeterType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowMeterType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFlowMeterTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFlowMovingDevice


const IfcParse::entity& IfcFlowMovingDevice::declaration() const { return *IfcFlowMovingDevice_type; }
const IfcParse::entity& IfcFlowMovingDevice::Class() { return *IfcFlowMovingDevice_type; }
IfcFlowMovingDevice::IfcFlowMovingDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowMovingDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowMovingDevice::IfcFlowMovingDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowMovingDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowMovingDeviceType


const IfcParse::entity& IfcFlowMovingDeviceType::declaration() const { return *IfcFlowMovingDeviceType_type; }
const IfcParse::entity& IfcFlowMovingDeviceType::Class() { return *IfcFlowMovingDeviceType_type; }
IfcFlowMovingDeviceType::IfcFlowMovingDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowMovingDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowMovingDeviceType::IfcFlowMovingDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowMovingDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowSegment


const IfcParse::entity& IfcFlowSegment::declaration() const { return *IfcFlowSegment_type; }
const IfcParse::entity& IfcFlowSegment::Class() { return *IfcFlowSegment_type; }
IfcFlowSegment::IfcFlowSegment(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowSegment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowSegment::IfcFlowSegment(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowSegment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowSegmentType


const IfcParse::entity& IfcFlowSegmentType::declaration() const { return *IfcFlowSegmentType_type; }
const IfcParse::entity& IfcFlowSegmentType::Class() { return *IfcFlowSegmentType_type; }
IfcFlowSegmentType::IfcFlowSegmentType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowSegmentType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowSegmentType::IfcFlowSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowStorageDevice


const IfcParse::entity& IfcFlowStorageDevice::declaration() const { return *IfcFlowStorageDevice_type; }
const IfcParse::entity& IfcFlowStorageDevice::Class() { return *IfcFlowStorageDevice_type; }
IfcFlowStorageDevice::IfcFlowStorageDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowStorageDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowStorageDevice::IfcFlowStorageDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowStorageDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowStorageDeviceType


const IfcParse::entity& IfcFlowStorageDeviceType::declaration() const { return *IfcFlowStorageDeviceType_type; }
const IfcParse::entity& IfcFlowStorageDeviceType::Class() { return *IfcFlowStorageDeviceType_type; }
IfcFlowStorageDeviceType::IfcFlowStorageDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowStorageDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowStorageDeviceType::IfcFlowStorageDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowStorageDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowTerminal


const IfcParse::entity& IfcFlowTerminal::declaration() const { return *IfcFlowTerminal_type; }
const IfcParse::entity& IfcFlowTerminal::Class() { return *IfcFlowTerminal_type; }
IfcFlowTerminal::IfcFlowTerminal(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowTerminal_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowTerminal::IfcFlowTerminal(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowTerminal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowTerminalType


const IfcParse::entity& IfcFlowTerminalType::declaration() const { return *IfcFlowTerminalType_type; }
const IfcParse::entity& IfcFlowTerminalType::Class() { return *IfcFlowTerminalType_type; }
IfcFlowTerminalType::IfcFlowTerminalType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowTerminalType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowTerminalType::IfcFlowTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowTreatmentDevice


const IfcParse::entity& IfcFlowTreatmentDevice::declaration() const { return *IfcFlowTreatmentDevice_type; }
const IfcParse::entity& IfcFlowTreatmentDevice::Class() { return *IfcFlowTreatmentDevice_type; }
IfcFlowTreatmentDevice::IfcFlowTreatmentDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowTreatmentDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowTreatmentDevice::IfcFlowTreatmentDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowTreatmentDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowTreatmentDeviceType


const IfcParse::entity& IfcFlowTreatmentDeviceType::declaration() const { return *IfcFlowTreatmentDeviceType_type; }
const IfcParse::entity& IfcFlowTreatmentDeviceType::Class() { return *IfcFlowTreatmentDeviceType_type; }
IfcFlowTreatmentDeviceType::IfcFlowTreatmentDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFlowTreatmentDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFlowTreatmentDeviceType::IfcFlowTreatmentDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFlowTreatmentDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFooting
bool IfcFooting::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcFootingTypeEnum::IfcFootingTypeEnum IfcFooting::PredefinedType() const { return IfcFootingTypeEnum::FromString(*data_->getArgument(8)); }
void IfcFooting::setPredefinedType(IfcFootingTypeEnum::IfcFootingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFootingTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcFooting::declaration() const { return *IfcFooting_type; }
const IfcParse::entity& IfcFooting::Class() { return *IfcFooting_type; }
IfcFooting::IfcFooting(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFooting_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFooting::IfcFooting(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFootingTypeEnum::IfcFootingTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFooting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcFootingTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFootingType
IfcFootingTypeEnum::IfcFootingTypeEnum IfcFootingType::PredefinedType() const { return IfcFootingTypeEnum::FromString(*data_->getArgument(9)); }
void IfcFootingType::setPredefinedType(IfcFootingTypeEnum::IfcFootingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFootingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcFootingType::declaration() const { return *IfcFootingType_type; }
const IfcParse::entity& IfcFootingType::Class() { return *IfcFootingType_type; }
IfcFootingType::IfcFootingType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFootingType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFootingType::IfcFootingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFootingTypeEnum::IfcFootingTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFootingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFootingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFurnishingElement


const IfcParse::entity& IfcFurnishingElement::declaration() const { return *IfcFurnishingElement_type; }
const IfcParse::entity& IfcFurnishingElement::Class() { return *IfcFurnishingElement_type; }
IfcFurnishingElement::IfcFurnishingElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFurnishingElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFurnishingElement::IfcFurnishingElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFurnishingElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFurnishingElementType


const IfcParse::entity& IfcFurnishingElementType::declaration() const { return *IfcFurnishingElementType_type; }
const IfcParse::entity& IfcFurnishingElementType::Class() { return *IfcFurnishingElementType_type; }
IfcFurnishingElementType::IfcFurnishingElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFurnishingElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFurnishingElementType::IfcFurnishingElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFurnishingElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFurniture
bool IfcFurniture::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcFurnitureTypeEnum::IfcFurnitureTypeEnum IfcFurniture::PredefinedType() const { return IfcFurnitureTypeEnum::FromString(*data_->getArgument(8)); }
void IfcFurniture::setPredefinedType(IfcFurnitureTypeEnum::IfcFurnitureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFurnitureTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcFurniture::declaration() const { return *IfcFurniture_type; }
const IfcParse::entity& IfcFurniture::Class() { return *IfcFurniture_type; }
IfcFurniture::IfcFurniture(IfcEntityInstanceData* e) : IfcFurnishingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFurniture_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFurniture::IfcFurniture(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFurnitureTypeEnum::IfcFurnitureTypeEnum > v9_PredefinedType) : IfcFurnishingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFurniture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcFurnitureTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFurnitureType
IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum IfcFurnitureType::AssemblyPlace() const { return IfcAssemblyPlaceEnum::FromString(*data_->getArgument(9)); }
void IfcFurnitureType::setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAssemblyPlaceEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcFurnitureType::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcFurnitureTypeEnum::IfcFurnitureTypeEnum IfcFurnitureType::PredefinedType() const { return IfcFurnitureTypeEnum::FromString(*data_->getArgument(10)); }
void IfcFurnitureType::setPredefinedType(IfcFurnitureTypeEnum::IfcFurnitureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFurnitureTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& IfcFurnitureType::declaration() const { return *IfcFurnitureType_type; }
const IfcParse::entity& IfcFurnitureType::Class() { return *IfcFurnitureType_type; }
IfcFurnitureType::IfcFurnitureType(IfcEntityInstanceData* e) : IfcFurnishingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcFurnitureType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcFurnitureType::IfcFurnitureType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v10_AssemblyPlace, boost::optional< IfcFurnitureTypeEnum::IfcFurnitureTypeEnum > v11_PredefinedType) : IfcFurnishingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcFurnitureType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_AssemblyPlace,IfcAssemblyPlaceEnum::ToString(v10_AssemblyPlace))));data_->setArgument(9,attr);} if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcFurnitureTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcGeographicElement
bool IfcGeographicElement::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum IfcGeographicElement::PredefinedType() const { return IfcGeographicElementTypeEnum::FromString(*data_->getArgument(8)); }
void IfcGeographicElement::setPredefinedType(IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcGeographicElementTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcGeographicElement::declaration() const { return *IfcGeographicElement_type; }
const IfcParse::entity& IfcGeographicElement::Class() { return *IfcGeographicElement_type; }
IfcGeographicElement::IfcGeographicElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGeographicElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGeographicElement::IfcGeographicElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum > v9_PredefinedType) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGeographicElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcGeographicElementTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcGeographicElementType
IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum IfcGeographicElementType::PredefinedType() const { return IfcGeographicElementTypeEnum::FromString(*data_->getArgument(9)); }
void IfcGeographicElementType::setPredefinedType(IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcGeographicElementTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcGeographicElementType::declaration() const { return *IfcGeographicElementType_type; }
const IfcParse::entity& IfcGeographicElementType::Class() { return *IfcGeographicElementType_type; }
IfcGeographicElementType::IfcGeographicElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGeographicElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGeographicElementType::IfcGeographicElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum v10_PredefinedType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGeographicElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcGeographicElementTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcGeometricCurveSet


const IfcParse::entity& IfcGeometricCurveSet::declaration() const { return *IfcGeometricCurveSet_type; }
const IfcParse::entity& IfcGeometricCurveSet::Class() { return *IfcGeometricCurveSet_type; }
IfcGeometricCurveSet::IfcGeometricCurveSet(IfcEntityInstanceData* e) : IfcGeometricSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGeometricCurveSet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGeometricCurveSet::IfcGeometricCurveSet(IfcEntityList::ptr v1_Elements) : IfcGeometricSet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGeometricCurveSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Elements));data_->setArgument(0,attr);} }

// Function implementations for IfcGeometricRepresentationContext
int IfcGeometricRepresentationContext::CoordinateSpaceDimension() const { return *data_->getArgument(2); }
void IfcGeometricRepresentationContext::setCoordinateSpaceDimension(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcGeometricRepresentationContext::hasPrecision() const { return !data_->getArgument(3)->isNull(); }
double IfcGeometricRepresentationContext::Precision() const { return *data_->getArgument(3); }
void IfcGeometricRepresentationContext::setPrecision(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
IfcAxis2Placement* IfcGeometricRepresentationContext::WorldCoordinateSystem() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcGeometricRepresentationContext::setWorldCoordinateSystem(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcGeometricRepresentationContext::hasTrueNorth() const { return !data_->getArgument(5)->isNull(); }
IfcDirection* IfcGeometricRepresentationContext::TrueNorth() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcGeometricRepresentationContext::setTrueNorth(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

IfcGeometricRepresentationSubContext::list::ptr IfcGeometricRepresentationContext::HasSubContexts() const { return data_->getInverse(IfcGeometricRepresentationSubContext_type, 6)->as<IfcGeometricRepresentationSubContext>(); }
IfcCoordinateOperation::list::ptr IfcGeometricRepresentationContext::HasCoordinateOperation() const { return data_->getInverse(IfcCoordinateOperation_type, 0)->as<IfcCoordinateOperation>(); }

const IfcParse::entity& IfcGeometricRepresentationContext::declaration() const { return *IfcGeometricRepresentationContext_type; }
const IfcParse::entity& IfcGeometricRepresentationContext::Class() { return *IfcGeometricRepresentationContext_type; }
IfcGeometricRepresentationContext::IfcGeometricRepresentationContext(IfcEntityInstanceData* e) : IfcRepresentationContext((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGeometricRepresentationContext_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGeometricRepresentationContext::IfcGeometricRepresentationContext(boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, int v3_CoordinateSpaceDimension, boost::optional< double > v4_Precision, IfcAxis2Placement* v5_WorldCoordinateSystem, IfcDirection* v6_TrueNorth) : IfcRepresentationContext((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGeometricRepresentationContext_type);  if (v1_ContextIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ContextIdentifier));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ContextType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ContextType));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CoordinateSpaceDimension));data_->setArgument(2,attr);} if (v4_Precision) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Precision));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_WorldCoordinateSystem));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TrueNorth));data_->setArgument(5,attr);} }

// Function implementations for IfcGeometricRepresentationItem


const IfcParse::entity& IfcGeometricRepresentationItem::declaration() const { return *IfcGeometricRepresentationItem_type; }
const IfcParse::entity& IfcGeometricRepresentationItem::Class() { return *IfcGeometricRepresentationItem_type; }
IfcGeometricRepresentationItem::IfcGeometricRepresentationItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGeometricRepresentationItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGeometricRepresentationItem::IfcGeometricRepresentationItem() : IfcRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGeometricRepresentationItem_type);  }

// Function implementations for IfcGeometricRepresentationSubContext
IfcGeometricRepresentationContext* IfcGeometricRepresentationSubContext::ParentContext() const { return (IfcGeometricRepresentationContext*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcGeometricRepresentationSubContext::setParentContext(IfcGeometricRepresentationContext* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcGeometricRepresentationSubContext::hasTargetScale() const { return !data_->getArgument(7)->isNull(); }
double IfcGeometricRepresentationSubContext::TargetScale() const { return *data_->getArgument(7); }
void IfcGeometricRepresentationSubContext::setTargetScale(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
IfcGeometricProjectionEnum::IfcGeometricProjectionEnum IfcGeometricRepresentationSubContext::TargetView() const { return IfcGeometricProjectionEnum::FromString(*data_->getArgument(8)); }
void IfcGeometricRepresentationSubContext::setTargetView(IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcGeometricProjectionEnum::ToString(v)));data_->setArgument(8,attr);} }
bool IfcGeometricRepresentationSubContext::hasUserDefinedTargetView() const { return !data_->getArgument(9)->isNull(); }
std::string IfcGeometricRepresentationSubContext::UserDefinedTargetView() const { return *data_->getArgument(9); }
void IfcGeometricRepresentationSubContext::setUserDefinedTargetView(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcGeometricRepresentationSubContext::declaration() const { return *IfcGeometricRepresentationSubContext_type; }
const IfcParse::entity& IfcGeometricRepresentationSubContext::Class() { return *IfcGeometricRepresentationSubContext_type; }
IfcGeometricRepresentationSubContext::IfcGeometricRepresentationSubContext(IfcEntityInstanceData* e) : IfcGeometricRepresentationContext((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGeometricRepresentationSubContext_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGeometricRepresentationSubContext::IfcGeometricRepresentationSubContext(boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, IfcGeometricRepresentationContext* v7_ParentContext, boost::optional< double > v8_TargetScale, IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v9_TargetView, boost::optional< std::string > v10_UserDefinedTargetView) : IfcGeometricRepresentationContext((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGeometricRepresentationSubContext_type);  if (v1_ContextIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ContextIdentifier));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ContextType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ContextType));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ParentContext));data_->setArgument(6,attr);} if (v8_TargetScale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_TargetScale));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_TargetView,IfcGeometricProjectionEnum::ToString(v9_TargetView))));data_->setArgument(8,attr);} if (v10_UserDefinedTargetView) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_UserDefinedTargetView));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcGeometricSet
IfcEntityList::ptr IfcGeometricSet::Elements() const { return *data_->getArgument(0); }
void IfcGeometricSet::setElements(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcGeometricSet::declaration() const { return *IfcGeometricSet_type; }
const IfcParse::entity& IfcGeometricSet::Class() { return *IfcGeometricSet_type; }
IfcGeometricSet::IfcGeometricSet(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGeometricSet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGeometricSet::IfcGeometricSet(IfcEntityList::ptr v1_Elements) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGeometricSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Elements));data_->setArgument(0,attr);} }

// Function implementations for IfcGrid
IfcTemplatedEntityList< IfcGridAxis >::ptr IfcGrid::UAxes() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcGridAxis>(); }
void IfcGrid::setUAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }
IfcTemplatedEntityList< IfcGridAxis >::ptr IfcGrid::VAxes() const { IfcEntityList::ptr es = *data_->getArgument(8); return es->as<IfcGridAxis>(); }
void IfcGrid::setVAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(8,attr);} }
bool IfcGrid::hasWAxes() const { return !data_->getArgument(9)->isNull(); }
IfcTemplatedEntityList< IfcGridAxis >::ptr IfcGrid::WAxes() const { IfcEntityList::ptr es = *data_->getArgument(9); return es->as<IfcGridAxis>(); }
void IfcGrid::setWAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(9,attr);} }
bool IfcGrid::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcGridTypeEnum::IfcGridTypeEnum IfcGrid::PredefinedType() const { return IfcGridTypeEnum::FromString(*data_->getArgument(10)); }
void IfcGrid::setPredefinedType(IfcGridTypeEnum::IfcGridTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcGridTypeEnum::ToString(v)));data_->setArgument(10,attr);} }

IfcRelContainedInSpatialStructure::list::ptr IfcGrid::ContainedInStructure() const { return data_->getInverse(IfcRelContainedInSpatialStructure_type, 4)->as<IfcRelContainedInSpatialStructure>(); }

const IfcParse::entity& IfcGrid::declaration() const { return *IfcGrid_type; }
const IfcParse::entity& IfcGrid::Class() { return *IfcGrid_type; }
IfcGrid::IfcGrid(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGrid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGrid::IfcGrid(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcTemplatedEntityList< IfcGridAxis >::ptr v8_UAxes, IfcTemplatedEntityList< IfcGridAxis >::ptr v9_VAxes, boost::optional< IfcTemplatedEntityList< IfcGridAxis >::ptr > v10_WAxes, boost::optional< IfcGridTypeEnum::IfcGridTypeEnum > v11_PredefinedType) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGrid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_UAxes)->generalize());data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_VAxes)->generalize());data_->setArgument(8,attr);} if (v10_WAxes) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_WAxes)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcGridTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcGridAxis
bool IfcGridAxis::hasAxisTag() const { return !data_->getArgument(0)->isNull(); }
std::string IfcGridAxis::AxisTag() const { return *data_->getArgument(0); }
void IfcGridAxis::setAxisTag(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcCurve* IfcGridAxis::AxisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcGridAxis::setAxisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcGridAxis::SameSense() const { return *data_->getArgument(2); }
void IfcGridAxis::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

IfcGrid::list::ptr IfcGridAxis::PartOfW() const { return data_->getInverse(IfcGrid_type, 9)->as<IfcGrid>(); }
IfcGrid::list::ptr IfcGridAxis::PartOfV() const { return data_->getInverse(IfcGrid_type, 8)->as<IfcGrid>(); }
IfcGrid::list::ptr IfcGridAxis::PartOfU() const { return data_->getInverse(IfcGrid_type, 7)->as<IfcGrid>(); }
IfcVirtualGridIntersection::list::ptr IfcGridAxis::HasIntersections() const { return data_->getInverse(IfcVirtualGridIntersection_type, 0)->as<IfcVirtualGridIntersection>(); }

const IfcParse::entity& IfcGridAxis::declaration() const { return *IfcGridAxis_type; }
const IfcParse::entity& IfcGridAxis::Class() { return *IfcGridAxis_type; }
IfcGridAxis::IfcGridAxis(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcGridAxis_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGridAxis::IfcGridAxis(boost::optional< std::string > v1_AxisTag, IfcCurve* v2_AxisCurve, bool v3_SameSense) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcGridAxis_type);  if (v1_AxisTag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_AxisTag));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AxisCurve));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SameSense));data_->setArgument(2,attr);} }

// Function implementations for IfcGridPlacement
IfcVirtualGridIntersection* IfcGridPlacement::PlacementLocation() const { return (IfcVirtualGridIntersection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcGridPlacement::setPlacementLocation(IfcVirtualGridIntersection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcGridPlacement::hasPlacementRefDirection() const { return !data_->getArgument(1)->isNull(); }
IfcGridPlacementDirectionSelect* IfcGridPlacement::PlacementRefDirection() const { return (IfcGridPlacementDirectionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcGridPlacement::setPlacementRefDirection(IfcGridPlacementDirectionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcGridPlacement::declaration() const { return *IfcGridPlacement_type; }
const IfcParse::entity& IfcGridPlacement::Class() { return *IfcGridPlacement_type; }
IfcGridPlacement::IfcGridPlacement(IfcEntityInstanceData* e) : IfcObjectPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGridPlacement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGridPlacement::IfcGridPlacement(IfcVirtualGridIntersection* v1_PlacementLocation, IfcGridPlacementDirectionSelect* v2_PlacementRefDirection) : IfcObjectPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGridPlacement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PlacementLocation));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PlacementRefDirection));data_->setArgument(1,attr);} }

// Function implementations for IfcGroup

IfcRelAssignsToGroup::list::ptr IfcGroup::IsGroupedBy() const { return data_->getInverse(IfcRelAssignsToGroup_type, 6)->as<IfcRelAssignsToGroup>(); }

const IfcParse::entity& IfcGroup::declaration() const { return *IfcGroup_type; }
const IfcParse::entity& IfcGroup::Class() { return *IfcGroup_type; }
IfcGroup::IfcGroup(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcGroup_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcGroup::IfcGroup(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcGroup_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcHalfSpaceSolid
IfcSurface* IfcHalfSpaceSolid::BaseSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcHalfSpaceSolid::setBaseSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcHalfSpaceSolid::AgreementFlag() const { return *data_->getArgument(1); }
void IfcHalfSpaceSolid::setAgreementFlag(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcHalfSpaceSolid::declaration() const { return *IfcHalfSpaceSolid_type; }
const IfcParse::entity& IfcHalfSpaceSolid::Class() { return *IfcHalfSpaceSolid_type; }
IfcHalfSpaceSolid::IfcHalfSpaceSolid(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcHalfSpaceSolid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcHalfSpaceSolid::IfcHalfSpaceSolid(IfcSurface* v1_BaseSurface, bool v2_AgreementFlag) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcHalfSpaceSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BaseSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AgreementFlag));data_->setArgument(1,attr);} }

// Function implementations for IfcHeatExchanger
bool IfcHeatExchanger::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum IfcHeatExchanger::PredefinedType() const { return IfcHeatExchangerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcHeatExchanger::setPredefinedType(IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcHeatExchangerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcHeatExchanger::declaration() const { return *IfcHeatExchanger_type; }
const IfcParse::entity& IfcHeatExchanger::Class() { return *IfcHeatExchanger_type; }
IfcHeatExchanger::IfcHeatExchanger(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcHeatExchanger_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcHeatExchanger::IfcHeatExchanger(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcHeatExchanger_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcHeatExchangerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcHeatExchangerType
IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum IfcHeatExchangerType::PredefinedType() const { return IfcHeatExchangerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcHeatExchangerType::setPredefinedType(IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcHeatExchangerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcHeatExchangerType::declaration() const { return *IfcHeatExchangerType_type; }
const IfcParse::entity& IfcHeatExchangerType::Class() { return *IfcHeatExchangerType_type; }
IfcHeatExchangerType::IfcHeatExchangerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcHeatExchangerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcHeatExchangerType::IfcHeatExchangerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcHeatExchangerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcHeatExchangerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcHumidifier
bool IfcHumidifier::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcHumidifierTypeEnum::IfcHumidifierTypeEnum IfcHumidifier::PredefinedType() const { return IfcHumidifierTypeEnum::FromString(*data_->getArgument(8)); }
void IfcHumidifier::setPredefinedType(IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcHumidifierTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcHumidifier::declaration() const { return *IfcHumidifier_type; }
const IfcParse::entity& IfcHumidifier::Class() { return *IfcHumidifier_type; }
IfcHumidifier::IfcHumidifier(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcHumidifier_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcHumidifier::IfcHumidifier(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcHumidifierTypeEnum::IfcHumidifierTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcHumidifier_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcHumidifierTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcHumidifierType
IfcHumidifierTypeEnum::IfcHumidifierTypeEnum IfcHumidifierType::PredefinedType() const { return IfcHumidifierTypeEnum::FromString(*data_->getArgument(9)); }
void IfcHumidifierType::setPredefinedType(IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcHumidifierTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcHumidifierType::declaration() const { return *IfcHumidifierType_type; }
const IfcParse::entity& IfcHumidifierType::Class() { return *IfcHumidifierType_type; }
IfcHumidifierType::IfcHumidifierType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcHumidifierType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcHumidifierType::IfcHumidifierType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcHumidifierType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcHumidifierTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcIShapeProfileDef
double IfcIShapeProfileDef::OverallWidth() const { return *data_->getArgument(3); }
void IfcIShapeProfileDef::setOverallWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcIShapeProfileDef::OverallDepth() const { return *data_->getArgument(4); }
void IfcIShapeProfileDef::setOverallDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double IfcIShapeProfileDef::WebThickness() const { return *data_->getArgument(5); }
void IfcIShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double IfcIShapeProfileDef::FlangeThickness() const { return *data_->getArgument(6); }
void IfcIShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcIShapeProfileDef::hasFilletRadius() const { return !data_->getArgument(7)->isNull(); }
double IfcIShapeProfileDef::FilletRadius() const { return *data_->getArgument(7); }
void IfcIShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcIShapeProfileDef::hasFlangeEdgeRadius() const { return !data_->getArgument(8)->isNull(); }
double IfcIShapeProfileDef::FlangeEdgeRadius() const { return *data_->getArgument(8); }
void IfcIShapeProfileDef::setFlangeEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcIShapeProfileDef::hasFlangeSlope() const { return !data_->getArgument(9)->isNull(); }
double IfcIShapeProfileDef::FlangeSlope() const { return *data_->getArgument(9); }
void IfcIShapeProfileDef::setFlangeSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcIShapeProfileDef::declaration() const { return *IfcIShapeProfileDef_type; }
const IfcParse::entity& IfcIShapeProfileDef::Class() { return *IfcIShapeProfileDef_type; }
IfcIShapeProfileDef::IfcIShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcIShapeProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcIShapeProfileDef::IfcIShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallWidth, double v5_OverallDepth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_FlangeEdgeRadius, boost::optional< double > v10_FlangeSlope) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcIShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OverallWidth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_OverallDepth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));data_->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_FlangeEdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FlangeEdgeRadius));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_FlangeSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_FlangeSlope));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcImageTexture
std::string IfcImageTexture::URLReference() const { return *data_->getArgument(5); }
void IfcImageTexture::setURLReference(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcImageTexture::declaration() const { return *IfcImageTexture_type; }
const IfcParse::entity& IfcImageTexture::Class() { return *IfcImageTexture_type; }
IfcImageTexture::IfcImageTexture(IfcEntityInstanceData* e) : IfcSurfaceTexture((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcImageTexture_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcImageTexture::IfcImageTexture(bool v1_RepeatS, bool v2_RepeatT, boost::optional< std::string > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_Parameter, std::string v6_URLReference) : IfcSurfaceTexture((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcImageTexture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));data_->setArgument(1,attr);} if (v3_Mode) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Mode));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));data_->setArgument(3,attr);} if (v5_Parameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Parameter));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_URLReference));data_->setArgument(5,attr);} }

// Function implementations for IfcIndexedColourMap
IfcTessellatedFaceSet* IfcIndexedColourMap::MappedTo() const { return (IfcTessellatedFaceSet*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcIndexedColourMap::setMappedTo(IfcTessellatedFaceSet* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcIndexedColourMap::hasOpacity() const { return !data_->getArgument(1)->isNull(); }
double IfcIndexedColourMap::Opacity() const { return *data_->getArgument(1); }
void IfcIndexedColourMap::setOpacity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcColourRgbList* IfcIndexedColourMap::Colours() const { return (IfcColourRgbList*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcIndexedColourMap::setColours(IfcColourRgbList* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
std::vector< int > /*[1:?]*/ IfcIndexedColourMap::ColourIndex() const { return *data_->getArgument(3); }
void IfcIndexedColourMap::setColourIndex(std::vector< int > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcIndexedColourMap::declaration() const { return *IfcIndexedColourMap_type; }
const IfcParse::entity& IfcIndexedColourMap::Class() { return *IfcIndexedColourMap_type; }
IfcIndexedColourMap::IfcIndexedColourMap(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcIndexedColourMap_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcIndexedColourMap::IfcIndexedColourMap(IfcTessellatedFaceSet* v1_MappedTo, boost::optional< double > v2_Opacity, IfcColourRgbList* v3_Colours, std::vector< int > /*[1:?]*/ v4_ColourIndex) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcIndexedColourMap_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MappedTo));data_->setArgument(0,attr);} if (v2_Opacity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Opacity));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Colours));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ColourIndex));data_->setArgument(3,attr);} }

// Function implementations for IfcIndexedPolyCurve
IfcCartesianPointList* IfcIndexedPolyCurve::Points() const { return (IfcCartesianPointList*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcIndexedPolyCurve::setPoints(IfcCartesianPointList* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcIndexedPolyCurve::hasSegments() const { return !data_->getArgument(1)->isNull(); }
IfcEntityList::ptr IfcIndexedPolyCurve::Segments() const { return *data_->getArgument(1); }
void IfcIndexedPolyCurve::setSegments(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcIndexedPolyCurve::hasSelfIntersect() const { return !data_->getArgument(2)->isNull(); }
bool IfcIndexedPolyCurve::SelfIntersect() const { return *data_->getArgument(2); }
void IfcIndexedPolyCurve::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcIndexedPolyCurve::declaration() const { return *IfcIndexedPolyCurve_type; }
const IfcParse::entity& IfcIndexedPolyCurve::Class() { return *IfcIndexedPolyCurve_type; }
IfcIndexedPolyCurve::IfcIndexedPolyCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcIndexedPolyCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcIndexedPolyCurve::IfcIndexedPolyCurve(IfcCartesianPointList* v1_Points, boost::optional< IfcEntityList::ptr > v2_Segments, boost::optional< bool > v3_SelfIntersect) : IfcBoundedCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcIndexedPolyCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Points));data_->setArgument(0,attr);} if (v2_Segments) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Segments));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_SelfIntersect) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_SelfIntersect));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcIndexedTextureMap
IfcTessellatedFaceSet* IfcIndexedTextureMap::MappedTo() const { return (IfcTessellatedFaceSet*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcIndexedTextureMap::setMappedTo(IfcTessellatedFaceSet* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcTextureVertexList* IfcIndexedTextureMap::TexCoords() const { return (IfcTextureVertexList*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcIndexedTextureMap::setTexCoords(IfcTextureVertexList* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcIndexedTextureMap::declaration() const { return *IfcIndexedTextureMap_type; }
const IfcParse::entity& IfcIndexedTextureMap::Class() { return *IfcIndexedTextureMap_type; }
IfcIndexedTextureMap::IfcIndexedTextureMap(IfcEntityInstanceData* e) : IfcTextureCoordinate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcIndexedTextureMap_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcIndexedTextureMap::IfcIndexedTextureMap(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps, IfcTessellatedFaceSet* v2_MappedTo, IfcTextureVertexList* v3_TexCoords) : IfcTextureCoordinate((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcIndexedTextureMap_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Maps)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MappedTo));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TexCoords));data_->setArgument(2,attr);} }

// Function implementations for IfcIndexedTriangleTextureMap
bool IfcIndexedTriangleTextureMap::hasTexCoordIndex() const { return !data_->getArgument(3)->isNull(); }
std::vector< std::vector< int > > IfcIndexedTriangleTextureMap::TexCoordIndex() const { return *data_->getArgument(3); }
void IfcIndexedTriangleTextureMap::setTexCoordIndex(std::vector< std::vector< int > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcIndexedTriangleTextureMap::declaration() const { return *IfcIndexedTriangleTextureMap_type; }
const IfcParse::entity& IfcIndexedTriangleTextureMap::Class() { return *IfcIndexedTriangleTextureMap_type; }
IfcIndexedTriangleTextureMap::IfcIndexedTriangleTextureMap(IfcEntityInstanceData* e) : IfcIndexedTextureMap((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcIndexedTriangleTextureMap_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcIndexedTriangleTextureMap::IfcIndexedTriangleTextureMap(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps, IfcTessellatedFaceSet* v2_MappedTo, IfcTextureVertexList* v3_TexCoords, boost::optional< std::vector< std::vector< int > > > v4_TexCoordIndex) : IfcIndexedTextureMap((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcIndexedTriangleTextureMap_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Maps)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MappedTo));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TexCoords));data_->setArgument(2,attr);} if (v4_TexCoordIndex) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_TexCoordIndex));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcInterceptor
bool IfcInterceptor::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcInterceptorTypeEnum::IfcInterceptorTypeEnum IfcInterceptor::PredefinedType() const { return IfcInterceptorTypeEnum::FromString(*data_->getArgument(8)); }
void IfcInterceptor::setPredefinedType(IfcInterceptorTypeEnum::IfcInterceptorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcInterceptorTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcInterceptor::declaration() const { return *IfcInterceptor_type; }
const IfcParse::entity& IfcInterceptor::Class() { return *IfcInterceptor_type; }
IfcInterceptor::IfcInterceptor(IfcEntityInstanceData* e) : IfcFlowTreatmentDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcInterceptor_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcInterceptor::IfcInterceptor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcInterceptorTypeEnum::IfcInterceptorTypeEnum > v9_PredefinedType) : IfcFlowTreatmentDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcInterceptor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcInterceptorTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcInterceptorType
IfcInterceptorTypeEnum::IfcInterceptorTypeEnum IfcInterceptorType::PredefinedType() const { return IfcInterceptorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcInterceptorType::setPredefinedType(IfcInterceptorTypeEnum::IfcInterceptorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcInterceptorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcInterceptorType::declaration() const { return *IfcInterceptorType_type; }
const IfcParse::entity& IfcInterceptorType::Class() { return *IfcInterceptorType_type; }
IfcInterceptorType::IfcInterceptorType(IfcEntityInstanceData* e) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcInterceptorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcInterceptorType::IfcInterceptorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcInterceptorTypeEnum::IfcInterceptorTypeEnum v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcInterceptorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcInterceptorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcInventory
bool IfcInventory::hasPredefinedType() const { return !data_->getArgument(5)->isNull(); }
IfcInventoryTypeEnum::IfcInventoryTypeEnum IfcInventory::PredefinedType() const { return IfcInventoryTypeEnum::FromString(*data_->getArgument(5)); }
void IfcInventory::setPredefinedType(IfcInventoryTypeEnum::IfcInventoryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcInventoryTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
bool IfcInventory::hasJurisdiction() const { return !data_->getArgument(6)->isNull(); }
IfcActorSelect* IfcInventory::Jurisdiction() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcInventory::setJurisdiction(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcInventory::hasResponsiblePersons() const { return !data_->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcPerson >::ptr IfcInventory::ResponsiblePersons() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcPerson>(); }
void IfcInventory::setResponsiblePersons(IfcTemplatedEntityList< IfcPerson >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }
bool IfcInventory::hasLastUpdateDate() const { return !data_->getArgument(8)->isNull(); }
std::string IfcInventory::LastUpdateDate() const { return *data_->getArgument(8); }
void IfcInventory::setLastUpdateDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcInventory::hasCurrentValue() const { return !data_->getArgument(9)->isNull(); }
IfcCostValue* IfcInventory::CurrentValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcInventory::setCurrentValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcInventory::hasOriginalValue() const { return !data_->getArgument(10)->isNull(); }
IfcCostValue* IfcInventory::OriginalValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(10))); }
void IfcInventory::setOriginalValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcInventory::declaration() const { return *IfcInventory_type; }
const IfcParse::entity& IfcInventory::Class() { return *IfcInventory_type; }
IfcInventory::IfcInventory(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcInventory_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcInventory::IfcInventory(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< IfcInventoryTypeEnum::IfcInventoryTypeEnum > v6_PredefinedType, IfcActorSelect* v7_Jurisdiction, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_ResponsiblePersons, boost::optional< std::string > v9_LastUpdateDate, IfcCostValue* v10_CurrentValue, IfcCostValue* v11_OriginalValue) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcInventory_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_PredefinedType,IfcInventoryTypeEnum::ToString(*v6_PredefinedType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Jurisdiction));data_->setArgument(6,attr);} if (v8_ResponsiblePersons) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_ResponsiblePersons)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_LastUpdateDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_LastUpdateDate));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_CurrentValue));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_OriginalValue));data_->setArgument(10,attr);} }

// Function implementations for IfcIrregularTimeSeries
IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr IfcIrregularTimeSeries::Values() const { IfcEntityList::ptr es = *data_->getArgument(8); return es->as<IfcIrregularTimeSeriesValue>(); }
void IfcIrregularTimeSeries::setValues(IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(8,attr);} }


const IfcParse::entity& IfcIrregularTimeSeries::declaration() const { return *IfcIrregularTimeSeries_type; }
const IfcParse::entity& IfcIrregularTimeSeries::Class() { return *IfcIrregularTimeSeries_type; }
IfcIrregularTimeSeries::IfcIrregularTimeSeries(IfcEntityInstanceData* e) : IfcTimeSeries((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcIrregularTimeSeries_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcIrregularTimeSeries::IfcIrregularTimeSeries(std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_StartTime, std::string v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit, IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr v9_Values) : IfcTimeSeries((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcIrregularTimeSeries_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_StartTime));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EndTime));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_TimeSeriesDataType,IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_DataOrigin,IfcDataOriginEnum::ToString(v6_DataOrigin))));data_->setArgument(5,attr);} if (v7_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedDataOrigin));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Unit));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_Values)->generalize());data_->setArgument(8,attr);} }

// Function implementations for IfcIrregularTimeSeriesValue
std::string IfcIrregularTimeSeriesValue::TimeStamp() const { return *data_->getArgument(0); }
void IfcIrregularTimeSeriesValue::setTimeStamp(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcEntityList::ptr IfcIrregularTimeSeriesValue::ListValues() const { return *data_->getArgument(1); }
void IfcIrregularTimeSeriesValue::setListValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcIrregularTimeSeriesValue::declaration() const { return *IfcIrregularTimeSeriesValue_type; }
const IfcParse::entity& IfcIrregularTimeSeriesValue::Class() { return *IfcIrregularTimeSeriesValue_type; }
IfcIrregularTimeSeriesValue::IfcIrregularTimeSeriesValue(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcIrregularTimeSeriesValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcIrregularTimeSeriesValue::IfcIrregularTimeSeriesValue(std::string v1_TimeStamp, IfcEntityList::ptr v2_ListValues) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcIrregularTimeSeriesValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TimeStamp));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ListValues));data_->setArgument(1,attr);} }

// Function implementations for IfcJunctionBox
bool IfcJunctionBox::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum IfcJunctionBox::PredefinedType() const { return IfcJunctionBoxTypeEnum::FromString(*data_->getArgument(8)); }
void IfcJunctionBox::setPredefinedType(IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcJunctionBoxTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcJunctionBox::declaration() const { return *IfcJunctionBox_type; }
const IfcParse::entity& IfcJunctionBox::Class() { return *IfcJunctionBox_type; }
IfcJunctionBox::IfcJunctionBox(IfcEntityInstanceData* e) : IfcFlowFitting((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcJunctionBox_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcJunctionBox::IfcJunctionBox(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcJunctionBox_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcJunctionBoxTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcJunctionBoxType
IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum IfcJunctionBoxType::PredefinedType() const { return IfcJunctionBoxTypeEnum::FromString(*data_->getArgument(9)); }
void IfcJunctionBoxType::setPredefinedType(IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcJunctionBoxTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcJunctionBoxType::declaration() const { return *IfcJunctionBoxType_type; }
const IfcParse::entity& IfcJunctionBoxType::Class() { return *IfcJunctionBoxType_type; }
IfcJunctionBoxType::IfcJunctionBoxType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcJunctionBoxType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcJunctionBoxType::IfcJunctionBoxType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcJunctionBoxType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcJunctionBoxTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcLShapeProfileDef
double IfcLShapeProfileDef::Depth() const { return *data_->getArgument(3); }
void IfcLShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcLShapeProfileDef::hasWidth() const { return !data_->getArgument(4)->isNull(); }
double IfcLShapeProfileDef::Width() const { return *data_->getArgument(4); }
void IfcLShapeProfileDef::setWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double IfcLShapeProfileDef::Thickness() const { return *data_->getArgument(5); }
void IfcLShapeProfileDef::setThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcLShapeProfileDef::hasFilletRadius() const { return !data_->getArgument(6)->isNull(); }
double IfcLShapeProfileDef::FilletRadius() const { return *data_->getArgument(6); }
void IfcLShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcLShapeProfileDef::hasEdgeRadius() const { return !data_->getArgument(7)->isNull(); }
double IfcLShapeProfileDef::EdgeRadius() const { return *data_->getArgument(7); }
void IfcLShapeProfileDef::setEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcLShapeProfileDef::hasLegSlope() const { return !data_->getArgument(8)->isNull(); }
double IfcLShapeProfileDef::LegSlope() const { return *data_->getArgument(8); }
void IfcLShapeProfileDef::setLegSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcLShapeProfileDef::declaration() const { return *IfcLShapeProfileDef_type; }
const IfcParse::entity& IfcLShapeProfileDef::Class() { return *IfcLShapeProfileDef_type; }
IfcLShapeProfileDef::IfcLShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLShapeProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLShapeProfileDef::IfcLShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, boost::optional< double > v5_Width, double v6_Thickness, boost::optional< double > v7_FilletRadius, boost::optional< double > v8_EdgeRadius, boost::optional< double > v9_LegSlope) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);} if (v5_Width) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Width));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Thickness));data_->setArgument(5,attr);} if (v7_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_FilletRadius));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_EdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_EdgeRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_LegSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_LegSlope));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcLaborResource
bool IfcLaborResource::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum IfcLaborResource::PredefinedType() const { return IfcLaborResourceTypeEnum::FromString(*data_->getArgument(10)); }
void IfcLaborResource::setPredefinedType(IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLaborResourceTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& IfcLaborResource::declaration() const { return *IfcLaborResource_type; }
const IfcParse::entity& IfcLaborResource::Class() { return *IfcLaborResource_type; }
IfcLaborResource::IfcLaborResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLaborResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLaborResource::IfcLaborResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLaborResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Usage));data_->setArgument(7,attr);} if (v9_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_BaseCosts)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_BaseQuantity));data_->setArgument(9,attr);} if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcLaborResourceTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcLaborResourceType
IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum IfcLaborResourceType::PredefinedType() const { return IfcLaborResourceTypeEnum::FromString(*data_->getArgument(11)); }
void IfcLaborResourceType::setPredefinedType(IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLaborResourceTypeEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcLaborResourceType::declaration() const { return *IfcLaborResourceType_type; }
const IfcParse::entity& IfcLaborResourceType::Class() { return *IfcLaborResourceType_type; }
IfcLaborResourceType::IfcLaborResourceType(IfcEntityInstanceData* e) : IfcConstructionResourceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLaborResourceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLaborResourceType::IfcLaborResourceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLaborResourceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ResourceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ResourceType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_BaseCosts)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseQuantity));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcLaborResourceTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcLagTime
IfcTimeOrRatioSelect* IfcLagTime::LagValue() const { return (IfcTimeOrRatioSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcLagTime::setLagValue(IfcTimeOrRatioSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
IfcTaskDurationEnum::IfcTaskDurationEnum IfcLagTime::DurationType() const { return IfcTaskDurationEnum::FromString(*data_->getArgument(4)); }
void IfcLagTime::setDurationType(IfcTaskDurationEnum::IfcTaskDurationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTaskDurationEnum::ToString(v)));data_->setArgument(4,attr);} }


const IfcParse::entity& IfcLagTime::declaration() const { return *IfcLagTime_type; }
const IfcParse::entity& IfcLagTime::Class() { return *IfcLagTime_type; }
IfcLagTime::IfcLagTime(IfcEntityInstanceData* e) : IfcSchedulingTime((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLagTime_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLagTime::IfcLagTime(boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, IfcTimeOrRatioSelect* v4_LagValue, IfcTaskDurationEnum::IfcTaskDurationEnum v5_DurationType) : IfcSchedulingTime((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLagTime_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin))));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedDataOrigin));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LagValue));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_DurationType,IfcTaskDurationEnum::ToString(v5_DurationType))));data_->setArgument(4,attr);} }

// Function implementations for IfcLamp
bool IfcLamp::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcLampTypeEnum::IfcLampTypeEnum IfcLamp::PredefinedType() const { return IfcLampTypeEnum::FromString(*data_->getArgument(8)); }
void IfcLamp::setPredefinedType(IfcLampTypeEnum::IfcLampTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLampTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcLamp::declaration() const { return *IfcLamp_type; }
const IfcParse::entity& IfcLamp::Class() { return *IfcLamp_type; }
IfcLamp::IfcLamp(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLamp_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLamp::IfcLamp(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcLampTypeEnum::IfcLampTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLamp_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcLampTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcLampType
IfcLampTypeEnum::IfcLampTypeEnum IfcLampType::PredefinedType() const { return IfcLampTypeEnum::FromString(*data_->getArgument(9)); }
void IfcLampType::setPredefinedType(IfcLampTypeEnum::IfcLampTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLampTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcLampType::declaration() const { return *IfcLampType_type; }
const IfcParse::entity& IfcLampType::Class() { return *IfcLampType_type; }
IfcLampType::IfcLampType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLampType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLampType::IfcLampType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcLampTypeEnum::IfcLampTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLampType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcLampTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcLibraryInformation
std::string IfcLibraryInformation::Name() const { return *data_->getArgument(0); }
void IfcLibraryInformation::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcLibraryInformation::hasVersion() const { return !data_->getArgument(1)->isNull(); }
std::string IfcLibraryInformation::Version() const { return *data_->getArgument(1); }
void IfcLibraryInformation::setVersion(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcLibraryInformation::hasPublisher() const { return !data_->getArgument(2)->isNull(); }
IfcActorSelect* IfcLibraryInformation::Publisher() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcLibraryInformation::setPublisher(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcLibraryInformation::hasVersionDate() const { return !data_->getArgument(3)->isNull(); }
std::string IfcLibraryInformation::VersionDate() const { return *data_->getArgument(3); }
void IfcLibraryInformation::setVersionDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcLibraryInformation::hasLocation() const { return !data_->getArgument(4)->isNull(); }
std::string IfcLibraryInformation::Location() const { return *data_->getArgument(4); }
void IfcLibraryInformation::setLocation(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcLibraryInformation::hasDescription() const { return !data_->getArgument(5)->isNull(); }
std::string IfcLibraryInformation::Description() const { return *data_->getArgument(5); }
void IfcLibraryInformation::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

IfcRelAssociatesLibrary::list::ptr IfcLibraryInformation::LibraryInfoForObjects() const { return data_->getInverse(IfcRelAssociatesLibrary_type, 5)->as<IfcRelAssociatesLibrary>(); }
IfcLibraryReference::list::ptr IfcLibraryInformation::HasLibraryReferences() const { return data_->getInverse(IfcLibraryReference_type, 5)->as<IfcLibraryReference>(); }

const IfcParse::entity& IfcLibraryInformation::declaration() const { return *IfcLibraryInformation_type; }
const IfcParse::entity& IfcLibraryInformation::Class() { return *IfcLibraryInformation_type; }
IfcLibraryInformation::IfcLibraryInformation(IfcEntityInstanceData* e) : IfcExternalInformation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLibraryInformation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLibraryInformation::IfcLibraryInformation(std::string v1_Name, boost::optional< std::string > v2_Version, IfcActorSelect* v3_Publisher, boost::optional< std::string > v4_VersionDate, boost::optional< std::string > v5_Location, boost::optional< std::string > v6_Description) : IfcExternalInformation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLibraryInformation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Version) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Version));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Publisher));data_->setArgument(2,attr);} if (v4_VersionDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_VersionDate));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Location));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Description));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcLibraryReference
bool IfcLibraryReference::hasDescription() const { return !data_->getArgument(3)->isNull(); }
std::string IfcLibraryReference::Description() const { return *data_->getArgument(3); }
void IfcLibraryReference::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcLibraryReference::hasLanguage() const { return !data_->getArgument(4)->isNull(); }
std::string IfcLibraryReference::Language() const { return *data_->getArgument(4); }
void IfcLibraryReference::setLanguage(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcLibraryReference::hasReferencedLibrary() const { return !data_->getArgument(5)->isNull(); }
IfcLibraryInformation* IfcLibraryReference::ReferencedLibrary() const { return (IfcLibraryInformation*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcLibraryReference::setReferencedLibrary(IfcLibraryInformation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

IfcRelAssociatesLibrary::list::ptr IfcLibraryReference::LibraryRefForObjects() const { return data_->getInverse(IfcRelAssociatesLibrary_type, 5)->as<IfcRelAssociatesLibrary>(); }

const IfcParse::entity& IfcLibraryReference::declaration() const { return *IfcLibraryReference_type; }
const IfcParse::entity& IfcLibraryReference::Class() { return *IfcLibraryReference_type; }
IfcLibraryReference::IfcLibraryReference(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLibraryReference_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLibraryReference::IfcLibraryReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_Language, IfcLibraryInformation* v6_ReferencedLibrary) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLibraryReference_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Identification));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Language) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Language));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReferencedLibrary));data_->setArgument(5,attr);} }

// Function implementations for IfcLightDistributionData
double IfcLightDistributionData::MainPlaneAngle() const { return *data_->getArgument(0); }
void IfcLightDistributionData::setMainPlaneAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::vector< double > /*[1:?]*/ IfcLightDistributionData::SecondaryPlaneAngle() const { return *data_->getArgument(1); }
void IfcLightDistributionData::setSecondaryPlaneAngle(std::vector< double > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
std::vector< double > /*[1:?]*/ IfcLightDistributionData::LuminousIntensity() const { return *data_->getArgument(2); }
void IfcLightDistributionData::setLuminousIntensity(std::vector< double > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcLightDistributionData::declaration() const { return *IfcLightDistributionData_type; }
const IfcParse::entity& IfcLightDistributionData::Class() { return *IfcLightDistributionData_type; }
IfcLightDistributionData::IfcLightDistributionData(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcLightDistributionData_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightDistributionData::IfcLightDistributionData(double v1_MainPlaneAngle, std::vector< double > /*[1:?]*/ v2_SecondaryPlaneAngle, std::vector< double > /*[1:?]*/ v3_LuminousIntensity) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcLightDistributionData_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MainPlaneAngle));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SecondaryPlaneAngle));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LuminousIntensity));data_->setArgument(2,attr);} }

// Function implementations for IfcLightFixture
bool IfcLightFixture::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum IfcLightFixture::PredefinedType() const { return IfcLightFixtureTypeEnum::FromString(*data_->getArgument(8)); }
void IfcLightFixture::setPredefinedType(IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLightFixtureTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcLightFixture::declaration() const { return *IfcLightFixture_type; }
const IfcParse::entity& IfcLightFixture::Class() { return *IfcLightFixture_type; }
IfcLightFixture::IfcLightFixture(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLightFixture_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightFixture::IfcLightFixture(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLightFixture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcLightFixtureTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcLightFixtureType
IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum IfcLightFixtureType::PredefinedType() const { return IfcLightFixtureTypeEnum::FromString(*data_->getArgument(9)); }
void IfcLightFixtureType::setPredefinedType(IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLightFixtureTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcLightFixtureType::declaration() const { return *IfcLightFixtureType_type; }
const IfcParse::entity& IfcLightFixtureType::Class() { return *IfcLightFixtureType_type; }
IfcLightFixtureType::IfcLightFixtureType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLightFixtureType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightFixtureType::IfcLightFixtureType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLightFixtureType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcLightFixtureTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcLightIntensityDistribution
IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum IfcLightIntensityDistribution::LightDistributionCurve() const { return IfcLightDistributionCurveEnum::FromString(*data_->getArgument(0)); }
void IfcLightIntensityDistribution::setLightDistributionCurve(IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLightDistributionCurveEnum::ToString(v)));data_->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcLightDistributionData >::ptr IfcLightIntensityDistribution::DistributionData() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcLightDistributionData>(); }
void IfcLightIntensityDistribution::setDistributionData(IfcTemplatedEntityList< IfcLightDistributionData >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& IfcLightIntensityDistribution::declaration() const { return *IfcLightIntensityDistribution_type; }
const IfcParse::entity& IfcLightIntensityDistribution::Class() { return *IfcLightIntensityDistribution_type; }
IfcLightIntensityDistribution::IfcLightIntensityDistribution(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcLightIntensityDistribution_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightIntensityDistribution::IfcLightIntensityDistribution(IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v1_LightDistributionCurve, IfcTemplatedEntityList< IfcLightDistributionData >::ptr v2_DistributionData) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcLightIntensityDistribution_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_LightDistributionCurve,IfcLightDistributionCurveEnum::ToString(v1_LightDistributionCurve))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_DistributionData)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcLightSource
bool IfcLightSource::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcLightSource::Name() const { return *data_->getArgument(0); }
void IfcLightSource::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcColourRgb* IfcLightSource::LightColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcLightSource::setLightColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcLightSource::hasAmbientIntensity() const { return !data_->getArgument(2)->isNull(); }
double IfcLightSource::AmbientIntensity() const { return *data_->getArgument(2); }
void IfcLightSource::setAmbientIntensity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcLightSource::hasIntensity() const { return !data_->getArgument(3)->isNull(); }
double IfcLightSource::Intensity() const { return *data_->getArgument(3); }
void IfcLightSource::setIntensity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcLightSource::declaration() const { return *IfcLightSource_type; }
const IfcParse::entity& IfcLightSource::Class() { return *IfcLightSource_type; }
IfcLightSource::IfcLightSource(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLightSource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightSource::IfcLightSource(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLightSource_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcLightSourceAmbient


const IfcParse::entity& IfcLightSourceAmbient::declaration() const { return *IfcLightSourceAmbient_type; }
const IfcParse::entity& IfcLightSourceAmbient::Class() { return *IfcLightSourceAmbient_type; }
IfcLightSourceAmbient::IfcLightSourceAmbient(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLightSourceAmbient_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightSourceAmbient::IfcLightSourceAmbient(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity) : IfcLightSource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLightSourceAmbient_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcLightSourceDirectional
IfcDirection* IfcLightSourceDirectional::Orientation() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcLightSourceDirectional::setOrientation(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcLightSourceDirectional::declaration() const { return *IfcLightSourceDirectional_type; }
const IfcParse::entity& IfcLightSourceDirectional::Class() { return *IfcLightSourceDirectional_type; }
IfcLightSourceDirectional::IfcLightSourceDirectional(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLightSourceDirectional_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightSourceDirectional::IfcLightSourceDirectional(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcDirection* v5_Orientation) : IfcLightSource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLightSourceDirectional_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Orientation));data_->setArgument(4,attr);} }

// Function implementations for IfcLightSourceGoniometric
IfcAxis2Placement3D* IfcLightSourceGoniometric::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcLightSourceGoniometric::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcLightSourceGoniometric::hasColourAppearance() const { return !data_->getArgument(5)->isNull(); }
IfcColourRgb* IfcLightSourceGoniometric::ColourAppearance() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcLightSourceGoniometric::setColourAppearance(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double IfcLightSourceGoniometric::ColourTemperature() const { return *data_->getArgument(6); }
void IfcLightSourceGoniometric::setColourTemperature(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
double IfcLightSourceGoniometric::LuminousFlux() const { return *data_->getArgument(7); }
void IfcLightSourceGoniometric::setLuminousFlux(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum IfcLightSourceGoniometric::LightEmissionSource() const { return IfcLightEmissionSourceEnum::FromString(*data_->getArgument(8)); }
void IfcLightSourceGoniometric::setLightEmissionSource(IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLightEmissionSourceEnum::ToString(v)));data_->setArgument(8,attr);} }
IfcLightDistributionDataSourceSelect* IfcLightSourceGoniometric::LightDistributionDataSource() const { return (IfcLightDistributionDataSourceSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcLightSourceGoniometric::setLightDistributionDataSource(IfcLightDistributionDataSourceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcLightSourceGoniometric::declaration() const { return *IfcLightSourceGoniometric_type; }
const IfcParse::entity& IfcLightSourceGoniometric::Class() { return *IfcLightSourceGoniometric_type; }
IfcLightSourceGoniometric::IfcLightSourceGoniometric(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLightSourceGoniometric_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightSourceGoniometric::IfcLightSourceGoniometric(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcAxis2Placement3D* v5_Position, IfcColourRgb* v6_ColourAppearance, double v7_ColourTemperature, double v8_LuminousFlux, IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v9_LightEmissionSource, IfcLightDistributionDataSourceSelect* v10_LightDistributionDataSource) : IfcLightSource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLightSourceGoniometric_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Position));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ColourAppearance));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ColourTemperature));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LuminousFlux));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_LightEmissionSource,IfcLightEmissionSourceEnum::ToString(v9_LightEmissionSource))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_LightDistributionDataSource));data_->setArgument(9,attr);} }

// Function implementations for IfcLightSourcePositional
IfcCartesianPoint* IfcLightSourcePositional::Position() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcLightSourcePositional::setPosition(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double IfcLightSourcePositional::Radius() const { return *data_->getArgument(5); }
void IfcLightSourcePositional::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double IfcLightSourcePositional::ConstantAttenuation() const { return *data_->getArgument(6); }
void IfcLightSourcePositional::setConstantAttenuation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
double IfcLightSourcePositional::DistanceAttenuation() const { return *data_->getArgument(7); }
void IfcLightSourcePositional::setDistanceAttenuation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
double IfcLightSourcePositional::QuadricAttenuation() const { return *data_->getArgument(8); }
void IfcLightSourcePositional::setQuadricAttenuation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcLightSourcePositional::declaration() const { return *IfcLightSourcePositional_type; }
const IfcParse::entity& IfcLightSourcePositional::Class() { return *IfcLightSourcePositional_type; }
IfcLightSourcePositional::IfcLightSourcePositional(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLightSourcePositional_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightSourcePositional::IfcLightSourcePositional(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation) : IfcLightSource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLightSourcePositional_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Position));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Radius));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConstantAttenuation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_DistanceAttenuation));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_QuadricAttenuation));data_->setArgument(8,attr);} }

// Function implementations for IfcLightSourceSpot
IfcDirection* IfcLightSourceSpot::Orientation() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcLightSourceSpot::setOrientation(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcLightSourceSpot::hasConcentrationExponent() const { return !data_->getArgument(10)->isNull(); }
double IfcLightSourceSpot::ConcentrationExponent() const { return *data_->getArgument(10); }
void IfcLightSourceSpot::setConcentrationExponent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
double IfcLightSourceSpot::SpreadAngle() const { return *data_->getArgument(11); }
void IfcLightSourceSpot::setSpreadAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
double IfcLightSourceSpot::BeamWidthAngle() const { return *data_->getArgument(12); }
void IfcLightSourceSpot::setBeamWidthAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& IfcLightSourceSpot::declaration() const { return *IfcLightSourceSpot_type; }
const IfcParse::entity& IfcLightSourceSpot::Class() { return *IfcLightSourceSpot_type; }
IfcLightSourceSpot::IfcLightSourceSpot(IfcEntityInstanceData* e) : IfcLightSourcePositional((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLightSourceSpot_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLightSourceSpot::IfcLightSourceSpot(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation, IfcDirection* v10_Orientation, boost::optional< double > v11_ConcentrationExponent, double v12_SpreadAngle, double v13_BeamWidthAngle) : IfcLightSourcePositional((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLightSourceSpot_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Position));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Radius));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConstantAttenuation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_DistanceAttenuation));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_QuadricAttenuation));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_Orientation));data_->setArgument(9,attr);} if (v11_ConcentrationExponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ConcentrationExponent));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_SpreadAngle));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_BeamWidthAngle));data_->setArgument(12,attr);} }

// Function implementations for IfcLine
IfcCartesianPoint* IfcLine::Pnt() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcLine::setPnt(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcVector* IfcLine::Dir() const { return (IfcVector*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcLine::setDir(IfcVector* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcLine::declaration() const { return *IfcLine_type; }
const IfcParse::entity& IfcLine::Class() { return *IfcLine_type; }
IfcLine::IfcLine(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLine_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLine::IfcLine(IfcCartesianPoint* v1_Pnt, IfcVector* v2_Dir) : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLine_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Pnt));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Dir));data_->setArgument(1,attr);} }

// Function implementations for IfcLocalPlacement
bool IfcLocalPlacement::hasPlacementRelTo() const { return !data_->getArgument(0)->isNull(); }
IfcObjectPlacement* IfcLocalPlacement::PlacementRelTo() const { return (IfcObjectPlacement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcLocalPlacement::setPlacementRelTo(IfcObjectPlacement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcAxis2Placement* IfcLocalPlacement::RelativePlacement() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcLocalPlacement::setRelativePlacement(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcLocalPlacement::declaration() const { return *IfcLocalPlacement_type; }
const IfcParse::entity& IfcLocalPlacement::Class() { return *IfcLocalPlacement_type; }
IfcLocalPlacement::IfcLocalPlacement(IfcEntityInstanceData* e) : IfcObjectPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLocalPlacement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLocalPlacement::IfcLocalPlacement(IfcObjectPlacement* v1_PlacementRelTo, IfcAxis2Placement* v2_RelativePlacement) : IfcObjectPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLocalPlacement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PlacementRelTo));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelativePlacement));data_->setArgument(1,attr);} }

// Function implementations for IfcLoop


const IfcParse::entity& IfcLoop::declaration() const { return *IfcLoop_type; }
const IfcParse::entity& IfcLoop::Class() { return *IfcLoop_type; }
IfcLoop::IfcLoop(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcLoop_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcLoop::IfcLoop() : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcLoop_type);  }

// Function implementations for IfcManifoldSolidBrep
IfcClosedShell* IfcManifoldSolidBrep::Outer() const { return (IfcClosedShell*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcManifoldSolidBrep::setOuter(IfcClosedShell* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcManifoldSolidBrep::declaration() const { return *IfcManifoldSolidBrep_type; }
const IfcParse::entity& IfcManifoldSolidBrep::Class() { return *IfcManifoldSolidBrep_type; }
IfcManifoldSolidBrep::IfcManifoldSolidBrep(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcManifoldSolidBrep_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcManifoldSolidBrep::IfcManifoldSolidBrep(IfcClosedShell* v1_Outer) : IfcSolidModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcManifoldSolidBrep_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));data_->setArgument(0,attr);} }

// Function implementations for IfcMapConversion
double IfcMapConversion::Eastings() const { return *data_->getArgument(2); }
void IfcMapConversion::setEastings(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double IfcMapConversion::Northings() const { return *data_->getArgument(3); }
void IfcMapConversion::setNorthings(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcMapConversion::OrthogonalHeight() const { return *data_->getArgument(4); }
void IfcMapConversion::setOrthogonalHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcMapConversion::hasXAxisAbscissa() const { return !data_->getArgument(5)->isNull(); }
double IfcMapConversion::XAxisAbscissa() const { return *data_->getArgument(5); }
void IfcMapConversion::setXAxisAbscissa(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcMapConversion::hasXAxisOrdinate() const { return !data_->getArgument(6)->isNull(); }
double IfcMapConversion::XAxisOrdinate() const { return *data_->getArgument(6); }
void IfcMapConversion::setXAxisOrdinate(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcMapConversion::hasScale() const { return !data_->getArgument(7)->isNull(); }
double IfcMapConversion::Scale() const { return *data_->getArgument(7); }
void IfcMapConversion::setScale(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcMapConversion::declaration() const { return *IfcMapConversion_type; }
const IfcParse::entity& IfcMapConversion::Class() { return *IfcMapConversion_type; }
IfcMapConversion::IfcMapConversion(IfcEntityInstanceData* e) : IfcCoordinateOperation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMapConversion_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMapConversion::IfcMapConversion(IfcCoordinateReferenceSystemSelect* v1_SourceCRS, IfcCoordinateReferenceSystem* v2_TargetCRS, double v3_Eastings, double v4_Northings, double v5_OrthogonalHeight, boost::optional< double > v6_XAxisAbscissa, boost::optional< double > v7_XAxisOrdinate, boost::optional< double > v8_Scale) : IfcCoordinateOperation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMapConversion_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SourceCRS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TargetCRS));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Eastings));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Northings));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_OrthogonalHeight));data_->setArgument(4,attr);} if (v6_XAxisAbscissa) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_XAxisAbscissa));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_XAxisOrdinate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_XAxisOrdinate));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Scale));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcMappedItem
IfcRepresentationMap* IfcMappedItem::MappingSource() const { return (IfcRepresentationMap*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcMappedItem::setMappingSource(IfcRepresentationMap* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcCartesianTransformationOperator* IfcMappedItem::MappingTarget() const { return (IfcCartesianTransformationOperator*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcMappedItem::setMappingTarget(IfcCartesianTransformationOperator* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcMappedItem::declaration() const { return *IfcMappedItem_type; }
const IfcParse::entity& IfcMappedItem::Class() { return *IfcMappedItem_type; }
IfcMappedItem::IfcMappedItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMappedItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMappedItem::IfcMappedItem(IfcRepresentationMap* v1_MappingSource, IfcCartesianTransformationOperator* v2_MappingTarget) : IfcRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMappedItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MappingSource));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MappingTarget));data_->setArgument(1,attr);} }

// Function implementations for IfcMaterial
std::string IfcMaterial::Name() const { return *data_->getArgument(0); }
void IfcMaterial::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcMaterial::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcMaterial::Description() const { return *data_->getArgument(1); }
void IfcMaterial::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcMaterial::hasCategory() const { return !data_->getArgument(2)->isNull(); }
std::string IfcMaterial::Category() const { return *data_->getArgument(2); }
void IfcMaterial::setCategory(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

IfcMaterialDefinitionRepresentation::list::ptr IfcMaterial::HasRepresentation() const { return data_->getInverse(IfcMaterialDefinitionRepresentation_type, 3)->as<IfcMaterialDefinitionRepresentation>(); }
IfcMaterialRelationship::list::ptr IfcMaterial::IsRelatedWith() const { return data_->getInverse(IfcMaterialRelationship_type, 3)->as<IfcMaterialRelationship>(); }
IfcMaterialRelationship::list::ptr IfcMaterial::RelatesTo() const { return data_->getInverse(IfcMaterialRelationship_type, 2)->as<IfcMaterialRelationship>(); }

const IfcParse::entity& IfcMaterial::declaration() const { return *IfcMaterial_type; }
const IfcParse::entity& IfcMaterial::Class() { return *IfcMaterial_type; }
IfcMaterial::IfcMaterial(IfcEntityInstanceData* e) : IfcMaterialDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterial_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterial::IfcMaterial(std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_Category) : IfcMaterialDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterial_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Category) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Category));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcMaterialClassificationRelationship
IfcEntityList::ptr IfcMaterialClassificationRelationship::MaterialClassifications() const { return *data_->getArgument(0); }
void IfcMaterialClassificationRelationship::setMaterialClassifications(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcMaterial* IfcMaterialClassificationRelationship::ClassifiedMaterial() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcMaterialClassificationRelationship::setClassifiedMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcMaterialClassificationRelationship::declaration() const { return *IfcMaterialClassificationRelationship_type; }
const IfcParse::entity& IfcMaterialClassificationRelationship::Class() { return *IfcMaterialClassificationRelationship_type; }
IfcMaterialClassificationRelationship::IfcMaterialClassificationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcMaterialClassificationRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialClassificationRelationship::IfcMaterialClassificationRelationship(IfcEntityList::ptr v1_MaterialClassifications, IfcMaterial* v2_ClassifiedMaterial) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcMaterialClassificationRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MaterialClassifications));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ClassifiedMaterial));data_->setArgument(1,attr);} }

// Function implementations for IfcMaterialConstituent
bool IfcMaterialConstituent::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcMaterialConstituent::Name() const { return *data_->getArgument(0); }
void IfcMaterialConstituent::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcMaterialConstituent::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcMaterialConstituent::Description() const { return *data_->getArgument(1); }
void IfcMaterialConstituent::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcMaterial* IfcMaterialConstituent::Material() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcMaterialConstituent::setMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcMaterialConstituent::hasFraction() const { return !data_->getArgument(3)->isNull(); }
double IfcMaterialConstituent::Fraction() const { return *data_->getArgument(3); }
void IfcMaterialConstituent::setFraction(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcMaterialConstituent::hasCategory() const { return !data_->getArgument(4)->isNull(); }
std::string IfcMaterialConstituent::Category() const { return *data_->getArgument(4); }
void IfcMaterialConstituent::setCategory(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }

IfcMaterialConstituentSet::list::ptr IfcMaterialConstituent::ToMaterialConstituentSet() const { return data_->getInverse(IfcMaterialConstituentSet_type, 2)->as<IfcMaterialConstituentSet>(); }

const IfcParse::entity& IfcMaterialConstituent::declaration() const { return *IfcMaterialConstituent_type; }
const IfcParse::entity& IfcMaterialConstituent::Class() { return *IfcMaterialConstituent_type; }
IfcMaterialConstituent::IfcMaterialConstituent(IfcEntityInstanceData* e) : IfcMaterialDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialConstituent_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialConstituent::IfcMaterialConstituent(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMaterial* v3_Material, boost::optional< double > v4_Fraction, boost::optional< std::string > v5_Category) : IfcMaterialDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialConstituent_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Material));data_->setArgument(2,attr);} if (v4_Fraction) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Fraction));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Category) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Category));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcMaterialConstituentSet
bool IfcMaterialConstituentSet::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcMaterialConstituentSet::Name() const { return *data_->getArgument(0); }
void IfcMaterialConstituentSet::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcMaterialConstituentSet::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcMaterialConstituentSet::Description() const { return *data_->getArgument(1); }
void IfcMaterialConstituentSet::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcMaterialConstituentSet::hasMaterialConstituents() const { return !data_->getArgument(2)->isNull(); }
IfcTemplatedEntityList< IfcMaterialConstituent >::ptr IfcMaterialConstituentSet::MaterialConstituents() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcMaterialConstituent>(); }
void IfcMaterialConstituentSet::setMaterialConstituents(IfcTemplatedEntityList< IfcMaterialConstituent >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& IfcMaterialConstituentSet::declaration() const { return *IfcMaterialConstituentSet_type; }
const IfcParse::entity& IfcMaterialConstituentSet::Class() { return *IfcMaterialConstituentSet_type; }
IfcMaterialConstituentSet::IfcMaterialConstituentSet(IfcEntityInstanceData* e) : IfcMaterialDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialConstituentSet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialConstituentSet::IfcMaterialConstituentSet(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, boost::optional< IfcTemplatedEntityList< IfcMaterialConstituent >::ptr > v3_MaterialConstituents) : IfcMaterialDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialConstituentSet_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_MaterialConstituents) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_MaterialConstituents)->generalize());data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcMaterialDefinition

IfcRelAssociatesMaterial::list::ptr IfcMaterialDefinition::AssociatedTo() const { return data_->getInverse(IfcRelAssociatesMaterial_type, 5)->as<IfcRelAssociatesMaterial>(); }
IfcExternalReferenceRelationship::list::ptr IfcMaterialDefinition::HasExternalReferences() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }
IfcMaterialProperties::list::ptr IfcMaterialDefinition::HasProperties() const { return data_->getInverse(IfcMaterialProperties_type, 3)->as<IfcMaterialProperties>(); }

const IfcParse::entity& IfcMaterialDefinition::declaration() const { return *IfcMaterialDefinition_type; }
const IfcParse::entity& IfcMaterialDefinition::Class() { return *IfcMaterialDefinition_type; }
IfcMaterialDefinition::IfcMaterialDefinition(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcMaterialDefinition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialDefinition::IfcMaterialDefinition() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcMaterialDefinition_type);  }

// Function implementations for IfcMaterialDefinitionRepresentation
IfcMaterial* IfcMaterialDefinitionRepresentation::RepresentedMaterial() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcMaterialDefinitionRepresentation::setRepresentedMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcMaterialDefinitionRepresentation::declaration() const { return *IfcMaterialDefinitionRepresentation_type; }
const IfcParse::entity& IfcMaterialDefinitionRepresentation::Class() { return *IfcMaterialDefinitionRepresentation_type; }
IfcMaterialDefinitionRepresentation::IfcMaterialDefinitionRepresentation(IfcEntityInstanceData* e) : IfcProductRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialDefinitionRepresentation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialDefinitionRepresentation::IfcMaterialDefinitionRepresentation(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations, IfcMaterial* v4_RepresentedMaterial) : IfcProductRepresentation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialDefinitionRepresentation_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Representations)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RepresentedMaterial));data_->setArgument(3,attr);} }

// Function implementations for IfcMaterialLayer
bool IfcMaterialLayer::hasMaterial() const { return !data_->getArgument(0)->isNull(); }
IfcMaterial* IfcMaterialLayer::Material() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcMaterialLayer::setMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcMaterialLayer::LayerThickness() const { return *data_->getArgument(1); }
void IfcMaterialLayer::setLayerThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcMaterialLayer::hasIsVentilated() const { return !data_->getArgument(2)->isNull(); }
bool IfcMaterialLayer::IsVentilated() const { return *data_->getArgument(2); }
void IfcMaterialLayer::setIsVentilated(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcMaterialLayer::hasName() const { return !data_->getArgument(3)->isNull(); }
std::string IfcMaterialLayer::Name() const { return *data_->getArgument(3); }
void IfcMaterialLayer::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcMaterialLayer::hasDescription() const { return !data_->getArgument(4)->isNull(); }
std::string IfcMaterialLayer::Description() const { return *data_->getArgument(4); }
void IfcMaterialLayer::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcMaterialLayer::hasCategory() const { return !data_->getArgument(5)->isNull(); }
std::string IfcMaterialLayer::Category() const { return *data_->getArgument(5); }
void IfcMaterialLayer::setCategory(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcMaterialLayer::hasPriority() const { return !data_->getArgument(6)->isNull(); }
int IfcMaterialLayer::Priority() const { return *data_->getArgument(6); }
void IfcMaterialLayer::setPriority(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }

IfcMaterialLayerSet::list::ptr IfcMaterialLayer::ToMaterialLayerSet() const { return data_->getInverse(IfcMaterialLayerSet_type, 0)->as<IfcMaterialLayerSet>(); }

const IfcParse::entity& IfcMaterialLayer::declaration() const { return *IfcMaterialLayer_type; }
const IfcParse::entity& IfcMaterialLayer::Class() { return *IfcMaterialLayer_type; }
IfcMaterialLayer::IfcMaterialLayer(IfcEntityInstanceData* e) : IfcMaterialDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialLayer_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialLayer::IfcMaterialLayer(IfcMaterial* v1_Material, double v2_LayerThickness, boost::optional< bool > v3_IsVentilated, boost::optional< std::string > v4_Name, boost::optional< std::string > v5_Description, boost::optional< std::string > v6_Category, boost::optional< int > v7_Priority) : IfcMaterialDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialLayer_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LayerThickness));data_->setArgument(1,attr);} if (v3_IsVentilated) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_IsVentilated));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Name));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Description));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Category) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Category));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Priority));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcMaterialLayerSet
IfcTemplatedEntityList< IfcMaterialLayer >::ptr IfcMaterialLayerSet::MaterialLayers() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcMaterialLayer>(); }
void IfcMaterialLayerSet::setMaterialLayers(IfcTemplatedEntityList< IfcMaterialLayer >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }
bool IfcMaterialLayerSet::hasLayerSetName() const { return !data_->getArgument(1)->isNull(); }
std::string IfcMaterialLayerSet::LayerSetName() const { return *data_->getArgument(1); }
void IfcMaterialLayerSet::setLayerSetName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcMaterialLayerSet::hasDescription() const { return !data_->getArgument(2)->isNull(); }
std::string IfcMaterialLayerSet::Description() const { return *data_->getArgument(2); }
void IfcMaterialLayerSet::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcMaterialLayerSet::declaration() const { return *IfcMaterialLayerSet_type; }
const IfcParse::entity& IfcMaterialLayerSet::Class() { return *IfcMaterialLayerSet_type; }
IfcMaterialLayerSet::IfcMaterialLayerSet(IfcEntityInstanceData* e) : IfcMaterialDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialLayerSet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialLayerSet::IfcMaterialLayerSet(IfcTemplatedEntityList< IfcMaterialLayer >::ptr v1_MaterialLayers, boost::optional< std::string > v2_LayerSetName, boost::optional< std::string > v3_Description) : IfcMaterialDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialLayerSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MaterialLayers)->generalize());data_->setArgument(0,attr);} if (v2_LayerSetName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LayerSetName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcMaterialLayerSetUsage
IfcMaterialLayerSet* IfcMaterialLayerSetUsage::ForLayerSet() const { return (IfcMaterialLayerSet*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcMaterialLayerSetUsage::setForLayerSet(IfcMaterialLayerSet* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum IfcMaterialLayerSetUsage::LayerSetDirection() const { return IfcLayerSetDirectionEnum::FromString(*data_->getArgument(1)); }
void IfcMaterialLayerSetUsage::setLayerSetDirection(IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLayerSetDirectionEnum::ToString(v)));data_->setArgument(1,attr);} }
IfcDirectionSenseEnum::IfcDirectionSenseEnum IfcMaterialLayerSetUsage::DirectionSense() const { return IfcDirectionSenseEnum::FromString(*data_->getArgument(2)); }
void IfcMaterialLayerSetUsage::setDirectionSense(IfcDirectionSenseEnum::IfcDirectionSenseEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDirectionSenseEnum::ToString(v)));data_->setArgument(2,attr);} }
double IfcMaterialLayerSetUsage::OffsetFromReferenceLine() const { return *data_->getArgument(3); }
void IfcMaterialLayerSetUsage::setOffsetFromReferenceLine(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcMaterialLayerSetUsage::hasReferenceExtent() const { return !data_->getArgument(4)->isNull(); }
double IfcMaterialLayerSetUsage::ReferenceExtent() const { return *data_->getArgument(4); }
void IfcMaterialLayerSetUsage::setReferenceExtent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcMaterialLayerSetUsage::declaration() const { return *IfcMaterialLayerSetUsage_type; }
const IfcParse::entity& IfcMaterialLayerSetUsage::Class() { return *IfcMaterialLayerSetUsage_type; }
IfcMaterialLayerSetUsage::IfcMaterialLayerSetUsage(IfcEntityInstanceData* e) : IfcMaterialUsageDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialLayerSetUsage_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialLayerSetUsage::IfcMaterialLayerSetUsage(IfcMaterialLayerSet* v1_ForLayerSet, IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v2_LayerSetDirection, IfcDirectionSenseEnum::IfcDirectionSenseEnum v3_DirectionSense, double v4_OffsetFromReferenceLine, boost::optional< double > v5_ReferenceExtent) : IfcMaterialUsageDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialLayerSetUsage_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ForLayerSet));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_LayerSetDirection,IfcLayerSetDirectionEnum::ToString(v2_LayerSetDirection))));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_DirectionSense,IfcDirectionSenseEnum::ToString(v3_DirectionSense))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OffsetFromReferenceLine));data_->setArgument(3,attr);} if (v5_ReferenceExtent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ReferenceExtent));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcMaterialLayerWithOffsets
IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum IfcMaterialLayerWithOffsets::OffsetDirection() const { return IfcLayerSetDirectionEnum::FromString(*data_->getArgument(7)); }
void IfcMaterialLayerWithOffsets::setOffsetDirection(IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLayerSetDirectionEnum::ToString(v)));data_->setArgument(7,attr);} }
std::vector< double > /*[1:2]*/ IfcMaterialLayerWithOffsets::OffsetValues() const { return *data_->getArgument(8); }
void IfcMaterialLayerWithOffsets::setOffsetValues(std::vector< double > /*[1:2]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcMaterialLayerWithOffsets::declaration() const { return *IfcMaterialLayerWithOffsets_type; }
const IfcParse::entity& IfcMaterialLayerWithOffsets::Class() { return *IfcMaterialLayerWithOffsets_type; }
IfcMaterialLayerWithOffsets::IfcMaterialLayerWithOffsets(IfcEntityInstanceData* e) : IfcMaterialLayer((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialLayerWithOffsets_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialLayerWithOffsets::IfcMaterialLayerWithOffsets(IfcMaterial* v1_Material, double v2_LayerThickness, boost::optional< bool > v3_IsVentilated, boost::optional< std::string > v4_Name, boost::optional< std::string > v5_Description, boost::optional< std::string > v6_Category, boost::optional< int > v7_Priority, IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v8_OffsetDirection, std::vector< double > /*[1:2]*/ v9_OffsetValues) : IfcMaterialLayer((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialLayerWithOffsets_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LayerThickness));data_->setArgument(1,attr);} if (v3_IsVentilated) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_IsVentilated));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Name));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Description));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Category) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Category));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Priority));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_OffsetDirection,IfcLayerSetDirectionEnum::ToString(v8_OffsetDirection))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_OffsetValues));data_->setArgument(8,attr);} }

// Function implementations for IfcMaterialList
IfcTemplatedEntityList< IfcMaterial >::ptr IfcMaterialList::Materials() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcMaterial>(); }
void IfcMaterialList::setMaterials(IfcTemplatedEntityList< IfcMaterial >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& IfcMaterialList::declaration() const { return *IfcMaterialList_type; }
const IfcParse::entity& IfcMaterialList::Class() { return *IfcMaterialList_type; }
IfcMaterialList::IfcMaterialList(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcMaterialList_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialList::IfcMaterialList(IfcTemplatedEntityList< IfcMaterial >::ptr v1_Materials) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcMaterialList_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Materials)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcMaterialProfile
bool IfcMaterialProfile::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcMaterialProfile::Name() const { return *data_->getArgument(0); }
void IfcMaterialProfile::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcMaterialProfile::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcMaterialProfile::Description() const { return *data_->getArgument(1); }
void IfcMaterialProfile::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcMaterialProfile::hasMaterial() const { return !data_->getArgument(2)->isNull(); }
IfcMaterial* IfcMaterialProfile::Material() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcMaterialProfile::setMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcProfileDef* IfcMaterialProfile::Profile() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcMaterialProfile::setProfile(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcMaterialProfile::hasPriority() const { return !data_->getArgument(4)->isNull(); }
int IfcMaterialProfile::Priority() const { return *data_->getArgument(4); }
void IfcMaterialProfile::setPriority(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcMaterialProfile::hasCategory() const { return !data_->getArgument(5)->isNull(); }
std::string IfcMaterialProfile::Category() const { return *data_->getArgument(5); }
void IfcMaterialProfile::setCategory(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

IfcMaterialProfileSet::list::ptr IfcMaterialProfile::ToMaterialProfileSet() const { return data_->getInverse(IfcMaterialProfileSet_type, 2)->as<IfcMaterialProfileSet>(); }

const IfcParse::entity& IfcMaterialProfile::declaration() const { return *IfcMaterialProfile_type; }
const IfcParse::entity& IfcMaterialProfile::Class() { return *IfcMaterialProfile_type; }
IfcMaterialProfile::IfcMaterialProfile(IfcEntityInstanceData* e) : IfcMaterialDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialProfile_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialProfile::IfcMaterialProfile(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMaterial* v3_Material, IfcProfileDef* v4_Profile, boost::optional< int > v5_Priority, boost::optional< std::string > v6_Category) : IfcMaterialDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialProfile_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Material));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Profile));data_->setArgument(3,attr);} if (v5_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Priority));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Category) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Category));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcMaterialProfileSet
bool IfcMaterialProfileSet::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcMaterialProfileSet::Name() const { return *data_->getArgument(0); }
void IfcMaterialProfileSet::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcMaterialProfileSet::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcMaterialProfileSet::Description() const { return *data_->getArgument(1); }
void IfcMaterialProfileSet::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcTemplatedEntityList< IfcMaterialProfile >::ptr IfcMaterialProfileSet::MaterialProfiles() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcMaterialProfile>(); }
void IfcMaterialProfileSet::setMaterialProfiles(IfcTemplatedEntityList< IfcMaterialProfile >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }
bool IfcMaterialProfileSet::hasCompositeProfile() const { return !data_->getArgument(3)->isNull(); }
IfcCompositeProfileDef* IfcMaterialProfileSet::CompositeProfile() const { return (IfcCompositeProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcMaterialProfileSet::setCompositeProfile(IfcCompositeProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcMaterialProfileSet::declaration() const { return *IfcMaterialProfileSet_type; }
const IfcParse::entity& IfcMaterialProfileSet::Class() { return *IfcMaterialProfileSet_type; }
IfcMaterialProfileSet::IfcMaterialProfileSet(IfcEntityInstanceData* e) : IfcMaterialDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialProfileSet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialProfileSet::IfcMaterialProfileSet(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcMaterialProfile >::ptr v3_MaterialProfiles, IfcCompositeProfileDef* v4_CompositeProfile) : IfcMaterialDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialProfileSet_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_MaterialProfiles)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_CompositeProfile));data_->setArgument(3,attr);} }

// Function implementations for IfcMaterialProfileSetUsage
IfcMaterialProfileSet* IfcMaterialProfileSetUsage::ForProfileSet() const { return (IfcMaterialProfileSet*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcMaterialProfileSetUsage::setForProfileSet(IfcMaterialProfileSet* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcMaterialProfileSetUsage::hasCardinalPoint() const { return !data_->getArgument(1)->isNull(); }
int IfcMaterialProfileSetUsage::CardinalPoint() const { return *data_->getArgument(1); }
void IfcMaterialProfileSetUsage::setCardinalPoint(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcMaterialProfileSetUsage::hasReferenceExtent() const { return !data_->getArgument(2)->isNull(); }
double IfcMaterialProfileSetUsage::ReferenceExtent() const { return *data_->getArgument(2); }
void IfcMaterialProfileSetUsage::setReferenceExtent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcMaterialProfileSetUsage::declaration() const { return *IfcMaterialProfileSetUsage_type; }
const IfcParse::entity& IfcMaterialProfileSetUsage::Class() { return *IfcMaterialProfileSetUsage_type; }
IfcMaterialProfileSetUsage::IfcMaterialProfileSetUsage(IfcEntityInstanceData* e) : IfcMaterialUsageDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialProfileSetUsage_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialProfileSetUsage::IfcMaterialProfileSetUsage(IfcMaterialProfileSet* v1_ForProfileSet, boost::optional< int > v2_CardinalPoint, boost::optional< double > v3_ReferenceExtent) : IfcMaterialUsageDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialProfileSetUsage_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ForProfileSet));data_->setArgument(0,attr);} if (v2_CardinalPoint) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_CardinalPoint));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_ReferenceExtent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ReferenceExtent));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcMaterialProfileSetUsageTapering
IfcMaterialProfileSet* IfcMaterialProfileSetUsageTapering::ForProfileEndSet() const { return (IfcMaterialProfileSet*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcMaterialProfileSetUsageTapering::setForProfileEndSet(IfcMaterialProfileSet* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcMaterialProfileSetUsageTapering::hasCardinalEndPoint() const { return !data_->getArgument(4)->isNull(); }
int IfcMaterialProfileSetUsageTapering::CardinalEndPoint() const { return *data_->getArgument(4); }
void IfcMaterialProfileSetUsageTapering::setCardinalEndPoint(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcMaterialProfileSetUsageTapering::declaration() const { return *IfcMaterialProfileSetUsageTapering_type; }
const IfcParse::entity& IfcMaterialProfileSetUsageTapering::Class() { return *IfcMaterialProfileSetUsageTapering_type; }
IfcMaterialProfileSetUsageTapering::IfcMaterialProfileSetUsageTapering(IfcEntityInstanceData* e) : IfcMaterialProfileSetUsage((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialProfileSetUsageTapering_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialProfileSetUsageTapering::IfcMaterialProfileSetUsageTapering(IfcMaterialProfileSet* v1_ForProfileSet, boost::optional< int > v2_CardinalPoint, boost::optional< double > v3_ReferenceExtent, IfcMaterialProfileSet* v4_ForProfileEndSet, boost::optional< int > v5_CardinalEndPoint) : IfcMaterialProfileSetUsage((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialProfileSetUsageTapering_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ForProfileSet));data_->setArgument(0,attr);} if (v2_CardinalPoint) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_CardinalPoint));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_ReferenceExtent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ReferenceExtent));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ForProfileEndSet));data_->setArgument(3,attr);} if (v5_CardinalEndPoint) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_CardinalEndPoint));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcMaterialProfileWithOffsets
std::vector< double > /*[1:2]*/ IfcMaterialProfileWithOffsets::OffsetValues() const { return *data_->getArgument(6); }
void IfcMaterialProfileWithOffsets::setOffsetValues(std::vector< double > /*[1:2]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcMaterialProfileWithOffsets::declaration() const { return *IfcMaterialProfileWithOffsets_type; }
const IfcParse::entity& IfcMaterialProfileWithOffsets::Class() { return *IfcMaterialProfileWithOffsets_type; }
IfcMaterialProfileWithOffsets::IfcMaterialProfileWithOffsets(IfcEntityInstanceData* e) : IfcMaterialProfile((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialProfileWithOffsets_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialProfileWithOffsets::IfcMaterialProfileWithOffsets(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMaterial* v3_Material, IfcProfileDef* v4_Profile, boost::optional< int > v5_Priority, boost::optional< std::string > v6_Category, std::vector< double > /*[1:2]*/ v7_OffsetValues) : IfcMaterialProfile((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialProfileWithOffsets_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Material));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Profile));data_->setArgument(3,attr);} if (v5_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Priority));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Category) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Category));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_OffsetValues));data_->setArgument(6,attr);} }

// Function implementations for IfcMaterialProperties
IfcMaterialDefinition* IfcMaterialProperties::Material() const { return (IfcMaterialDefinition*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcMaterialProperties::setMaterial(IfcMaterialDefinition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcMaterialProperties::declaration() const { return *IfcMaterialProperties_type; }
const IfcParse::entity& IfcMaterialProperties::Class() { return *IfcMaterialProperties_type; }
IfcMaterialProperties::IfcMaterialProperties(IfcEntityInstanceData* e) : IfcExtendedProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialProperties::IfcMaterialProperties(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcProperty >::ptr v3_Properties, IfcMaterialDefinition* v4_Material) : IfcExtendedProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialProperties_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Properties)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Material));data_->setArgument(3,attr);} }

// Function implementations for IfcMaterialRelationship
IfcMaterial* IfcMaterialRelationship::RelatingMaterial() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcMaterialRelationship::setRelatingMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcMaterial >::ptr IfcMaterialRelationship::RelatedMaterials() const { IfcEntityList::ptr es = *data_->getArgument(3); return es->as<IfcMaterial>(); }
void IfcMaterialRelationship::setRelatedMaterials(IfcTemplatedEntityList< IfcMaterial >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(3,attr);} }
bool IfcMaterialRelationship::hasExpression() const { return !data_->getArgument(4)->isNull(); }
std::string IfcMaterialRelationship::Expression() const { return *data_->getArgument(4); }
void IfcMaterialRelationship::setExpression(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcMaterialRelationship::declaration() const { return *IfcMaterialRelationship_type; }
const IfcParse::entity& IfcMaterialRelationship::Class() { return *IfcMaterialRelationship_type; }
IfcMaterialRelationship::IfcMaterialRelationship(IfcEntityInstanceData* e) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMaterialRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialRelationship::IfcMaterialRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMaterial* v3_RelatingMaterial, IfcTemplatedEntityList< IfcMaterial >::ptr v4_RelatedMaterials, boost::optional< std::string > v5_Expression) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMaterialRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingMaterial));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedMaterials)->generalize());data_->setArgument(3,attr);} if (v5_Expression) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Expression));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcMaterialUsageDefinition

IfcRelAssociatesMaterial::list::ptr IfcMaterialUsageDefinition::AssociatedTo() const { return data_->getInverse(IfcRelAssociatesMaterial_type, 5)->as<IfcRelAssociatesMaterial>(); }

const IfcParse::entity& IfcMaterialUsageDefinition::declaration() const { return *IfcMaterialUsageDefinition_type; }
const IfcParse::entity& IfcMaterialUsageDefinition::Class() { return *IfcMaterialUsageDefinition_type; }
IfcMaterialUsageDefinition::IfcMaterialUsageDefinition(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcMaterialUsageDefinition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMaterialUsageDefinition::IfcMaterialUsageDefinition() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcMaterialUsageDefinition_type);  }

// Function implementations for IfcMeasureWithUnit
IfcValue* IfcMeasureWithUnit::ValueComponent() const { return (IfcValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcMeasureWithUnit::setValueComponent(IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcUnit* IfcMeasureWithUnit::UnitComponent() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcMeasureWithUnit::setUnitComponent(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcMeasureWithUnit::declaration() const { return *IfcMeasureWithUnit_type; }
const IfcParse::entity& IfcMeasureWithUnit::Class() { return *IfcMeasureWithUnit_type; }
IfcMeasureWithUnit::IfcMeasureWithUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcMeasureWithUnit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMeasureWithUnit::IfcMeasureWithUnit(IfcValue* v1_ValueComponent, IfcUnit* v2_UnitComponent) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcMeasureWithUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ValueComponent));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_UnitComponent));data_->setArgument(1,attr);} }

// Function implementations for IfcMechanicalFastener
bool IfcMechanicalFastener::hasNominalDiameter() const { return !data_->getArgument(8)->isNull(); }
double IfcMechanicalFastener::NominalDiameter() const { return *data_->getArgument(8); }
void IfcMechanicalFastener::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcMechanicalFastener::hasNominalLength() const { return !data_->getArgument(9)->isNull(); }
double IfcMechanicalFastener::NominalLength() const { return *data_->getArgument(9); }
void IfcMechanicalFastener::setNominalLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcMechanicalFastener::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum IfcMechanicalFastener::PredefinedType() const { return IfcMechanicalFastenerTypeEnum::FromString(*data_->getArgument(10)); }
void IfcMechanicalFastener::setPredefinedType(IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMechanicalFastenerTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& IfcMechanicalFastener::declaration() const { return *IfcMechanicalFastener_type; }
const IfcParse::entity& IfcMechanicalFastener::Class() { return *IfcMechanicalFastener_type; }
IfcMechanicalFastener::IfcMechanicalFastener(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMechanicalFastener_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMechanicalFastener::IfcMechanicalFastener(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_NominalDiameter, boost::optional< double > v10_NominalLength, boost::optional< IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum > v11_PredefinedType) : IfcElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMechanicalFastener_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_NominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_NominalDiameter));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_NominalLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_NominalLength));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcMechanicalFastenerTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcMechanicalFastenerType
IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum IfcMechanicalFastenerType::PredefinedType() const { return IfcMechanicalFastenerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcMechanicalFastenerType::setPredefinedType(IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMechanicalFastenerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcMechanicalFastenerType::hasNominalDiameter() const { return !data_->getArgument(10)->isNull(); }
double IfcMechanicalFastenerType::NominalDiameter() const { return *data_->getArgument(10); }
void IfcMechanicalFastenerType::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcMechanicalFastenerType::hasNominalLength() const { return !data_->getArgument(11)->isNull(); }
double IfcMechanicalFastenerType::NominalLength() const { return *data_->getArgument(11); }
void IfcMechanicalFastenerType::setNominalLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }


const IfcParse::entity& IfcMechanicalFastenerType::declaration() const { return *IfcMechanicalFastenerType_type; }
const IfcParse::entity& IfcMechanicalFastenerType::Class() { return *IfcMechanicalFastenerType_type; }
IfcMechanicalFastenerType::IfcMechanicalFastenerType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMechanicalFastenerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMechanicalFastenerType::IfcMechanicalFastenerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum v10_PredefinedType, boost::optional< double > v11_NominalDiameter, boost::optional< double > v12_NominalLength) : IfcElementComponentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMechanicalFastenerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcMechanicalFastenerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} if (v11_NominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_NominalDiameter));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_NominalLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_NominalLength));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } }

// Function implementations for IfcMedicalDevice
bool IfcMedicalDevice::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum IfcMedicalDevice::PredefinedType() const { return IfcMedicalDeviceTypeEnum::FromString(*data_->getArgument(8)); }
void IfcMedicalDevice::setPredefinedType(IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMedicalDeviceTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcMedicalDevice::declaration() const { return *IfcMedicalDevice_type; }
const IfcParse::entity& IfcMedicalDevice::Class() { return *IfcMedicalDevice_type; }
IfcMedicalDevice::IfcMedicalDevice(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMedicalDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMedicalDevice::IfcMedicalDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMedicalDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcMedicalDeviceTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcMedicalDeviceType
IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum IfcMedicalDeviceType::PredefinedType() const { return IfcMedicalDeviceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcMedicalDeviceType::setPredefinedType(IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMedicalDeviceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcMedicalDeviceType::declaration() const { return *IfcMedicalDeviceType_type; }
const IfcParse::entity& IfcMedicalDeviceType::Class() { return *IfcMedicalDeviceType_type; }
IfcMedicalDeviceType::IfcMedicalDeviceType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMedicalDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMedicalDeviceType::IfcMedicalDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMedicalDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcMedicalDeviceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcMember
bool IfcMember::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcMemberTypeEnum::IfcMemberTypeEnum IfcMember::PredefinedType() const { return IfcMemberTypeEnum::FromString(*data_->getArgument(8)); }
void IfcMember::setPredefinedType(IfcMemberTypeEnum::IfcMemberTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMemberTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcMember::declaration() const { return *IfcMember_type; }
const IfcParse::entity& IfcMember::Class() { return *IfcMember_type; }
IfcMember::IfcMember(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMember_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMember::IfcMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcMemberTypeEnum::IfcMemberTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcMemberTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcMemberStandardCase


const IfcParse::entity& IfcMemberStandardCase::declaration() const { return *IfcMemberStandardCase_type; }
const IfcParse::entity& IfcMemberStandardCase::Class() { return *IfcMemberStandardCase_type; }
IfcMemberStandardCase::IfcMemberStandardCase(IfcEntityInstanceData* e) : IfcMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMemberStandardCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMemberStandardCase::IfcMemberStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcMemberTypeEnum::IfcMemberTypeEnum > v9_PredefinedType) : IfcMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMemberStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcMemberTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcMemberType
IfcMemberTypeEnum::IfcMemberTypeEnum IfcMemberType::PredefinedType() const { return IfcMemberTypeEnum::FromString(*data_->getArgument(9)); }
void IfcMemberType::setPredefinedType(IfcMemberTypeEnum::IfcMemberTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMemberTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcMemberType::declaration() const { return *IfcMemberType_type; }
const IfcParse::entity& IfcMemberType::Class() { return *IfcMemberType_type; }
IfcMemberType::IfcMemberType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMemberType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMemberType::IfcMemberType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMemberTypeEnum::IfcMemberTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMemberType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcMemberTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcMetric
IfcBenchmarkEnum::IfcBenchmarkEnum IfcMetric::Benchmark() const { return IfcBenchmarkEnum::FromString(*data_->getArgument(7)); }
void IfcMetric::setBenchmark(IfcBenchmarkEnum::IfcBenchmarkEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBenchmarkEnum::ToString(v)));data_->setArgument(7,attr);} }
bool IfcMetric::hasValueSource() const { return !data_->getArgument(8)->isNull(); }
std::string IfcMetric::ValueSource() const { return *data_->getArgument(8); }
void IfcMetric::setValueSource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcMetric::hasDataValue() const { return !data_->getArgument(9)->isNull(); }
IfcMetricValueSelect* IfcMetric::DataValue() const { return (IfcMetricValueSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcMetric::setDataValue(IfcMetricValueSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcMetric::hasReferencePath() const { return !data_->getArgument(10)->isNull(); }
IfcReference* IfcMetric::ReferencePath() const { return (IfcReference*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(10))); }
void IfcMetric::setReferencePath(IfcReference* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcMetric::declaration() const { return *IfcMetric_type; }
const IfcParse::entity& IfcMetric::Class() { return *IfcMetric_type; }
IfcMetric::IfcMetric(IfcEntityInstanceData* e) : IfcConstraint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMetric_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMetric::IfcMetric(std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, boost::optional< std::string > v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, IfcBenchmarkEnum::IfcBenchmarkEnum v8_Benchmark, boost::optional< std::string > v9_ValueSource, IfcMetricValueSelect* v10_DataValue, IfcReference* v11_ReferencePath) : IfcConstraint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMetric_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ConstraintGrade,IfcConstraintEnum::ToString(v3_ConstraintGrade))));data_->setArgument(2,attr);} if (v4_ConstraintSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ConstraintSource));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CreatingActor));data_->setArgument(4,attr);} if (v6_CreationTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_CreationTime));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_UserDefinedGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedGrade));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_Benchmark,IfcBenchmarkEnum::ToString(v8_Benchmark))));data_->setArgument(7,attr);} if (v9_ValueSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ValueSource));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DataValue));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ReferencePath));data_->setArgument(10,attr);} }

// Function implementations for IfcMirroredProfileDef


const IfcParse::entity& IfcMirroredProfileDef::declaration() const { return *IfcMirroredProfileDef_type; }
const IfcParse::entity& IfcMirroredProfileDef::Class() { return *IfcMirroredProfileDef_type; }
IfcMirroredProfileDef::IfcMirroredProfileDef(IfcEntityInstanceData* e) : IfcDerivedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMirroredProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMirroredProfileDef::IfcMirroredProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcProfileDef* v3_ParentProfile, boost::optional< std::string > v5_Label) : IfcDerivedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMirroredProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentProfile));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(3,attr);} if (v5_Label) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Label));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcMonetaryUnit
std::string IfcMonetaryUnit::Currency() const { return *data_->getArgument(0); }
void IfcMonetaryUnit::setCurrency(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcMonetaryUnit::declaration() const { return *IfcMonetaryUnit_type; }
const IfcParse::entity& IfcMonetaryUnit::Class() { return *IfcMonetaryUnit_type; }
IfcMonetaryUnit::IfcMonetaryUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcMonetaryUnit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMonetaryUnit::IfcMonetaryUnit(std::string v1_Currency) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcMonetaryUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Currency));data_->setArgument(0,attr);} }

// Function implementations for IfcMotorConnection
bool IfcMotorConnection::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum IfcMotorConnection::PredefinedType() const { return IfcMotorConnectionTypeEnum::FromString(*data_->getArgument(8)); }
void IfcMotorConnection::setPredefinedType(IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMotorConnectionTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcMotorConnection::declaration() const { return *IfcMotorConnection_type; }
const IfcParse::entity& IfcMotorConnection::Class() { return *IfcMotorConnection_type; }
IfcMotorConnection::IfcMotorConnection(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMotorConnection_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMotorConnection::IfcMotorConnection(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMotorConnection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcMotorConnectionTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcMotorConnectionType
IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum IfcMotorConnectionType::PredefinedType() const { return IfcMotorConnectionTypeEnum::FromString(*data_->getArgument(9)); }
void IfcMotorConnectionType::setPredefinedType(IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMotorConnectionTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcMotorConnectionType::declaration() const { return *IfcMotorConnectionType_type; }
const IfcParse::entity& IfcMotorConnectionType::Class() { return *IfcMotorConnectionType_type; }
IfcMotorConnectionType::IfcMotorConnectionType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcMotorConnectionType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcMotorConnectionType::IfcMotorConnectionType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcMotorConnectionType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcMotorConnectionTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcNamedUnit
IfcDimensionalExponents* IfcNamedUnit::Dimensions() const { return (IfcDimensionalExponents*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcNamedUnit::setDimensions(IfcDimensionalExponents* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcUnitEnum::IfcUnitEnum IfcNamedUnit::UnitType() const { return IfcUnitEnum::FromString(*data_->getArgument(1)); }
void IfcNamedUnit::setUnitType(IfcUnitEnum::IfcUnitEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcUnitEnum::ToString(v)));data_->setArgument(1,attr);} }


const IfcParse::entity& IfcNamedUnit::declaration() const { return *IfcNamedUnit_type; }
const IfcParse::entity& IfcNamedUnit::Class() { return *IfcNamedUnit_type; }
IfcNamedUnit::IfcNamedUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcNamedUnit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcNamedUnit::IfcNamedUnit(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcNamedUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);} }

// Function implementations for IfcObject
bool IfcObject::hasObjectType() const { return !data_->getArgument(4)->isNull(); }
std::string IfcObject::ObjectType() const { return *data_->getArgument(4); }
void IfcObject::setObjectType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }

IfcRelDefinesByObject::list::ptr IfcObject::IsDeclaredBy() const { return data_->getInverse(IfcRelDefinesByObject_type, 4)->as<IfcRelDefinesByObject>(); }
IfcRelDefinesByObject::list::ptr IfcObject::Declares() const { return data_->getInverse(IfcRelDefinesByObject_type, 5)->as<IfcRelDefinesByObject>(); }
IfcRelDefinesByType::list::ptr IfcObject::IsTypedBy() const { return data_->getInverse(IfcRelDefinesByType_type, 4)->as<IfcRelDefinesByType>(); }
IfcRelDefinesByProperties::list::ptr IfcObject::IsDefinedBy() const { return data_->getInverse(IfcRelDefinesByProperties_type, 4)->as<IfcRelDefinesByProperties>(); }

const IfcParse::entity& IfcObject::declaration() const { return *IfcObject_type; }
const IfcParse::entity& IfcObject::Class() { return *IfcObject_type; }
IfcObject::IfcObject(IfcEntityInstanceData* e) : IfcObjectDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcObject_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcObject::IfcObject(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObjectDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcObject_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcObjectDefinition

IfcRelAssigns::list::ptr IfcObjectDefinition::HasAssignments() const { return data_->getInverse(IfcRelAssigns_type, 4)->as<IfcRelAssigns>(); }
IfcRelNests::list::ptr IfcObjectDefinition::Nests() const { return data_->getInverse(IfcRelNests_type, 5)->as<IfcRelNests>(); }
IfcRelNests::list::ptr IfcObjectDefinition::IsNestedBy() const { return data_->getInverse(IfcRelNests_type, 4)->as<IfcRelNests>(); }
IfcRelDeclares::list::ptr IfcObjectDefinition::HasContext() const { return data_->getInverse(IfcRelDeclares_type, 5)->as<IfcRelDeclares>(); }
IfcRelAggregates::list::ptr IfcObjectDefinition::IsDecomposedBy() const { return data_->getInverse(IfcRelAggregates_type, 4)->as<IfcRelAggregates>(); }
IfcRelAggregates::list::ptr IfcObjectDefinition::Decomposes() const { return data_->getInverse(IfcRelAggregates_type, 5)->as<IfcRelAggregates>(); }
IfcRelAssociates::list::ptr IfcObjectDefinition::HasAssociations() const { return data_->getInverse(IfcRelAssociates_type, 4)->as<IfcRelAssociates>(); }

const IfcParse::entity& IfcObjectDefinition::declaration() const { return *IfcObjectDefinition_type; }
const IfcParse::entity& IfcObjectDefinition::Class() { return *IfcObjectDefinition_type; }
IfcObjectDefinition::IfcObjectDefinition(IfcEntityInstanceData* e) : IfcRoot((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcObjectDefinition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcObjectDefinition::IfcObjectDefinition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRoot((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcObjectDefinition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcObjectPlacement

IfcProduct::list::ptr IfcObjectPlacement::PlacesObject() const { return data_->getInverse(IfcProduct_type, 5)->as<IfcProduct>(); }
IfcLocalPlacement::list::ptr IfcObjectPlacement::ReferencedByPlacements() const { return data_->getInverse(IfcLocalPlacement_type, 0)->as<IfcLocalPlacement>(); }

const IfcParse::entity& IfcObjectPlacement::declaration() const { return *IfcObjectPlacement_type; }
const IfcParse::entity& IfcObjectPlacement::Class() { return *IfcObjectPlacement_type; }
IfcObjectPlacement::IfcObjectPlacement(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcObjectPlacement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcObjectPlacement::IfcObjectPlacement() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcObjectPlacement_type);  }

// Function implementations for IfcObjective
bool IfcObjective::hasBenchmarkValues() const { return !data_->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcConstraint >::ptr IfcObjective::BenchmarkValues() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcConstraint>(); }
void IfcObjective::setBenchmarkValues(IfcTemplatedEntityList< IfcConstraint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }
bool IfcObjective::hasLogicalAggregator() const { return !data_->getArgument(8)->isNull(); }
IfcLogicalOperatorEnum::IfcLogicalOperatorEnum IfcObjective::LogicalAggregator() const { return IfcLogicalOperatorEnum::FromString(*data_->getArgument(8)); }
void IfcObjective::setLogicalAggregator(IfcLogicalOperatorEnum::IfcLogicalOperatorEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLogicalOperatorEnum::ToString(v)));data_->setArgument(8,attr);} }
IfcObjectiveEnum::IfcObjectiveEnum IfcObjective::ObjectiveQualifier() const { return IfcObjectiveEnum::FromString(*data_->getArgument(9)); }
void IfcObjective::setObjectiveQualifier(IfcObjectiveEnum::IfcObjectiveEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcObjectiveEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcObjective::hasUserDefinedQualifier() const { return !data_->getArgument(10)->isNull(); }
std::string IfcObjective::UserDefinedQualifier() const { return *data_->getArgument(10); }
void IfcObjective::setUserDefinedQualifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcObjective::declaration() const { return *IfcObjective_type; }
const IfcParse::entity& IfcObjective::Class() { return *IfcObjective_type; }
IfcObjective::IfcObjective(IfcEntityInstanceData* e) : IfcConstraint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcObjective_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcObjective::IfcObjective(std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, boost::optional< std::string > v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, boost::optional< IfcTemplatedEntityList< IfcConstraint >::ptr > v8_BenchmarkValues, boost::optional< IfcLogicalOperatorEnum::IfcLogicalOperatorEnum > v9_LogicalAggregator, IfcObjectiveEnum::IfcObjectiveEnum v10_ObjectiveQualifier, boost::optional< std::string > v11_UserDefinedQualifier) : IfcConstraint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcObjective_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ConstraintGrade,IfcConstraintEnum::ToString(v3_ConstraintGrade))));data_->setArgument(2,attr);} if (v4_ConstraintSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ConstraintSource));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CreatingActor));data_->setArgument(4,attr);} if (v6_CreationTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_CreationTime));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_UserDefinedGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedGrade));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_BenchmarkValues) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_BenchmarkValues)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_LogicalAggregator) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_LogicalAggregator,IfcLogicalOperatorEnum::ToString(*v9_LogicalAggregator))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_ObjectiveQualifier,IfcObjectiveEnum::ToString(v10_ObjectiveQualifier))));data_->setArgument(9,attr);} if (v11_UserDefinedQualifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_UserDefinedQualifier));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcOccupant
bool IfcOccupant::hasPredefinedType() const { return !data_->getArgument(6)->isNull(); }
IfcOccupantTypeEnum::IfcOccupantTypeEnum IfcOccupant::PredefinedType() const { return IfcOccupantTypeEnum::FromString(*data_->getArgument(6)); }
void IfcOccupant::setPredefinedType(IfcOccupantTypeEnum::IfcOccupantTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcOccupantTypeEnum::ToString(v)));data_->setArgument(6,attr);} }


const IfcParse::entity& IfcOccupant::declaration() const { return *IfcOccupant_type; }
const IfcParse::entity& IfcOccupant::Class() { return *IfcOccupant_type; }
IfcOccupant::IfcOccupant(IfcEntityInstanceData* e) : IfcActor((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOccupant_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOccupant::IfcOccupant(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_TheActor, boost::optional< IfcOccupantTypeEnum::IfcOccupantTypeEnum > v7_PredefinedType) : IfcActor((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOccupant_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TheActor));data_->setArgument(5,attr);} if (v7_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_PredefinedType,IfcOccupantTypeEnum::ToString(*v7_PredefinedType))));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcOffsetCurve2D
IfcCurve* IfcOffsetCurve2D::BasisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcOffsetCurve2D::setBasisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcOffsetCurve2D::Distance() const { return *data_->getArgument(1); }
void IfcOffsetCurve2D::setDistance(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcOffsetCurve2D::SelfIntersect() const { return *data_->getArgument(2); }
void IfcOffsetCurve2D::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcOffsetCurve2D::declaration() const { return *IfcOffsetCurve2D_type; }
const IfcParse::entity& IfcOffsetCurve2D::Class() { return *IfcOffsetCurve2D_type; }
IfcOffsetCurve2D::IfcOffsetCurve2D(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOffsetCurve2D_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOffsetCurve2D::IfcOffsetCurve2D(IfcCurve* v1_BasisCurve, double v2_Distance, bool v3_SelfIntersect) : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOffsetCurve2D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Distance));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SelfIntersect));data_->setArgument(2,attr);} }

// Function implementations for IfcOffsetCurve3D
IfcCurve* IfcOffsetCurve3D::BasisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcOffsetCurve3D::setBasisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcOffsetCurve3D::Distance() const { return *data_->getArgument(1); }
void IfcOffsetCurve3D::setDistance(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcOffsetCurve3D::SelfIntersect() const { return *data_->getArgument(2); }
void IfcOffsetCurve3D::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcDirection* IfcOffsetCurve3D::RefDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcOffsetCurve3D::setRefDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcOffsetCurve3D::declaration() const { return *IfcOffsetCurve3D_type; }
const IfcParse::entity& IfcOffsetCurve3D::Class() { return *IfcOffsetCurve3D_type; }
IfcOffsetCurve3D::IfcOffsetCurve3D(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOffsetCurve3D_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOffsetCurve3D::IfcOffsetCurve3D(IfcCurve* v1_BasisCurve, double v2_Distance, bool v3_SelfIntersect, IfcDirection* v4_RefDirection) : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOffsetCurve3D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Distance));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SelfIntersect));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RefDirection));data_->setArgument(3,attr);} }

// Function implementations for IfcOpenShell


const IfcParse::entity& IfcOpenShell::declaration() const { return *IfcOpenShell_type; }
const IfcParse::entity& IfcOpenShell::Class() { return *IfcOpenShell_type; }
IfcOpenShell::IfcOpenShell(IfcEntityInstanceData* e) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOpenShell_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOpenShell::IfcOpenShell(IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOpenShell_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CfsFaces)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcOpeningElement
bool IfcOpeningElement::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum IfcOpeningElement::PredefinedType() const { return IfcOpeningElementTypeEnum::FromString(*data_->getArgument(8)); }
void IfcOpeningElement::setPredefinedType(IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcOpeningElementTypeEnum::ToString(v)));data_->setArgument(8,attr);} }

IfcRelFillsElement::list::ptr IfcOpeningElement::HasFillings() const { return data_->getInverse(IfcRelFillsElement_type, 4)->as<IfcRelFillsElement>(); }

const IfcParse::entity& IfcOpeningElement::declaration() const { return *IfcOpeningElement_type; }
const IfcParse::entity& IfcOpeningElement::Class() { return *IfcOpeningElement_type; }
IfcOpeningElement::IfcOpeningElement(IfcEntityInstanceData* e) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOpeningElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOpeningElement::IfcOpeningElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum > v9_PredefinedType) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOpeningElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcOpeningElementTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcOpeningStandardCase


const IfcParse::entity& IfcOpeningStandardCase::declaration() const { return *IfcOpeningStandardCase_type; }
const IfcParse::entity& IfcOpeningStandardCase::Class() { return *IfcOpeningStandardCase_type; }
IfcOpeningStandardCase::IfcOpeningStandardCase(IfcEntityInstanceData* e) : IfcOpeningElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOpeningStandardCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOpeningStandardCase::IfcOpeningStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum > v9_PredefinedType) : IfcOpeningElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOpeningStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcOpeningElementTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcOrganization
bool IfcOrganization::hasIdentification() const { return !data_->getArgument(0)->isNull(); }
std::string IfcOrganization::Identification() const { return *data_->getArgument(0); }
void IfcOrganization::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::string IfcOrganization::Name() const { return *data_->getArgument(1); }
void IfcOrganization::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcOrganization::hasDescription() const { return !data_->getArgument(2)->isNull(); }
std::string IfcOrganization::Description() const { return *data_->getArgument(2); }
void IfcOrganization::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcOrganization::hasRoles() const { return !data_->getArgument(3)->isNull(); }
IfcTemplatedEntityList< IfcActorRole >::ptr IfcOrganization::Roles() const { IfcEntityList::ptr es = *data_->getArgument(3); return es->as<IfcActorRole>(); }
void IfcOrganization::setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(3,attr);} }
bool IfcOrganization::hasAddresses() const { return !data_->getArgument(4)->isNull(); }
IfcTemplatedEntityList< IfcAddress >::ptr IfcOrganization::Addresses() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcAddress>(); }
void IfcOrganization::setAddresses(IfcTemplatedEntityList< IfcAddress >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }

IfcOrganizationRelationship::list::ptr IfcOrganization::IsRelatedBy() const { return data_->getInverse(IfcOrganizationRelationship_type, 3)->as<IfcOrganizationRelationship>(); }
IfcOrganizationRelationship::list::ptr IfcOrganization::Relates() const { return data_->getInverse(IfcOrganizationRelationship_type, 2)->as<IfcOrganizationRelationship>(); }
IfcPersonAndOrganization::list::ptr IfcOrganization::Engages() const { return data_->getInverse(IfcPersonAndOrganization_type, 1)->as<IfcPersonAndOrganization>(); }

const IfcParse::entity& IfcOrganization::declaration() const { return *IfcOrganization_type; }
const IfcParse::entity& IfcOrganization::Class() { return *IfcOrganization_type; }
IfcOrganization::IfcOrganization(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcOrganization_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOrganization::IfcOrganization(boost::optional< std::string > v1_Identification, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v4_Roles, boost::optional< IfcTemplatedEntityList< IfcAddress >::ptr > v5_Addresses) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcOrganization_type);  if (v1_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Identification));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Name));data_->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Roles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Roles)->generalize());data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Addresses) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Addresses)->generalize());data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcOrganizationRelationship
IfcOrganization* IfcOrganizationRelationship::RelatingOrganization() const { return (IfcOrganization*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcOrganizationRelationship::setRelatingOrganization(IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcOrganization >::ptr IfcOrganizationRelationship::RelatedOrganizations() const { IfcEntityList::ptr es = *data_->getArgument(3); return es->as<IfcOrganization>(); }
void IfcOrganizationRelationship::setRelatedOrganizations(IfcTemplatedEntityList< IfcOrganization >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(3,attr);} }


const IfcParse::entity& IfcOrganizationRelationship::declaration() const { return *IfcOrganizationRelationship_type; }
const IfcParse::entity& IfcOrganizationRelationship::Class() { return *IfcOrganizationRelationship_type; }
IfcOrganizationRelationship::IfcOrganizationRelationship(IfcEntityInstanceData* e) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOrganizationRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOrganizationRelationship::IfcOrganizationRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcOrganization* v3_RelatingOrganization, IfcTemplatedEntityList< IfcOrganization >::ptr v4_RelatedOrganizations) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOrganizationRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingOrganization));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedOrganizations)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcOrientedEdge
IfcEdge* IfcOrientedEdge::EdgeElement() const { return (IfcEdge*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcOrientedEdge::setEdgeElement(IfcEdge* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcOrientedEdge::Orientation() const { return *data_->getArgument(3); }
void IfcOrientedEdge::setOrientation(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcOrientedEdge::declaration() const { return *IfcOrientedEdge_type; }
const IfcParse::entity& IfcOrientedEdge::Class() { return *IfcOrientedEdge_type; }
IfcOrientedEdge::IfcOrientedEdge(IfcEntityInstanceData* e) : IfcEdge((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOrientedEdge_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOrientedEdge::IfcOrientedEdge(IfcEdge* v3_EdgeElement, bool v4_Orientation) : IfcEdge((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOrientedEdge_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EdgeElement));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Orientation));data_->setArgument(3,attr);} }

// Function implementations for IfcOuterBoundaryCurve


const IfcParse::entity& IfcOuterBoundaryCurve::declaration() const { return *IfcOuterBoundaryCurve_type; }
const IfcParse::entity& IfcOuterBoundaryCurve::Class() { return *IfcOuterBoundaryCurve_type; }
IfcOuterBoundaryCurve::IfcOuterBoundaryCurve(IfcEntityInstanceData* e) : IfcBoundaryCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOuterBoundaryCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOuterBoundaryCurve::IfcOuterBoundaryCurve(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect) : IfcBoundaryCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOuterBoundaryCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Segments)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SelfIntersect));data_->setArgument(1,attr);} }

// Function implementations for IfcOutlet
bool IfcOutlet::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcOutletTypeEnum::IfcOutletTypeEnum IfcOutlet::PredefinedType() const { return IfcOutletTypeEnum::FromString(*data_->getArgument(8)); }
void IfcOutlet::setPredefinedType(IfcOutletTypeEnum::IfcOutletTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcOutletTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcOutlet::declaration() const { return *IfcOutlet_type; }
const IfcParse::entity& IfcOutlet::Class() { return *IfcOutlet_type; }
IfcOutlet::IfcOutlet(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOutlet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOutlet::IfcOutlet(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcOutletTypeEnum::IfcOutletTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOutlet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcOutletTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcOutletType
IfcOutletTypeEnum::IfcOutletTypeEnum IfcOutletType::PredefinedType() const { return IfcOutletTypeEnum::FromString(*data_->getArgument(9)); }
void IfcOutletType::setPredefinedType(IfcOutletTypeEnum::IfcOutletTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcOutletTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcOutletType::declaration() const { return *IfcOutletType_type; }
const IfcParse::entity& IfcOutletType::Class() { return *IfcOutletType_type; }
IfcOutletType::IfcOutletType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcOutletType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOutletType::IfcOutletType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcOutletTypeEnum::IfcOutletTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcOutletType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcOutletTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcOwnerHistory
IfcPersonAndOrganization* IfcOwnerHistory::OwningUser() const { return (IfcPersonAndOrganization*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcOwnerHistory::setOwningUser(IfcPersonAndOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcApplication* IfcOwnerHistory::OwningApplication() const { return (IfcApplication*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcOwnerHistory::setOwningApplication(IfcApplication* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcOwnerHistory::hasState() const { return !data_->getArgument(2)->isNull(); }
IfcStateEnum::IfcStateEnum IfcOwnerHistory::State() const { return IfcStateEnum::FromString(*data_->getArgument(2)); }
void IfcOwnerHistory::setState(IfcStateEnum::IfcStateEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStateEnum::ToString(v)));data_->setArgument(2,attr);} }
bool IfcOwnerHistory::hasChangeAction() const { return !data_->getArgument(3)->isNull(); }
IfcChangeActionEnum::IfcChangeActionEnum IfcOwnerHistory::ChangeAction() const { return IfcChangeActionEnum::FromString(*data_->getArgument(3)); }
void IfcOwnerHistory::setChangeAction(IfcChangeActionEnum::IfcChangeActionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcChangeActionEnum::ToString(v)));data_->setArgument(3,attr);} }
bool IfcOwnerHistory::hasLastModifiedDate() const { return !data_->getArgument(4)->isNull(); }
int IfcOwnerHistory::LastModifiedDate() const { return *data_->getArgument(4); }
void IfcOwnerHistory::setLastModifiedDate(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcOwnerHistory::hasLastModifyingUser() const { return !data_->getArgument(5)->isNull(); }
IfcPersonAndOrganization* IfcOwnerHistory::LastModifyingUser() const { return (IfcPersonAndOrganization*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcOwnerHistory::setLastModifyingUser(IfcPersonAndOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcOwnerHistory::hasLastModifyingApplication() const { return !data_->getArgument(6)->isNull(); }
IfcApplication* IfcOwnerHistory::LastModifyingApplication() const { return (IfcApplication*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcOwnerHistory::setLastModifyingApplication(IfcApplication* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
int IfcOwnerHistory::CreationDate() const { return *data_->getArgument(7); }
void IfcOwnerHistory::setCreationDate(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcOwnerHistory::declaration() const { return *IfcOwnerHistory_type; }
const IfcParse::entity& IfcOwnerHistory::Class() { return *IfcOwnerHistory_type; }
IfcOwnerHistory::IfcOwnerHistory(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcOwnerHistory_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcOwnerHistory::IfcOwnerHistory(IfcPersonAndOrganization* v1_OwningUser, IfcApplication* v2_OwningApplication, boost::optional< IfcStateEnum::IfcStateEnum > v3_State, boost::optional< IfcChangeActionEnum::IfcChangeActionEnum > v4_ChangeAction, boost::optional< int > v5_LastModifiedDate, IfcPersonAndOrganization* v6_LastModifyingUser, IfcApplication* v7_LastModifyingApplication, int v8_CreationDate) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcOwnerHistory_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_OwningUser));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwningApplication));data_->setArgument(1,attr);} if (v3_State) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v3_State,IfcStateEnum::ToString(*v3_State))));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ChangeAction) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v4_ChangeAction,IfcChangeActionEnum::ToString(*v4_ChangeAction))));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_LastModifiedDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LastModifiedDate));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_LastModifyingUser));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LastModifyingApplication));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_CreationDate));data_->setArgument(7,attr);} }

// Function implementations for IfcParameterizedProfileDef
bool IfcParameterizedProfileDef::hasPosition() const { return !data_->getArgument(2)->isNull(); }
IfcAxis2Placement2D* IfcParameterizedProfileDef::Position() const { return (IfcAxis2Placement2D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcParameterizedProfileDef::setPosition(IfcAxis2Placement2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcParameterizedProfileDef::declaration() const { return *IfcParameterizedProfileDef_type; }
const IfcParse::entity& IfcParameterizedProfileDef::Class() { return *IfcParameterizedProfileDef_type; }
IfcParameterizedProfileDef::IfcParameterizedProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcParameterizedProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcParameterizedProfileDef::IfcParameterizedProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcParameterizedProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);} }

// Function implementations for IfcPath
IfcTemplatedEntityList< IfcOrientedEdge >::ptr IfcPath::EdgeList() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcOrientedEdge>(); }
void IfcPath::setEdgeList(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& IfcPath::declaration() const { return *IfcPath_type; }
const IfcParse::entity& IfcPath::Class() { return *IfcPath_type; }
IfcPath::IfcPath(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPath_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPath::IfcPath(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v1_EdgeList) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPath_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeList)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcPcurve
IfcSurface* IfcPcurve::BasisSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcPcurve::setBasisSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcCurve* IfcPcurve::ReferenceCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcPcurve::setReferenceCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcPcurve::declaration() const { return *IfcPcurve_type; }
const IfcParse::entity& IfcPcurve::Class() { return *IfcPcurve_type; }
IfcPcurve::IfcPcurve(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPcurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPcurve::IfcPcurve(IfcSurface* v1_BasisSurface, IfcCurve* v2_ReferenceCurve) : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPcurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ReferenceCurve));data_->setArgument(1,attr);} }

// Function implementations for IfcPerformanceHistory
std::string IfcPerformanceHistory::LifeCyclePhase() const { return *data_->getArgument(6); }
void IfcPerformanceHistory::setLifeCyclePhase(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcPerformanceHistory::hasPredefinedType() const { return !data_->getArgument(7)->isNull(); }
IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum IfcPerformanceHistory::PredefinedType() const { return IfcPerformanceHistoryTypeEnum::FromString(*data_->getArgument(7)); }
void IfcPerformanceHistory::setPredefinedType(IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPerformanceHistoryTypeEnum::ToString(v)));data_->setArgument(7,attr);} }


const IfcParse::entity& IfcPerformanceHistory::declaration() const { return *IfcPerformanceHistory_type; }
const IfcParse::entity& IfcPerformanceHistory::Class() { return *IfcPerformanceHistory_type; }
IfcPerformanceHistory::IfcPerformanceHistory(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPerformanceHistory_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPerformanceHistory::IfcPerformanceHistory(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, std::string v7_LifeCyclePhase, boost::optional< IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum > v8_PredefinedType) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPerformanceHistory_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LifeCyclePhase));data_->setArgument(6,attr);} if (v8_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_PredefinedType,IfcPerformanceHistoryTypeEnum::ToString(*v8_PredefinedType))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcPermeableCoveringProperties
IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum IfcPermeableCoveringProperties::OperationType() const { return IfcPermeableCoveringOperationEnum::FromString(*data_->getArgument(4)); }
void IfcPermeableCoveringProperties::setOperationType(IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPermeableCoveringOperationEnum::ToString(v)));data_->setArgument(4,attr);} }
IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum IfcPermeableCoveringProperties::PanelPosition() const { return IfcWindowPanelPositionEnum::FromString(*data_->getArgument(5)); }
void IfcPermeableCoveringProperties::setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowPanelPositionEnum::ToString(v)));data_->setArgument(5,attr);} }
bool IfcPermeableCoveringProperties::hasFrameDepth() const { return !data_->getArgument(6)->isNull(); }
double IfcPermeableCoveringProperties::FrameDepth() const { return *data_->getArgument(6); }
void IfcPermeableCoveringProperties::setFrameDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcPermeableCoveringProperties::hasFrameThickness() const { return !data_->getArgument(7)->isNull(); }
double IfcPermeableCoveringProperties::FrameThickness() const { return *data_->getArgument(7); }
void IfcPermeableCoveringProperties::setFrameThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcPermeableCoveringProperties::hasShapeAspectStyle() const { return !data_->getArgument(8)->isNull(); }
IfcShapeAspect* IfcPermeableCoveringProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcPermeableCoveringProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcPermeableCoveringProperties::declaration() const { return *IfcPermeableCoveringProperties_type; }
const IfcParse::entity& IfcPermeableCoveringProperties::Class() { return *IfcPermeableCoveringProperties_type; }
IfcPermeableCoveringProperties::IfcPermeableCoveringProperties(IfcEntityInstanceData* e) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPermeableCoveringProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPermeableCoveringProperties::IfcPermeableCoveringProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPermeableCoveringProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_OperationType,IfcPermeableCoveringOperationEnum::ToString(v5_OperationType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PanelPosition,IfcWindowPanelPositionEnum::ToString(v6_PanelPosition))));data_->setArgument(5,attr);} if (v7_FrameDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_FrameDepth));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_FrameThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FrameThickness));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ShapeAspectStyle));data_->setArgument(8,attr);} }

// Function implementations for IfcPermit
bool IfcPermit::hasPredefinedType() const { return !data_->getArgument(6)->isNull(); }
IfcPermitTypeEnum::IfcPermitTypeEnum IfcPermit::PredefinedType() const { return IfcPermitTypeEnum::FromString(*data_->getArgument(6)); }
void IfcPermit::setPredefinedType(IfcPermitTypeEnum::IfcPermitTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPermitTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
bool IfcPermit::hasStatus() const { return !data_->getArgument(7)->isNull(); }
std::string IfcPermit::Status() const { return *data_->getArgument(7); }
void IfcPermit::setStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcPermit::hasLongDescription() const { return !data_->getArgument(8)->isNull(); }
std::string IfcPermit::LongDescription() const { return *data_->getArgument(8); }
void IfcPermit::setLongDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcPermit::declaration() const { return *IfcPermit_type; }
const IfcParse::entity& IfcPermit::Class() { return *IfcPermit_type; }
IfcPermit::IfcPermit(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPermit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPermit::IfcPermit(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcPermitTypeEnum::IfcPermitTypeEnum > v7_PredefinedType, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_LongDescription) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPermit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_PredefinedType,IfcPermitTypeEnum::ToString(*v7_PredefinedType))));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Status));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_LongDescription));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcPerson
bool IfcPerson::hasIdentification() const { return !data_->getArgument(0)->isNull(); }
std::string IfcPerson::Identification() const { return *data_->getArgument(0); }
void IfcPerson::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcPerson::hasFamilyName() const { return !data_->getArgument(1)->isNull(); }
std::string IfcPerson::FamilyName() const { return *data_->getArgument(1); }
void IfcPerson::setFamilyName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcPerson::hasGivenName() const { return !data_->getArgument(2)->isNull(); }
std::string IfcPerson::GivenName() const { return *data_->getArgument(2); }
void IfcPerson::setGivenName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcPerson::hasMiddleNames() const { return !data_->getArgument(3)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcPerson::MiddleNames() const { return *data_->getArgument(3); }
void IfcPerson::setMiddleNames(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcPerson::hasPrefixTitles() const { return !data_->getArgument(4)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcPerson::PrefixTitles() const { return *data_->getArgument(4); }
void IfcPerson::setPrefixTitles(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcPerson::hasSuffixTitles() const { return !data_->getArgument(5)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcPerson::SuffixTitles() const { return *data_->getArgument(5); }
void IfcPerson::setSuffixTitles(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcPerson::hasRoles() const { return !data_->getArgument(6)->isNull(); }
IfcTemplatedEntityList< IfcActorRole >::ptr IfcPerson::Roles() const { IfcEntityList::ptr es = *data_->getArgument(6); return es->as<IfcActorRole>(); }
void IfcPerson::setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(6,attr);} }
bool IfcPerson::hasAddresses() const { return !data_->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcAddress >::ptr IfcPerson::Addresses() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcAddress>(); }
void IfcPerson::setAddresses(IfcTemplatedEntityList< IfcAddress >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }

IfcPersonAndOrganization::list::ptr IfcPerson::EngagedIn() const { return data_->getInverse(IfcPersonAndOrganization_type, 0)->as<IfcPersonAndOrganization>(); }

const IfcParse::entity& IfcPerson::declaration() const { return *IfcPerson_type; }
const IfcParse::entity& IfcPerson::Class() { return *IfcPerson_type; }
IfcPerson::IfcPerson(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcPerson_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPerson::IfcPerson(boost::optional< std::string > v1_Identification, boost::optional< std::string > v2_FamilyName, boost::optional< std::string > v3_GivenName, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_MiddleNames, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_PrefixTitles, boost::optional< std::vector< std::string > /*[1:?]*/ > v6_SuffixTitles, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v7_Roles, boost::optional< IfcTemplatedEntityList< IfcAddress >::ptr > v8_Addresses) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcPerson_type);  if (v1_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Identification));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_FamilyName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_FamilyName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_GivenName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_GivenName));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_MiddleNames) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_MiddleNames));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_PrefixTitles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PrefixTitles));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_SuffixTitles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_SuffixTitles));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Roles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Roles)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Addresses) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Addresses)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcPersonAndOrganization
IfcPerson* IfcPersonAndOrganization::ThePerson() const { return (IfcPerson*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcPersonAndOrganization::setThePerson(IfcPerson* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcOrganization* IfcPersonAndOrganization::TheOrganization() const { return (IfcOrganization*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcPersonAndOrganization::setTheOrganization(IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcPersonAndOrganization::hasRoles() const { return !data_->getArgument(2)->isNull(); }
IfcTemplatedEntityList< IfcActorRole >::ptr IfcPersonAndOrganization::Roles() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcActorRole>(); }
void IfcPersonAndOrganization::setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& IfcPersonAndOrganization::declaration() const { return *IfcPersonAndOrganization_type; }
const IfcParse::entity& IfcPersonAndOrganization::Class() { return *IfcPersonAndOrganization_type; }
IfcPersonAndOrganization::IfcPersonAndOrganization(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcPersonAndOrganization_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPersonAndOrganization::IfcPersonAndOrganization(IfcPerson* v1_ThePerson, IfcOrganization* v2_TheOrganization, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v3_Roles) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcPersonAndOrganization_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ThePerson));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TheOrganization));data_->setArgument(1,attr);} if (v3_Roles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Roles)->generalize());data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcPhysicalComplexQuantity
IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr IfcPhysicalComplexQuantity::HasQuantities() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcPhysicalQuantity>(); }
void IfcPhysicalComplexQuantity::setHasQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }
std::string IfcPhysicalComplexQuantity::Discrimination() const { return *data_->getArgument(3); }
void IfcPhysicalComplexQuantity::setDiscrimination(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcPhysicalComplexQuantity::hasQuality() const { return !data_->getArgument(4)->isNull(); }
std::string IfcPhysicalComplexQuantity::Quality() const { return *data_->getArgument(4); }
void IfcPhysicalComplexQuantity::setQuality(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcPhysicalComplexQuantity::hasUsage() const { return !data_->getArgument(5)->isNull(); }
std::string IfcPhysicalComplexQuantity::Usage() const { return *data_->getArgument(5); }
void IfcPhysicalComplexQuantity::setUsage(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcPhysicalComplexQuantity::declaration() const { return *IfcPhysicalComplexQuantity_type; }
const IfcParse::entity& IfcPhysicalComplexQuantity::Class() { return *IfcPhysicalComplexQuantity_type; }
IfcPhysicalComplexQuantity::IfcPhysicalComplexQuantity(IfcEntityInstanceData* e) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPhysicalComplexQuantity_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPhysicalComplexQuantity::IfcPhysicalComplexQuantity(std::string v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v3_HasQuantities, std::string v4_Discrimination, boost::optional< std::string > v5_Quality, boost::optional< std::string > v6_Usage) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPhysicalComplexQuantity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_HasQuantities)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Discrimination));data_->setArgument(3,attr);} if (v5_Quality) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Quality));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Usage) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Usage));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcPhysicalQuantity
std::string IfcPhysicalQuantity::Name() const { return *data_->getArgument(0); }
void IfcPhysicalQuantity::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcPhysicalQuantity::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcPhysicalQuantity::Description() const { return *data_->getArgument(1); }
void IfcPhysicalQuantity::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcPhysicalQuantity::HasExternalReferences() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }
IfcPhysicalComplexQuantity::list::ptr IfcPhysicalQuantity::PartOfComplex() const { return data_->getInverse(IfcPhysicalComplexQuantity_type, 2)->as<IfcPhysicalComplexQuantity>(); }

const IfcParse::entity& IfcPhysicalQuantity::declaration() const { return *IfcPhysicalQuantity_type; }
const IfcParse::entity& IfcPhysicalQuantity::Class() { return *IfcPhysicalQuantity_type; }
IfcPhysicalQuantity::IfcPhysicalQuantity(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcPhysicalQuantity_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPhysicalQuantity::IfcPhysicalQuantity(std::string v1_Name, boost::optional< std::string > v2_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcPhysicalQuantity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcPhysicalSimpleQuantity
bool IfcPhysicalSimpleQuantity::hasUnit() const { return !data_->getArgument(2)->isNull(); }
IfcNamedUnit* IfcPhysicalSimpleQuantity::Unit() const { return (IfcNamedUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcPhysicalSimpleQuantity::setUnit(IfcNamedUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcPhysicalSimpleQuantity::declaration() const { return *IfcPhysicalSimpleQuantity_type; }
const IfcParse::entity& IfcPhysicalSimpleQuantity::Class() { return *IfcPhysicalSimpleQuantity_type; }
IfcPhysicalSimpleQuantity::IfcPhysicalSimpleQuantity(IfcEntityInstanceData* e) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPhysicalSimpleQuantity_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPhysicalSimpleQuantity::IfcPhysicalSimpleQuantity(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPhysicalSimpleQuantity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);} }

// Function implementations for IfcPile
bool IfcPile::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcPileTypeEnum::IfcPileTypeEnum IfcPile::PredefinedType() const { return IfcPileTypeEnum::FromString(*data_->getArgument(8)); }
void IfcPile::setPredefinedType(IfcPileTypeEnum::IfcPileTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPileTypeEnum::ToString(v)));data_->setArgument(8,attr);} }
bool IfcPile::hasConstructionType() const { return !data_->getArgument(9)->isNull(); }
IfcPileConstructionEnum::IfcPileConstructionEnum IfcPile::ConstructionType() const { return IfcPileConstructionEnum::FromString(*data_->getArgument(9)); }
void IfcPile::setConstructionType(IfcPileConstructionEnum::IfcPileConstructionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPileConstructionEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcPile::declaration() const { return *IfcPile_type; }
const IfcParse::entity& IfcPile::Class() { return *IfcPile_type; }
IfcPile::IfcPile(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPile_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPile::IfcPile(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPileTypeEnum::IfcPileTypeEnum > v9_PredefinedType, boost::optional< IfcPileConstructionEnum::IfcPileConstructionEnum > v10_ConstructionType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPile_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcPileTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_ConstructionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v10_ConstructionType,IfcPileConstructionEnum::ToString(*v10_ConstructionType))));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcPileType
IfcPileTypeEnum::IfcPileTypeEnum IfcPileType::PredefinedType() const { return IfcPileTypeEnum::FromString(*data_->getArgument(9)); }
void IfcPileType::setPredefinedType(IfcPileTypeEnum::IfcPileTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPileTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcPileType::declaration() const { return *IfcPileType_type; }
const IfcParse::entity& IfcPileType::Class() { return *IfcPileType_type; }
IfcPileType::IfcPileType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPileType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPileType::IfcPileType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPileTypeEnum::IfcPileTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPileType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcPileTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcPipeFitting
bool IfcPipeFitting::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum IfcPipeFitting::PredefinedType() const { return IfcPipeFittingTypeEnum::FromString(*data_->getArgument(8)); }
void IfcPipeFitting::setPredefinedType(IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPipeFittingTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcPipeFitting::declaration() const { return *IfcPipeFitting_type; }
const IfcParse::entity& IfcPipeFitting::Class() { return *IfcPipeFitting_type; }
IfcPipeFitting::IfcPipeFitting(IfcEntityInstanceData* e) : IfcFlowFitting((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPipeFitting_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPipeFitting::IfcPipeFitting(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPipeFitting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcPipeFittingTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcPipeFittingType
IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum IfcPipeFittingType::PredefinedType() const { return IfcPipeFittingTypeEnum::FromString(*data_->getArgument(9)); }
void IfcPipeFittingType::setPredefinedType(IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPipeFittingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcPipeFittingType::declaration() const { return *IfcPipeFittingType_type; }
const IfcParse::entity& IfcPipeFittingType::Class() { return *IfcPipeFittingType_type; }
IfcPipeFittingType::IfcPipeFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPipeFittingType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPipeFittingType::IfcPipeFittingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPipeFittingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcPipeFittingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcPipeSegment
bool IfcPipeSegment::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum IfcPipeSegment::PredefinedType() const { return IfcPipeSegmentTypeEnum::FromString(*data_->getArgument(8)); }
void IfcPipeSegment::setPredefinedType(IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPipeSegmentTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcPipeSegment::declaration() const { return *IfcPipeSegment_type; }
const IfcParse::entity& IfcPipeSegment::Class() { return *IfcPipeSegment_type; }
IfcPipeSegment::IfcPipeSegment(IfcEntityInstanceData* e) : IfcFlowSegment((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPipeSegment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPipeSegment::IfcPipeSegment(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum > v9_PredefinedType) : IfcFlowSegment((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPipeSegment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcPipeSegmentTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcPipeSegmentType
IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum IfcPipeSegmentType::PredefinedType() const { return IfcPipeSegmentTypeEnum::FromString(*data_->getArgument(9)); }
void IfcPipeSegmentType::setPredefinedType(IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPipeSegmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcPipeSegmentType::declaration() const { return *IfcPipeSegmentType_type; }
const IfcParse::entity& IfcPipeSegmentType::Class() { return *IfcPipeSegmentType_type; }
IfcPipeSegmentType::IfcPipeSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPipeSegmentType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPipeSegmentType::IfcPipeSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPipeSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcPipeSegmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcPixelTexture
int IfcPixelTexture::Width() const { return *data_->getArgument(5); }
void IfcPixelTexture::setWidth(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
int IfcPixelTexture::Height() const { return *data_->getArgument(6); }
void IfcPixelTexture::setHeight(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
int IfcPixelTexture::ColourComponents() const { return *data_->getArgument(7); }
void IfcPixelTexture::setColourComponents(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
std::vector< boost::dynamic_bitset<> > /*[1:?]*/ IfcPixelTexture::Pixel() const { return *data_->getArgument(8); }
void IfcPixelTexture::setPixel(std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcPixelTexture::declaration() const { return *IfcPixelTexture_type; }
const IfcParse::entity& IfcPixelTexture::Class() { return *IfcPixelTexture_type; }
IfcPixelTexture::IfcPixelTexture(IfcEntityInstanceData* e) : IfcSurfaceTexture((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPixelTexture_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPixelTexture::IfcPixelTexture(bool v1_RepeatS, bool v2_RepeatT, boost::optional< std::string > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_Parameter, int v6_Width, int v7_Height, int v8_ColourComponents, std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v9_Pixel) : IfcSurfaceTexture((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPixelTexture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));data_->setArgument(1,attr);} if (v3_Mode) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Mode));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));data_->setArgument(3,attr);} if (v5_Parameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Parameter));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Width));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Height));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ColourComponents));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_Pixel));data_->setArgument(8,attr);} }

// Function implementations for IfcPlacement
IfcCartesianPoint* IfcPlacement::Location() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcPlacement::setLocation(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcPlacement::declaration() const { return *IfcPlacement_type; }
const IfcParse::entity& IfcPlacement::Class() { return *IfcPlacement_type; }
IfcPlacement::IfcPlacement(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPlacement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPlacement::IfcPlacement(IfcCartesianPoint* v1_Location) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPlacement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));data_->setArgument(0,attr);} }

// Function implementations for IfcPlanarBox
IfcAxis2Placement* IfcPlanarBox::Placement() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcPlanarBox::setPlacement(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcPlanarBox::declaration() const { return *IfcPlanarBox_type; }
const IfcParse::entity& IfcPlanarBox::Class() { return *IfcPlanarBox_type; }
IfcPlanarBox::IfcPlanarBox(IfcEntityInstanceData* e) : IfcPlanarExtent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPlanarBox_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPlanarBox::IfcPlanarBox(double v1_SizeInX, double v2_SizeInY, IfcAxis2Placement* v3_Placement) : IfcPlanarExtent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPlanarBox_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SizeInX));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SizeInY));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Placement));data_->setArgument(2,attr);} }

// Function implementations for IfcPlanarExtent
double IfcPlanarExtent::SizeInX() const { return *data_->getArgument(0); }
void IfcPlanarExtent::setSizeInX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcPlanarExtent::SizeInY() const { return *data_->getArgument(1); }
void IfcPlanarExtent::setSizeInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcPlanarExtent::declaration() const { return *IfcPlanarExtent_type; }
const IfcParse::entity& IfcPlanarExtent::Class() { return *IfcPlanarExtent_type; }
IfcPlanarExtent::IfcPlanarExtent(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPlanarExtent_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPlanarExtent::IfcPlanarExtent(double v1_SizeInX, double v2_SizeInY) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPlanarExtent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SizeInX));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SizeInY));data_->setArgument(1,attr);} }

// Function implementations for IfcPlane


const IfcParse::entity& IfcPlane::declaration() const { return *IfcPlane_type; }
const IfcParse::entity& IfcPlane::Class() { return *IfcPlane_type; }
IfcPlane::IfcPlane(IfcEntityInstanceData* e) : IfcElementarySurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPlane_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPlane::IfcPlane(IfcAxis2Placement3D* v1_Position) : IfcElementarySurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPlane_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);} }

// Function implementations for IfcPlate
bool IfcPlate::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcPlateTypeEnum::IfcPlateTypeEnum IfcPlate::PredefinedType() const { return IfcPlateTypeEnum::FromString(*data_->getArgument(8)); }
void IfcPlate::setPredefinedType(IfcPlateTypeEnum::IfcPlateTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPlateTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcPlate::declaration() const { return *IfcPlate_type; }
const IfcParse::entity& IfcPlate::Class() { return *IfcPlate_type; }
IfcPlate::IfcPlate(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPlate_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPlate::IfcPlate(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPlateTypeEnum::IfcPlateTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPlate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcPlateTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcPlateStandardCase


const IfcParse::entity& IfcPlateStandardCase::declaration() const { return *IfcPlateStandardCase_type; }
const IfcParse::entity& IfcPlateStandardCase::Class() { return *IfcPlateStandardCase_type; }
IfcPlateStandardCase::IfcPlateStandardCase(IfcEntityInstanceData* e) : IfcPlate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPlateStandardCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPlateStandardCase::IfcPlateStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPlateTypeEnum::IfcPlateTypeEnum > v9_PredefinedType) : IfcPlate((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPlateStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcPlateTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcPlateType
IfcPlateTypeEnum::IfcPlateTypeEnum IfcPlateType::PredefinedType() const { return IfcPlateTypeEnum::FromString(*data_->getArgument(9)); }
void IfcPlateType::setPredefinedType(IfcPlateTypeEnum::IfcPlateTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPlateTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcPlateType::declaration() const { return *IfcPlateType_type; }
const IfcParse::entity& IfcPlateType::Class() { return *IfcPlateType_type; }
IfcPlateType::IfcPlateType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPlateType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPlateType::IfcPlateType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPlateTypeEnum::IfcPlateTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPlateType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcPlateTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcPoint


const IfcParse::entity& IfcPoint::declaration() const { return *IfcPoint_type; }
const IfcParse::entity& IfcPoint::Class() { return *IfcPoint_type; }
IfcPoint::IfcPoint(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPoint_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPoint::IfcPoint() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPoint_type);  }

// Function implementations for IfcPointOnCurve
IfcCurve* IfcPointOnCurve::BasisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcPointOnCurve::setBasisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcPointOnCurve::PointParameter() const { return *data_->getArgument(1); }
void IfcPointOnCurve::setPointParameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcPointOnCurve::declaration() const { return *IfcPointOnCurve_type; }
const IfcParse::entity& IfcPointOnCurve::Class() { return *IfcPointOnCurve_type; }
IfcPointOnCurve::IfcPointOnCurve(IfcEntityInstanceData* e) : IfcPoint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPointOnCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPointOnCurve::IfcPointOnCurve(IfcCurve* v1_BasisCurve, double v2_PointParameter) : IfcPoint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPointOnCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointParameter));data_->setArgument(1,attr);} }

// Function implementations for IfcPointOnSurface
IfcSurface* IfcPointOnSurface::BasisSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcPointOnSurface::setBasisSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcPointOnSurface::PointParameterU() const { return *data_->getArgument(1); }
void IfcPointOnSurface::setPointParameterU(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcPointOnSurface::PointParameterV() const { return *data_->getArgument(2); }
void IfcPointOnSurface::setPointParameterV(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcPointOnSurface::declaration() const { return *IfcPointOnSurface_type; }
const IfcParse::entity& IfcPointOnSurface::Class() { return *IfcPointOnSurface_type; }
IfcPointOnSurface::IfcPointOnSurface(IfcEntityInstanceData* e) : IfcPoint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPointOnSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPointOnSurface::IfcPointOnSurface(IfcSurface* v1_BasisSurface, double v2_PointParameterU, double v3_PointParameterV) : IfcPoint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPointOnSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointParameterU));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_PointParameterV));data_->setArgument(2,attr);} }

// Function implementations for IfcPolyLoop
IfcTemplatedEntityList< IfcCartesianPoint >::ptr IfcPolyLoop::Polygon() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcCartesianPoint>(); }
void IfcPolyLoop::setPolygon(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& IfcPolyLoop::declaration() const { return *IfcPolyLoop_type; }
const IfcParse::entity& IfcPolyLoop::Class() { return *IfcPolyLoop_type; }
IfcPolyLoop::IfcPolyLoop(IfcEntityInstanceData* e) : IfcLoop((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPolyLoop_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPolyLoop::IfcPolyLoop(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v1_Polygon) : IfcLoop((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPolyLoop_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Polygon)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcPolygonalBoundedHalfSpace
IfcAxis2Placement3D* IfcPolygonalBoundedHalfSpace::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcPolygonalBoundedHalfSpace::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcBoundedCurve* IfcPolygonalBoundedHalfSpace::PolygonalBoundary() const { return (IfcBoundedCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcPolygonalBoundedHalfSpace::setPolygonalBoundary(IfcBoundedCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcPolygonalBoundedHalfSpace::declaration() const { return *IfcPolygonalBoundedHalfSpace_type; }
const IfcParse::entity& IfcPolygonalBoundedHalfSpace::Class() { return *IfcPolygonalBoundedHalfSpace_type; }
IfcPolygonalBoundedHalfSpace::IfcPolygonalBoundedHalfSpace(IfcEntityInstanceData* e) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPolygonalBoundedHalfSpace_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPolygonalBoundedHalfSpace::IfcPolygonalBoundedHalfSpace(IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcAxis2Placement3D* v3_Position, IfcBoundedCurve* v4_PolygonalBoundary) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPolygonalBoundedHalfSpace_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BaseSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AgreementFlag));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_PolygonalBoundary));data_->setArgument(3,attr);} }

// Function implementations for IfcPolyline
IfcTemplatedEntityList< IfcCartesianPoint >::ptr IfcPolyline::Points() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcCartesianPoint>(); }
void IfcPolyline::setPoints(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& IfcPolyline::declaration() const { return *IfcPolyline_type; }
const IfcParse::entity& IfcPolyline::Class() { return *IfcPolyline_type; }
IfcPolyline::IfcPolyline(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPolyline_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPolyline::IfcPolyline(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v1_Points) : IfcBoundedCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPolyline_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Points)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcPort

IfcRelConnectsPortToElement::list::ptr IfcPort::ContainedIn() const { return data_->getInverse(IfcRelConnectsPortToElement_type, 4)->as<IfcRelConnectsPortToElement>(); }
IfcRelConnectsPorts::list::ptr IfcPort::ConnectedFrom() const { return data_->getInverse(IfcRelConnectsPorts_type, 5)->as<IfcRelConnectsPorts>(); }
IfcRelConnectsPorts::list::ptr IfcPort::ConnectedTo() const { return data_->getInverse(IfcRelConnectsPorts_type, 4)->as<IfcRelConnectsPorts>(); }

const IfcParse::entity& IfcPort::declaration() const { return *IfcPort_type; }
const IfcParse::entity& IfcPort::Class() { return *IfcPort_type; }
IfcPort::IfcPort(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPort_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPort::IfcPort(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPort_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcPostalAddress
bool IfcPostalAddress::hasInternalLocation() const { return !data_->getArgument(3)->isNull(); }
std::string IfcPostalAddress::InternalLocation() const { return *data_->getArgument(3); }
void IfcPostalAddress::setInternalLocation(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcPostalAddress::hasAddressLines() const { return !data_->getArgument(4)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcPostalAddress::AddressLines() const { return *data_->getArgument(4); }
void IfcPostalAddress::setAddressLines(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcPostalAddress::hasPostalBox() const { return !data_->getArgument(5)->isNull(); }
std::string IfcPostalAddress::PostalBox() const { return *data_->getArgument(5); }
void IfcPostalAddress::setPostalBox(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcPostalAddress::hasTown() const { return !data_->getArgument(6)->isNull(); }
std::string IfcPostalAddress::Town() const { return *data_->getArgument(6); }
void IfcPostalAddress::setTown(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcPostalAddress::hasRegion() const { return !data_->getArgument(7)->isNull(); }
std::string IfcPostalAddress::Region() const { return *data_->getArgument(7); }
void IfcPostalAddress::setRegion(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcPostalAddress::hasPostalCode() const { return !data_->getArgument(8)->isNull(); }
std::string IfcPostalAddress::PostalCode() const { return *data_->getArgument(8); }
void IfcPostalAddress::setPostalCode(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcPostalAddress::hasCountry() const { return !data_->getArgument(9)->isNull(); }
std::string IfcPostalAddress::Country() const { return *data_->getArgument(9); }
void IfcPostalAddress::setCountry(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcPostalAddress::declaration() const { return *IfcPostalAddress_type; }
const IfcParse::entity& IfcPostalAddress::Class() { return *IfcPostalAddress_type; }
IfcPostalAddress::IfcPostalAddress(IfcEntityInstanceData* e) : IfcAddress((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPostalAddress_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPostalAddress::IfcPostalAddress(boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::string > v4_InternalLocation, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_AddressLines, boost::optional< std::string > v6_PostalBox, boost::optional< std::string > v7_Town, boost::optional< std::string > v8_Region, boost::optional< std::string > v9_PostalCode, boost::optional< std::string > v10_Country) : IfcAddress((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPostalAddress_type);  if (v1_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v1_Purpose,IfcAddressTypeEnum::ToString(*v1_Purpose))));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedPurpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedPurpose));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_InternalLocation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_InternalLocation));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_AddressLines) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_AddressLines));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_PostalBox) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_PostalBox));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Town) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Town));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Region) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Region));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PostalCode) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_PostalCode));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Country) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Country));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcPreDefinedColour


const IfcParse::entity& IfcPreDefinedColour::declaration() const { return *IfcPreDefinedColour_type; }
const IfcParse::entity& IfcPreDefinedColour::Class() { return *IfcPreDefinedColour_type; }
IfcPreDefinedColour::IfcPreDefinedColour(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPreDefinedColour_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPreDefinedColour::IfcPreDefinedColour(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPreDefinedColour_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedCurveFont


const IfcParse::entity& IfcPreDefinedCurveFont::declaration() const { return *IfcPreDefinedCurveFont_type; }
const IfcParse::entity& IfcPreDefinedCurveFont::Class() { return *IfcPreDefinedCurveFont_type; }
IfcPreDefinedCurveFont::IfcPreDefinedCurveFont(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPreDefinedCurveFont_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPreDefinedCurveFont::IfcPreDefinedCurveFont(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPreDefinedCurveFont_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedItem
std::string IfcPreDefinedItem::Name() const { return *data_->getArgument(0); }
void IfcPreDefinedItem::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcPreDefinedItem::declaration() const { return *IfcPreDefinedItem_type; }
const IfcParse::entity& IfcPreDefinedItem::Class() { return *IfcPreDefinedItem_type; }
IfcPreDefinedItem::IfcPreDefinedItem(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPreDefinedItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPreDefinedItem::IfcPreDefinedItem(std::string v1_Name) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPreDefinedItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedProperties


const IfcParse::entity& IfcPreDefinedProperties::declaration() const { return *IfcPreDefinedProperties_type; }
const IfcParse::entity& IfcPreDefinedProperties::Class() { return *IfcPreDefinedProperties_type; }
IfcPreDefinedProperties::IfcPreDefinedProperties(IfcEntityInstanceData* e) : IfcPropertyAbstraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPreDefinedProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPreDefinedProperties::IfcPreDefinedProperties() : IfcPropertyAbstraction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPreDefinedProperties_type);  }

// Function implementations for IfcPreDefinedPropertySet


const IfcParse::entity& IfcPreDefinedPropertySet::declaration() const { return *IfcPreDefinedPropertySet_type; }
const IfcParse::entity& IfcPreDefinedPropertySet::Class() { return *IfcPreDefinedPropertySet_type; }
IfcPreDefinedPropertySet::IfcPreDefinedPropertySet(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPreDefinedPropertySet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPreDefinedPropertySet::IfcPreDefinedPropertySet(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPreDefinedPropertySet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcPreDefinedTextFont


const IfcParse::entity& IfcPreDefinedTextFont::declaration() const { return *IfcPreDefinedTextFont_type; }
const IfcParse::entity& IfcPreDefinedTextFont::Class() { return *IfcPreDefinedTextFont_type; }
IfcPreDefinedTextFont::IfcPreDefinedTextFont(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPreDefinedTextFont_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPreDefinedTextFont::IfcPreDefinedTextFont(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPreDefinedTextFont_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPresentationItem


const IfcParse::entity& IfcPresentationItem::declaration() const { return *IfcPresentationItem_type; }
const IfcParse::entity& IfcPresentationItem::Class() { return *IfcPresentationItem_type; }
IfcPresentationItem::IfcPresentationItem(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcPresentationItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPresentationItem::IfcPresentationItem() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcPresentationItem_type);  }

// Function implementations for IfcPresentationLayerAssignment
std::string IfcPresentationLayerAssignment::Name() const { return *data_->getArgument(0); }
void IfcPresentationLayerAssignment::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcPresentationLayerAssignment::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcPresentationLayerAssignment::Description() const { return *data_->getArgument(1); }
void IfcPresentationLayerAssignment::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcEntityList::ptr IfcPresentationLayerAssignment::AssignedItems() const { return *data_->getArgument(2); }
void IfcPresentationLayerAssignment::setAssignedItems(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcPresentationLayerAssignment::hasIdentifier() const { return !data_->getArgument(3)->isNull(); }
std::string IfcPresentationLayerAssignment::Identifier() const { return *data_->getArgument(3); }
void IfcPresentationLayerAssignment::setIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcPresentationLayerAssignment::declaration() const { return *IfcPresentationLayerAssignment_type; }
const IfcParse::entity& IfcPresentationLayerAssignment::Class() { return *IfcPresentationLayerAssignment_type; }
IfcPresentationLayerAssignment::IfcPresentationLayerAssignment(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcPresentationLayerAssignment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPresentationLayerAssignment::IfcPresentationLayerAssignment(std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcPresentationLayerAssignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AssignedItems));data_->setArgument(2,attr);} if (v4_Identifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Identifier));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcPresentationLayerWithStyle
bool IfcPresentationLayerWithStyle::LayerOn() const { return *data_->getArgument(4); }
void IfcPresentationLayerWithStyle::setLayerOn(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcPresentationLayerWithStyle::LayerFrozen() const { return *data_->getArgument(5); }
void IfcPresentationLayerWithStyle::setLayerFrozen(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcPresentationLayerWithStyle::LayerBlocked() const { return *data_->getArgument(6); }
void IfcPresentationLayerWithStyle::setLayerBlocked(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
IfcTemplatedEntityList< IfcPresentationStyle >::ptr IfcPresentationLayerWithStyle::LayerStyles() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcPresentationStyle>(); }
void IfcPresentationLayerWithStyle::setLayerStyles(IfcTemplatedEntityList< IfcPresentationStyle >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }


const IfcParse::entity& IfcPresentationLayerWithStyle::declaration() const { return *IfcPresentationLayerWithStyle_type; }
const IfcParse::entity& IfcPresentationLayerWithStyle::Class() { return *IfcPresentationLayerWithStyle_type; }
IfcPresentationLayerWithStyle::IfcPresentationLayerWithStyle(IfcEntityInstanceData* e) : IfcPresentationLayerAssignment((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPresentationLayerWithStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPresentationLayerWithStyle::IfcPresentationLayerWithStyle(std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier, bool v5_LayerOn, bool v6_LayerFrozen, bool v7_LayerBlocked, IfcTemplatedEntityList< IfcPresentationStyle >::ptr v8_LayerStyles) : IfcPresentationLayerAssignment((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPresentationLayerWithStyle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AssignedItems));data_->setArgument(2,attr);} if (v4_Identifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Identifier));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_LayerOn));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_LayerFrozen));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LayerBlocked));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LayerStyles)->generalize());data_->setArgument(7,attr);} }

// Function implementations for IfcPresentationStyle
bool IfcPresentationStyle::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcPresentationStyle::Name() const { return *data_->getArgument(0); }
void IfcPresentationStyle::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcPresentationStyle::declaration() const { return *IfcPresentationStyle_type; }
const IfcParse::entity& IfcPresentationStyle::Class() { return *IfcPresentationStyle_type; }
IfcPresentationStyle::IfcPresentationStyle(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcPresentationStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPresentationStyle::IfcPresentationStyle(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcPresentationStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcPresentationStyleAssignment
IfcEntityList::ptr IfcPresentationStyleAssignment::Styles() const { return *data_->getArgument(0); }
void IfcPresentationStyleAssignment::setStyles(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcPresentationStyleAssignment::declaration() const { return *IfcPresentationStyleAssignment_type; }
const IfcParse::entity& IfcPresentationStyleAssignment::Class() { return *IfcPresentationStyleAssignment_type; }
IfcPresentationStyleAssignment::IfcPresentationStyleAssignment(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcPresentationStyleAssignment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPresentationStyleAssignment::IfcPresentationStyleAssignment(IfcEntityList::ptr v1_Styles) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcPresentationStyleAssignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Styles));data_->setArgument(0,attr);} }

// Function implementations for IfcProcedure
bool IfcProcedure::hasPredefinedType() const { return !data_->getArgument(7)->isNull(); }
IfcProcedureTypeEnum::IfcProcedureTypeEnum IfcProcedure::PredefinedType() const { return IfcProcedureTypeEnum::FromString(*data_->getArgument(7)); }
void IfcProcedure::setPredefinedType(IfcProcedureTypeEnum::IfcProcedureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProcedureTypeEnum::ToString(v)));data_->setArgument(7,attr);} }


const IfcParse::entity& IfcProcedure::declaration() const { return *IfcProcedure_type; }
const IfcParse::entity& IfcProcedure::Class() { return *IfcProcedure_type; }
IfcProcedure::IfcProcedure(IfcEntityInstanceData* e) : IfcProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProcedure_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProcedure::IfcProcedure(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, boost::optional< IfcProcedureTypeEnum::IfcProcedureTypeEnum > v8_PredefinedType) : IfcProcess((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProcedure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_PredefinedType,IfcProcedureTypeEnum::ToString(*v8_PredefinedType))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcProcedureType
IfcProcedureTypeEnum::IfcProcedureTypeEnum IfcProcedureType::PredefinedType() const { return IfcProcedureTypeEnum::FromString(*data_->getArgument(9)); }
void IfcProcedureType::setPredefinedType(IfcProcedureTypeEnum::IfcProcedureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProcedureTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcProcedureType::declaration() const { return *IfcProcedureType_type; }
const IfcParse::entity& IfcProcedureType::Class() { return *IfcProcedureType_type; }
IfcProcedureType::IfcProcedureType(IfcEntityInstanceData* e) : IfcTypeProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProcedureType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProcedureType::IfcProcedureType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ProcessType, IfcProcedureTypeEnum::IfcProcedureTypeEnum v10_PredefinedType) : IfcTypeProcess((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProcedureType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ProcessType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ProcessType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcProcedureTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcProcess
bool IfcProcess::hasIdentification() const { return !data_->getArgument(5)->isNull(); }
std::string IfcProcess::Identification() const { return *data_->getArgument(5); }
void IfcProcess::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcProcess::hasLongDescription() const { return !data_->getArgument(6)->isNull(); }
std::string IfcProcess::LongDescription() const { return *data_->getArgument(6); }
void IfcProcess::setLongDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }

IfcRelSequence::list::ptr IfcProcess::IsPredecessorTo() const { return data_->getInverse(IfcRelSequence_type, 4)->as<IfcRelSequence>(); }
IfcRelSequence::list::ptr IfcProcess::IsSuccessorFrom() const { return data_->getInverse(IfcRelSequence_type, 5)->as<IfcRelSequence>(); }
IfcRelAssignsToProcess::list::ptr IfcProcess::OperatesOn() const { return data_->getInverse(IfcRelAssignsToProcess_type, 6)->as<IfcRelAssignsToProcess>(); }

const IfcParse::entity& IfcProcess::declaration() const { return *IfcProcess_type; }
const IfcParse::entity& IfcProcess::Class() { return *IfcProcess_type; }
IfcProcess::IfcProcess(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProcess_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProcess::IfcProcess(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProcess_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcProduct
bool IfcProduct::hasObjectPlacement() const { return !data_->getArgument(5)->isNull(); }
IfcObjectPlacement* IfcProduct::ObjectPlacement() const { return (IfcObjectPlacement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcProduct::setObjectPlacement(IfcObjectPlacement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcProduct::hasRepresentation() const { return !data_->getArgument(6)->isNull(); }
IfcProductRepresentation* IfcProduct::Representation() const { return (IfcProductRepresentation*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcProduct::setRepresentation(IfcProductRepresentation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }

IfcRelAssignsToProduct::list::ptr IfcProduct::ReferencedBy() const { return data_->getInverse(IfcRelAssignsToProduct_type, 6)->as<IfcRelAssignsToProduct>(); }

const IfcParse::entity& IfcProduct::declaration() const { return *IfcProduct_type; }
const IfcParse::entity& IfcProduct::Class() { return *IfcProduct_type; }
IfcProduct::IfcProduct(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProduct_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProduct::IfcProduct(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProduct_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcProductDefinitionShape

IfcProduct::list::ptr IfcProductDefinitionShape::ShapeOfProduct() const { return data_->getInverse(IfcProduct_type, 6)->as<IfcProduct>(); }
IfcShapeAspect::list::ptr IfcProductDefinitionShape::HasShapeAspects() const { return data_->getInverse(IfcShapeAspect_type, 4)->as<IfcShapeAspect>(); }

const IfcParse::entity& IfcProductDefinitionShape::declaration() const { return *IfcProductDefinitionShape_type; }
const IfcParse::entity& IfcProductDefinitionShape::Class() { return *IfcProductDefinitionShape_type; }
IfcProductDefinitionShape::IfcProductDefinitionShape(IfcEntityInstanceData* e) : IfcProductRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProductDefinitionShape_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProductDefinitionShape::IfcProductDefinitionShape(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations) : IfcProductRepresentation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProductDefinitionShape_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Representations)->generalize());data_->setArgument(2,attr);} }

// Function implementations for IfcProductRepresentation
bool IfcProductRepresentation::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcProductRepresentation::Name() const { return *data_->getArgument(0); }
void IfcProductRepresentation::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcProductRepresentation::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcProductRepresentation::Description() const { return *data_->getArgument(1); }
void IfcProductRepresentation::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcTemplatedEntityList< IfcRepresentation >::ptr IfcProductRepresentation::Representations() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcRepresentation>(); }
void IfcProductRepresentation::setRepresentations(IfcTemplatedEntityList< IfcRepresentation >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& IfcProductRepresentation::declaration() const { return *IfcProductRepresentation_type; }
const IfcParse::entity& IfcProductRepresentation::Class() { return *IfcProductRepresentation_type; }
IfcProductRepresentation::IfcProductRepresentation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcProductRepresentation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProductRepresentation::IfcProductRepresentation(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcProductRepresentation_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Representations)->generalize());data_->setArgument(2,attr);} }

// Function implementations for IfcProfileDef
IfcProfileTypeEnum::IfcProfileTypeEnum IfcProfileDef::ProfileType() const { return IfcProfileTypeEnum::FromString(*data_->getArgument(0)); }
void IfcProfileDef::setProfileType(IfcProfileTypeEnum::IfcProfileTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProfileTypeEnum::ToString(v)));data_->setArgument(0,attr);} }
bool IfcProfileDef::hasProfileName() const { return !data_->getArgument(1)->isNull(); }
std::string IfcProfileDef::ProfileName() const { return *data_->getArgument(1); }
void IfcProfileDef::setProfileName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcProfileDef::HasExternalReference() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }
IfcProfileProperties::list::ptr IfcProfileDef::HasProperties() const { return data_->getInverse(IfcProfileProperties_type, 3)->as<IfcProfileProperties>(); }

const IfcParse::entity& IfcProfileDef::declaration() const { return *IfcProfileDef_type; }
const IfcParse::entity& IfcProfileDef::Class() { return *IfcProfileDef_type; }
IfcProfileDef::IfcProfileDef(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProfileDef::IfcProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcProfileProperties
IfcProfileDef* IfcProfileProperties::ProfileDefinition() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcProfileProperties::setProfileDefinition(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcProfileProperties::declaration() const { return *IfcProfileProperties_type; }
const IfcParse::entity& IfcProfileProperties::Class() { return *IfcProfileProperties_type; }
IfcProfileProperties::IfcProfileProperties(IfcEntityInstanceData* e) : IfcExtendedProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProfileProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProfileProperties::IfcProfileProperties(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcProperty >::ptr v3_Properties, IfcProfileDef* v4_ProfileDefinition) : IfcExtendedProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProfileProperties_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Properties)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ProfileDefinition));data_->setArgument(3,attr);} }

// Function implementations for IfcProject


const IfcParse::entity& IfcProject::declaration() const { return *IfcProject_type; }
const IfcParse::entity& IfcProject::Class() { return *IfcProject_type; }
IfcProject::IfcProject(IfcEntityInstanceData* e) : IfcContext((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProject_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProject::IfcProject(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< std::string > v7_Phase, boost::optional< IfcTemplatedEntityList< IfcRepresentationContext >::ptr > v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext) : IfcContext((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProject_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LongName));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Phase) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Phase));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_RepresentationContexts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_RepresentationContexts)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_UnitsInContext));data_->setArgument(8,attr);} }

// Function implementations for IfcProjectLibrary


const IfcParse::entity& IfcProjectLibrary::declaration() const { return *IfcProjectLibrary_type; }
const IfcParse::entity& IfcProjectLibrary::Class() { return *IfcProjectLibrary_type; }
IfcProjectLibrary::IfcProjectLibrary(IfcEntityInstanceData* e) : IfcContext((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProjectLibrary_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProjectLibrary::IfcProjectLibrary(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< std::string > v7_Phase, boost::optional< IfcTemplatedEntityList< IfcRepresentationContext >::ptr > v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext) : IfcContext((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProjectLibrary_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LongName));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Phase) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Phase));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_RepresentationContexts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_RepresentationContexts)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_UnitsInContext));data_->setArgument(8,attr);} }

// Function implementations for IfcProjectOrder
bool IfcProjectOrder::hasPredefinedType() const { return !data_->getArgument(6)->isNull(); }
IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum IfcProjectOrder::PredefinedType() const { return IfcProjectOrderTypeEnum::FromString(*data_->getArgument(6)); }
void IfcProjectOrder::setPredefinedType(IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProjectOrderTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
bool IfcProjectOrder::hasStatus() const { return !data_->getArgument(7)->isNull(); }
std::string IfcProjectOrder::Status() const { return *data_->getArgument(7); }
void IfcProjectOrder::setStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcProjectOrder::hasLongDescription() const { return !data_->getArgument(8)->isNull(); }
std::string IfcProjectOrder::LongDescription() const { return *data_->getArgument(8); }
void IfcProjectOrder::setLongDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcProjectOrder::declaration() const { return *IfcProjectOrder_type; }
const IfcParse::entity& IfcProjectOrder::Class() { return *IfcProjectOrder_type; }
IfcProjectOrder::IfcProjectOrder(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProjectOrder_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProjectOrder::IfcProjectOrder(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum > v7_PredefinedType, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_LongDescription) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProjectOrder_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_PredefinedType,IfcProjectOrderTypeEnum::ToString(*v7_PredefinedType))));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Status));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_LongDescription));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcProjectedCRS
bool IfcProjectedCRS::hasMapProjection() const { return !data_->getArgument(4)->isNull(); }
std::string IfcProjectedCRS::MapProjection() const { return *data_->getArgument(4); }
void IfcProjectedCRS::setMapProjection(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcProjectedCRS::hasMapZone() const { return !data_->getArgument(5)->isNull(); }
std::string IfcProjectedCRS::MapZone() const { return *data_->getArgument(5); }
void IfcProjectedCRS::setMapZone(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcProjectedCRS::hasMapUnit() const { return !data_->getArgument(6)->isNull(); }
IfcNamedUnit* IfcProjectedCRS::MapUnit() const { return (IfcNamedUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcProjectedCRS::setMapUnit(IfcNamedUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcProjectedCRS::declaration() const { return *IfcProjectedCRS_type; }
const IfcParse::entity& IfcProjectedCRS::Class() { return *IfcProjectedCRS_type; }
IfcProjectedCRS::IfcProjectedCRS(IfcEntityInstanceData* e) : IfcCoordinateReferenceSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProjectedCRS_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProjectedCRS::IfcProjectedCRS(std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_GeodeticDatum, boost::optional< std::string > v4_VerticalDatum, boost::optional< std::string > v5_MapProjection, boost::optional< std::string > v6_MapZone, IfcNamedUnit* v7_MapUnit) : IfcCoordinateReferenceSystem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProjectedCRS_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_GeodeticDatum) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_GeodeticDatum));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_VerticalDatum) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_VerticalDatum));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MapProjection) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MapProjection));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_MapZone) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MapZone));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_MapUnit));data_->setArgument(6,attr);} }

// Function implementations for IfcProjectionElement
bool IfcProjectionElement::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum IfcProjectionElement::PredefinedType() const { return IfcProjectionElementTypeEnum::FromString(*data_->getArgument(8)); }
void IfcProjectionElement::setPredefinedType(IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProjectionElementTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcProjectionElement::declaration() const { return *IfcProjectionElement_type; }
const IfcParse::entity& IfcProjectionElement::Class() { return *IfcProjectionElement_type; }
IfcProjectionElement::IfcProjectionElement(IfcEntityInstanceData* e) : IfcFeatureElementAddition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProjectionElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProjectionElement::IfcProjectionElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum > v9_PredefinedType) : IfcFeatureElementAddition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProjectionElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcProjectionElementTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcProperty
std::string IfcProperty::Name() const { return *data_->getArgument(0); }
void IfcProperty::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcProperty::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcProperty::Description() const { return *data_->getArgument(1); }
void IfcProperty::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }

IfcPropertySet::list::ptr IfcProperty::PartOfPset() const { return data_->getInverse(IfcPropertySet_type, 4)->as<IfcPropertySet>(); }
IfcPropertyDependencyRelationship::list::ptr IfcProperty::PropertyForDependance() const { return data_->getInverse(IfcPropertyDependencyRelationship_type, 2)->as<IfcPropertyDependencyRelationship>(); }
IfcPropertyDependencyRelationship::list::ptr IfcProperty::PropertyDependsOn() const { return data_->getInverse(IfcPropertyDependencyRelationship_type, 3)->as<IfcPropertyDependencyRelationship>(); }
IfcComplexProperty::list::ptr IfcProperty::PartOfComplex() const { return data_->getInverse(IfcComplexProperty_type, 3)->as<IfcComplexProperty>(); }
IfcResourceConstraintRelationship::list::ptr IfcProperty::HasConstraints() const { return data_->getInverse(IfcResourceConstraintRelationship_type, 3)->as<IfcResourceConstraintRelationship>(); }
IfcResourceApprovalRelationship::list::ptr IfcProperty::HasApprovals() const { return data_->getInverse(IfcResourceApprovalRelationship_type, 2)->as<IfcResourceApprovalRelationship>(); }

const IfcParse::entity& IfcProperty::declaration() const { return *IfcProperty_type; }
const IfcParse::entity& IfcProperty::Class() { return *IfcProperty_type; }
IfcProperty::IfcProperty(IfcEntityInstanceData* e) : IfcPropertyAbstraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProperty_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProperty::IfcProperty(std::string v1_Name, boost::optional< std::string > v2_Description) : IfcPropertyAbstraction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProperty_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcPropertyAbstraction

IfcExternalReferenceRelationship::list::ptr IfcPropertyAbstraction::HasExternalReferences() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }

const IfcParse::entity& IfcPropertyAbstraction::declaration() const { return *IfcPropertyAbstraction_type; }
const IfcParse::entity& IfcPropertyAbstraction::Class() { return *IfcPropertyAbstraction_type; }
IfcPropertyAbstraction::IfcPropertyAbstraction(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcPropertyAbstraction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyAbstraction::IfcPropertyAbstraction() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcPropertyAbstraction_type);  }

// Function implementations for IfcPropertyBoundedValue
bool IfcPropertyBoundedValue::hasUpperBoundValue() const { return !data_->getArgument(2)->isNull(); }
IfcValue* IfcPropertyBoundedValue::UpperBoundValue() const { return (IfcValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcPropertyBoundedValue::setUpperBoundValue(IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcPropertyBoundedValue::hasLowerBoundValue() const { return !data_->getArgument(3)->isNull(); }
IfcValue* IfcPropertyBoundedValue::LowerBoundValue() const { return (IfcValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcPropertyBoundedValue::setLowerBoundValue(IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcPropertyBoundedValue::hasUnit() const { return !data_->getArgument(4)->isNull(); }
IfcUnit* IfcPropertyBoundedValue::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcPropertyBoundedValue::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcPropertyBoundedValue::hasSetPointValue() const { return !data_->getArgument(5)->isNull(); }
IfcValue* IfcPropertyBoundedValue::SetPointValue() const { return (IfcValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcPropertyBoundedValue::setSetPointValue(IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcPropertyBoundedValue::declaration() const { return *IfcPropertyBoundedValue_type; }
const IfcParse::entity& IfcPropertyBoundedValue::Class() { return *IfcPropertyBoundedValue_type; }
IfcPropertyBoundedValue::IfcPropertyBoundedValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyBoundedValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyBoundedValue::IfcPropertyBoundedValue(std::string v1_Name, boost::optional< std::string > v2_Description, IfcValue* v3_UpperBoundValue, IfcValue* v4_LowerBoundValue, IfcUnit* v5_Unit, IfcValue* v6_SetPointValue) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyBoundedValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_UpperBoundValue));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LowerBoundValue));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Unit));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_SetPointValue));data_->setArgument(5,attr);} }

// Function implementations for IfcPropertyDefinition

IfcRelDeclares::list::ptr IfcPropertyDefinition::HasContext() const { return data_->getInverse(IfcRelDeclares_type, 5)->as<IfcRelDeclares>(); }
IfcRelAssociates::list::ptr IfcPropertyDefinition::HasAssociations() const { return data_->getInverse(IfcRelAssociates_type, 4)->as<IfcRelAssociates>(); }

const IfcParse::entity& IfcPropertyDefinition::declaration() const { return *IfcPropertyDefinition_type; }
const IfcParse::entity& IfcPropertyDefinition::Class() { return *IfcPropertyDefinition_type; }
IfcPropertyDefinition::IfcPropertyDefinition(IfcEntityInstanceData* e) : IfcRoot((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyDefinition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyDefinition::IfcPropertyDefinition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRoot((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyDefinition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcPropertyDependencyRelationship
IfcProperty* IfcPropertyDependencyRelationship::DependingProperty() const { return (IfcProperty*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcPropertyDependencyRelationship::setDependingProperty(IfcProperty* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcProperty* IfcPropertyDependencyRelationship::DependantProperty() const { return (IfcProperty*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcPropertyDependencyRelationship::setDependantProperty(IfcProperty* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcPropertyDependencyRelationship::hasExpression() const { return !data_->getArgument(4)->isNull(); }
std::string IfcPropertyDependencyRelationship::Expression() const { return *data_->getArgument(4); }
void IfcPropertyDependencyRelationship::setExpression(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcPropertyDependencyRelationship::declaration() const { return *IfcPropertyDependencyRelationship_type; }
const IfcParse::entity& IfcPropertyDependencyRelationship::Class() { return *IfcPropertyDependencyRelationship_type; }
IfcPropertyDependencyRelationship::IfcPropertyDependencyRelationship(IfcEntityInstanceData* e) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyDependencyRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyDependencyRelationship::IfcPropertyDependencyRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcProperty* v3_DependingProperty, IfcProperty* v4_DependantProperty, boost::optional< std::string > v5_Expression) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyDependencyRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_DependingProperty));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_DependantProperty));data_->setArgument(3,attr);} if (v5_Expression) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Expression));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcPropertyEnumeratedValue
bool IfcPropertyEnumeratedValue::hasEnumerationValues() const { return !data_->getArgument(2)->isNull(); }
IfcEntityList::ptr IfcPropertyEnumeratedValue::EnumerationValues() const { return *data_->getArgument(2); }
void IfcPropertyEnumeratedValue::setEnumerationValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcPropertyEnumeratedValue::hasEnumerationReference() const { return !data_->getArgument(3)->isNull(); }
IfcPropertyEnumeration* IfcPropertyEnumeratedValue::EnumerationReference() const { return (IfcPropertyEnumeration*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcPropertyEnumeratedValue::setEnumerationReference(IfcPropertyEnumeration* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcPropertyEnumeratedValue::declaration() const { return *IfcPropertyEnumeratedValue_type; }
const IfcParse::entity& IfcPropertyEnumeratedValue::Class() { return *IfcPropertyEnumeratedValue_type; }
IfcPropertyEnumeratedValue::IfcPropertyEnumeratedValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyEnumeratedValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyEnumeratedValue::IfcPropertyEnumeratedValue(std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< IfcEntityList::ptr > v3_EnumerationValues, IfcPropertyEnumeration* v4_EnumerationReference) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyEnumeratedValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_EnumerationValues) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_EnumerationValues));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EnumerationReference));data_->setArgument(3,attr);} }

// Function implementations for IfcPropertyEnumeration
std::string IfcPropertyEnumeration::Name() const { return *data_->getArgument(0); }
void IfcPropertyEnumeration::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcEntityList::ptr IfcPropertyEnumeration::EnumerationValues() const { return *data_->getArgument(1); }
void IfcPropertyEnumeration::setEnumerationValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcPropertyEnumeration::hasUnit() const { return !data_->getArgument(2)->isNull(); }
IfcUnit* IfcPropertyEnumeration::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcPropertyEnumeration::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcPropertyEnumeration::declaration() const { return *IfcPropertyEnumeration_type; }
const IfcParse::entity& IfcPropertyEnumeration::Class() { return *IfcPropertyEnumeration_type; }
IfcPropertyEnumeration::IfcPropertyEnumeration(IfcEntityInstanceData* e) : IfcPropertyAbstraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyEnumeration_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyEnumeration::IfcPropertyEnumeration(std::string v1_Name, IfcEntityList::ptr v2_EnumerationValues, IfcUnit* v3_Unit) : IfcPropertyAbstraction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyEnumeration_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EnumerationValues));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);} }

// Function implementations for IfcPropertyListValue
bool IfcPropertyListValue::hasListValues() const { return !data_->getArgument(2)->isNull(); }
IfcEntityList::ptr IfcPropertyListValue::ListValues() const { return *data_->getArgument(2); }
void IfcPropertyListValue::setListValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcPropertyListValue::hasUnit() const { return !data_->getArgument(3)->isNull(); }
IfcUnit* IfcPropertyListValue::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcPropertyListValue::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcPropertyListValue::declaration() const { return *IfcPropertyListValue_type; }
const IfcParse::entity& IfcPropertyListValue::Class() { return *IfcPropertyListValue_type; }
IfcPropertyListValue::IfcPropertyListValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyListValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyListValue::IfcPropertyListValue(std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< IfcEntityList::ptr > v3_ListValues, IfcUnit* v4_Unit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyListValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_ListValues) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ListValues));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Unit));data_->setArgument(3,attr);} }

// Function implementations for IfcPropertyReferenceValue
bool IfcPropertyReferenceValue::hasUsageName() const { return !data_->getArgument(2)->isNull(); }
std::string IfcPropertyReferenceValue::UsageName() const { return *data_->getArgument(2); }
void IfcPropertyReferenceValue::setUsageName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcPropertyReferenceValue::hasPropertyReference() const { return !data_->getArgument(3)->isNull(); }
IfcObjectReferenceSelect* IfcPropertyReferenceValue::PropertyReference() const { return (IfcObjectReferenceSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcPropertyReferenceValue::setPropertyReference(IfcObjectReferenceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcPropertyReferenceValue::declaration() const { return *IfcPropertyReferenceValue_type; }
const IfcParse::entity& IfcPropertyReferenceValue::Class() { return *IfcPropertyReferenceValue_type; }
IfcPropertyReferenceValue::IfcPropertyReferenceValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyReferenceValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyReferenceValue::IfcPropertyReferenceValue(std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UsageName, IfcObjectReferenceSelect* v4_PropertyReference) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyReferenceValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UsageName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UsageName));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_PropertyReference));data_->setArgument(3,attr);} }

// Function implementations for IfcPropertySet
IfcTemplatedEntityList< IfcProperty >::ptr IfcPropertySet::HasProperties() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcProperty>(); }
void IfcPropertySet::setHasProperties(IfcTemplatedEntityList< IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }


const IfcParse::entity& IfcPropertySet::declaration() const { return *IfcPropertySet_type; }
const IfcParse::entity& IfcPropertySet::Class() { return *IfcPropertySet_type; }
IfcPropertySet::IfcPropertySet(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertySet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertySet::IfcPropertySet(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProperty >::ptr v5_HasProperties) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertySet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_HasProperties)->generalize());data_->setArgument(4,attr);} }

// Function implementations for IfcPropertySetDefinition

IfcTypeObject::list::ptr IfcPropertySetDefinition::DefinesType() const { return data_->getInverse(IfcTypeObject_type, 5)->as<IfcTypeObject>(); }
IfcRelDefinesByTemplate::list::ptr IfcPropertySetDefinition::IsDefinedBy() const { return data_->getInverse(IfcRelDefinesByTemplate_type, 4)->as<IfcRelDefinesByTemplate>(); }
IfcRelDefinesByProperties::list::ptr IfcPropertySetDefinition::DefinesOccurrence() const { return data_->getInverse(IfcRelDefinesByProperties_type, 5)->as<IfcRelDefinesByProperties>(); }

const IfcParse::entity& IfcPropertySetDefinition::declaration() const { return *IfcPropertySetDefinition_type; }
const IfcParse::entity& IfcPropertySetDefinition::Class() { return *IfcPropertySetDefinition_type; }
IfcPropertySetDefinition::IfcPropertySetDefinition(IfcEntityInstanceData* e) : IfcPropertyDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertySetDefinition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertySetDefinition::IfcPropertySetDefinition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcPropertyDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertySetDefinition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcPropertySetTemplate
bool IfcPropertySetTemplate::hasTemplateType() const { return !data_->getArgument(4)->isNull(); }
IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum IfcPropertySetTemplate::TemplateType() const { return IfcPropertySetTemplateTypeEnum::FromString(*data_->getArgument(4)); }
void IfcPropertySetTemplate::setTemplateType(IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPropertySetTemplateTypeEnum::ToString(v)));data_->setArgument(4,attr);} }
bool IfcPropertySetTemplate::hasApplicableEntity() const { return !data_->getArgument(5)->isNull(); }
std::string IfcPropertySetTemplate::ApplicableEntity() const { return *data_->getArgument(5); }
void IfcPropertySetTemplate::setApplicableEntity(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
IfcTemplatedEntityList< IfcPropertyTemplate >::ptr IfcPropertySetTemplate::HasPropertyTemplates() const { IfcEntityList::ptr es = *data_->getArgument(6); return es->as<IfcPropertyTemplate>(); }
void IfcPropertySetTemplate::setHasPropertyTemplates(IfcTemplatedEntityList< IfcPropertyTemplate >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(6,attr);} }

IfcRelDefinesByTemplate::list::ptr IfcPropertySetTemplate::Defines() const { return data_->getInverse(IfcRelDefinesByTemplate_type, 5)->as<IfcRelDefinesByTemplate>(); }

const IfcParse::entity& IfcPropertySetTemplate::declaration() const { return *IfcPropertySetTemplate_type; }
const IfcParse::entity& IfcPropertySetTemplate::Class() { return *IfcPropertySetTemplate_type; }
IfcPropertySetTemplate::IfcPropertySetTemplate(IfcEntityInstanceData* e) : IfcPropertyTemplateDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertySetTemplate_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertySetTemplate::IfcPropertySetTemplate(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum > v5_TemplateType, boost::optional< std::string > v6_ApplicableEntity, IfcTemplatedEntityList< IfcPropertyTemplate >::ptr v7_HasPropertyTemplates) : IfcPropertyTemplateDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertySetTemplate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_TemplateType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v5_TemplateType,IfcPropertySetTemplateTypeEnum::ToString(*v5_TemplateType))));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ApplicableEntity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ApplicableEntity));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_HasPropertyTemplates)->generalize());data_->setArgument(6,attr);} }

// Function implementations for IfcPropertySingleValue
bool IfcPropertySingleValue::hasNominalValue() const { return !data_->getArgument(2)->isNull(); }
IfcValue* IfcPropertySingleValue::NominalValue() const { return (IfcValue*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcPropertySingleValue::setNominalValue(IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcPropertySingleValue::hasUnit() const { return !data_->getArgument(3)->isNull(); }
IfcUnit* IfcPropertySingleValue::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcPropertySingleValue::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcPropertySingleValue::declaration() const { return *IfcPropertySingleValue_type; }
const IfcParse::entity& IfcPropertySingleValue::Class() { return *IfcPropertySingleValue_type; }
IfcPropertySingleValue::IfcPropertySingleValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertySingleValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertySingleValue::IfcPropertySingleValue(std::string v1_Name, boost::optional< std::string > v2_Description, IfcValue* v3_NominalValue, IfcUnit* v4_Unit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertySingleValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_NominalValue));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Unit));data_->setArgument(3,attr);} }

// Function implementations for IfcPropertyTableValue
bool IfcPropertyTableValue::hasDefiningValues() const { return !data_->getArgument(2)->isNull(); }
IfcEntityList::ptr IfcPropertyTableValue::DefiningValues() const { return *data_->getArgument(2); }
void IfcPropertyTableValue::setDefiningValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcPropertyTableValue::hasDefinedValues() const { return !data_->getArgument(3)->isNull(); }
IfcEntityList::ptr IfcPropertyTableValue::DefinedValues() const { return *data_->getArgument(3); }
void IfcPropertyTableValue::setDefinedValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcPropertyTableValue::hasExpression() const { return !data_->getArgument(4)->isNull(); }
std::string IfcPropertyTableValue::Expression() const { return *data_->getArgument(4); }
void IfcPropertyTableValue::setExpression(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcPropertyTableValue::hasDefiningUnit() const { return !data_->getArgument(5)->isNull(); }
IfcUnit* IfcPropertyTableValue::DefiningUnit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcPropertyTableValue::setDefiningUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcPropertyTableValue::hasDefinedUnit() const { return !data_->getArgument(6)->isNull(); }
IfcUnit* IfcPropertyTableValue::DefinedUnit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcPropertyTableValue::setDefinedUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcPropertyTableValue::hasCurveInterpolation() const { return !data_->getArgument(7)->isNull(); }
IfcCurveInterpolationEnum::IfcCurveInterpolationEnum IfcPropertyTableValue::CurveInterpolation() const { return IfcCurveInterpolationEnum::FromString(*data_->getArgument(7)); }
void IfcPropertyTableValue::setCurveInterpolation(IfcCurveInterpolationEnum::IfcCurveInterpolationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCurveInterpolationEnum::ToString(v)));data_->setArgument(7,attr);} }


const IfcParse::entity& IfcPropertyTableValue::declaration() const { return *IfcPropertyTableValue_type; }
const IfcParse::entity& IfcPropertyTableValue::Class() { return *IfcPropertyTableValue_type; }
IfcPropertyTableValue::IfcPropertyTableValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyTableValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyTableValue::IfcPropertyTableValue(std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< IfcEntityList::ptr > v3_DefiningValues, boost::optional< IfcEntityList::ptr > v4_DefinedValues, boost::optional< std::string > v5_Expression, IfcUnit* v6_DefiningUnit, IfcUnit* v7_DefinedUnit, boost::optional< IfcCurveInterpolationEnum::IfcCurveInterpolationEnum > v8_CurveInterpolation) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyTableValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_DefiningValues) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DefiningValues));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DefinedValues) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DefinedValues));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Expression) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Expression));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_DefiningUnit));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_DefinedUnit));data_->setArgument(6,attr);} if (v8_CurveInterpolation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_CurveInterpolation,IfcCurveInterpolationEnum::ToString(*v8_CurveInterpolation))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcPropertyTemplate

IfcComplexPropertyTemplate::list::ptr IfcPropertyTemplate::PartOfComplexTemplate() const { return data_->getInverse(IfcComplexPropertyTemplate_type, 6)->as<IfcComplexPropertyTemplate>(); }
IfcPropertySetTemplate::list::ptr IfcPropertyTemplate::PartOfPsetTemplate() const { return data_->getInverse(IfcPropertySetTemplate_type, 6)->as<IfcPropertySetTemplate>(); }

const IfcParse::entity& IfcPropertyTemplate::declaration() const { return *IfcPropertyTemplate_type; }
const IfcParse::entity& IfcPropertyTemplate::Class() { return *IfcPropertyTemplate_type; }
IfcPropertyTemplate::IfcPropertyTemplate(IfcEntityInstanceData* e) : IfcPropertyTemplateDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyTemplate_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyTemplate::IfcPropertyTemplate(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcPropertyTemplateDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyTemplate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcPropertyTemplateDefinition


const IfcParse::entity& IfcPropertyTemplateDefinition::declaration() const { return *IfcPropertyTemplateDefinition_type; }
const IfcParse::entity& IfcPropertyTemplateDefinition::Class() { return *IfcPropertyTemplateDefinition_type; }
IfcPropertyTemplateDefinition::IfcPropertyTemplateDefinition(IfcEntityInstanceData* e) : IfcPropertyDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPropertyTemplateDefinition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPropertyTemplateDefinition::IfcPropertyTemplateDefinition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcPropertyDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPropertyTemplateDefinition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcProtectiveDevice
bool IfcProtectiveDevice::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum IfcProtectiveDevice::PredefinedType() const { return IfcProtectiveDeviceTypeEnum::FromString(*data_->getArgument(8)); }
void IfcProtectiveDevice::setPredefinedType(IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProtectiveDeviceTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcProtectiveDevice::declaration() const { return *IfcProtectiveDevice_type; }
const IfcParse::entity& IfcProtectiveDevice::Class() { return *IfcProtectiveDevice_type; }
IfcProtectiveDevice::IfcProtectiveDevice(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProtectiveDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProtectiveDevice::IfcProtectiveDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum > v9_PredefinedType) : IfcFlowController((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProtectiveDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcProtectiveDeviceTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcProtectiveDeviceTrippingUnit
bool IfcProtectiveDeviceTrippingUnit::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum IfcProtectiveDeviceTrippingUnit::PredefinedType() const { return IfcProtectiveDeviceTrippingUnitTypeEnum::FromString(*data_->getArgument(8)); }
void IfcProtectiveDeviceTrippingUnit::setPredefinedType(IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcProtectiveDeviceTrippingUnit::declaration() const { return *IfcProtectiveDeviceTrippingUnit_type; }
const IfcParse::entity& IfcProtectiveDeviceTrippingUnit::Class() { return *IfcProtectiveDeviceTrippingUnit_type; }
IfcProtectiveDeviceTrippingUnit::IfcProtectiveDeviceTrippingUnit(IfcEntityInstanceData* e) : IfcDistributionControlElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProtectiveDeviceTrippingUnit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProtectiveDeviceTrippingUnit::IfcProtectiveDeviceTrippingUnit(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProtectiveDeviceTrippingUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcProtectiveDeviceTrippingUnitType
IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum IfcProtectiveDeviceTrippingUnitType::PredefinedType() const { return IfcProtectiveDeviceTrippingUnitTypeEnum::FromString(*data_->getArgument(9)); }
void IfcProtectiveDeviceTrippingUnitType::setPredefinedType(IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcProtectiveDeviceTrippingUnitType::declaration() const { return *IfcProtectiveDeviceTrippingUnitType_type; }
const IfcParse::entity& IfcProtectiveDeviceTrippingUnitType::Class() { return *IfcProtectiveDeviceTrippingUnitType_type; }
IfcProtectiveDeviceTrippingUnitType::IfcProtectiveDeviceTrippingUnitType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProtectiveDeviceTrippingUnitType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProtectiveDeviceTrippingUnitType::IfcProtectiveDeviceTrippingUnitType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProtectiveDeviceTrippingUnitType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcProtectiveDeviceType
IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum IfcProtectiveDeviceType::PredefinedType() const { return IfcProtectiveDeviceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcProtectiveDeviceType::setPredefinedType(IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProtectiveDeviceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcProtectiveDeviceType::declaration() const { return *IfcProtectiveDeviceType_type; }
const IfcParse::entity& IfcProtectiveDeviceType::Class() { return *IfcProtectiveDeviceType_type; }
IfcProtectiveDeviceType::IfcProtectiveDeviceType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProtectiveDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProtectiveDeviceType::IfcProtectiveDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProtectiveDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcProtectiveDeviceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcProxy
IfcObjectTypeEnum::IfcObjectTypeEnum IfcProxy::ProxyType() const { return IfcObjectTypeEnum::FromString(*data_->getArgument(7)); }
void IfcProxy::setProxyType(IfcObjectTypeEnum::IfcObjectTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcObjectTypeEnum::ToString(v)));data_->setArgument(7,attr);} }
bool IfcProxy::hasTag() const { return !data_->getArgument(8)->isNull(); }
std::string IfcProxy::Tag() const { return *data_->getArgument(8); }
void IfcProxy::setTag(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcProxy::declaration() const { return *IfcProxy_type; }
const IfcParse::entity& IfcProxy::Class() { return *IfcProxy_type; }
IfcProxy::IfcProxy(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcProxy_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcProxy::IfcProxy(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcObjectTypeEnum::IfcObjectTypeEnum v8_ProxyType, boost::optional< std::string > v9_Tag) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcProxy_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_ProxyType,IfcObjectTypeEnum::ToString(v8_ProxyType))));data_->setArgument(7,attr);} if (v9_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Tag));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcPump
bool IfcPump::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcPumpTypeEnum::IfcPumpTypeEnum IfcPump::PredefinedType() const { return IfcPumpTypeEnum::FromString(*data_->getArgument(8)); }
void IfcPump::setPredefinedType(IfcPumpTypeEnum::IfcPumpTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPumpTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcPump::declaration() const { return *IfcPump_type; }
const IfcParse::entity& IfcPump::Class() { return *IfcPump_type; }
IfcPump::IfcPump(IfcEntityInstanceData* e) : IfcFlowMovingDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPump_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPump::IfcPump(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPumpTypeEnum::IfcPumpTypeEnum > v9_PredefinedType) : IfcFlowMovingDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPump_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcPumpTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcPumpType
IfcPumpTypeEnum::IfcPumpTypeEnum IfcPumpType::PredefinedType() const { return IfcPumpTypeEnum::FromString(*data_->getArgument(9)); }
void IfcPumpType::setPredefinedType(IfcPumpTypeEnum::IfcPumpTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPumpTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcPumpType::declaration() const { return *IfcPumpType_type; }
const IfcParse::entity& IfcPumpType::Class() { return *IfcPumpType_type; }
IfcPumpType::IfcPumpType(IfcEntityInstanceData* e) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcPumpType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcPumpType::IfcPumpType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPumpTypeEnum::IfcPumpTypeEnum v10_PredefinedType) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcPumpType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcPumpTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcQuantityArea
double IfcQuantityArea::AreaValue() const { return *data_->getArgument(3); }
void IfcQuantityArea::setAreaValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcQuantityArea::hasFormula() const { return !data_->getArgument(4)->isNull(); }
std::string IfcQuantityArea::Formula() const { return *data_->getArgument(4); }
void IfcQuantityArea::setFormula(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcQuantityArea::declaration() const { return *IfcQuantityArea_type; }
const IfcParse::entity& IfcQuantityArea::Class() { return *IfcQuantityArea_type; }
IfcQuantityArea::IfcQuantityArea(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcQuantityArea_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcQuantityArea::IfcQuantityArea(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_AreaValue, boost::optional< std::string > v5_Formula) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcQuantityArea_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_AreaValue));data_->setArgument(3,attr);} if (v5_Formula) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Formula));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcQuantityCount
double IfcQuantityCount::CountValue() const { return *data_->getArgument(3); }
void IfcQuantityCount::setCountValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcQuantityCount::hasFormula() const { return !data_->getArgument(4)->isNull(); }
std::string IfcQuantityCount::Formula() const { return *data_->getArgument(4); }
void IfcQuantityCount::setFormula(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcQuantityCount::declaration() const { return *IfcQuantityCount_type; }
const IfcParse::entity& IfcQuantityCount::Class() { return *IfcQuantityCount_type; }
IfcQuantityCount::IfcQuantityCount(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcQuantityCount_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcQuantityCount::IfcQuantityCount(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_CountValue, boost::optional< std::string > v5_Formula) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcQuantityCount_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_CountValue));data_->setArgument(3,attr);} if (v5_Formula) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Formula));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcQuantityLength
double IfcQuantityLength::LengthValue() const { return *data_->getArgument(3); }
void IfcQuantityLength::setLengthValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcQuantityLength::hasFormula() const { return !data_->getArgument(4)->isNull(); }
std::string IfcQuantityLength::Formula() const { return *data_->getArgument(4); }
void IfcQuantityLength::setFormula(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcQuantityLength::declaration() const { return *IfcQuantityLength_type; }
const IfcParse::entity& IfcQuantityLength::Class() { return *IfcQuantityLength_type; }
IfcQuantityLength::IfcQuantityLength(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcQuantityLength_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcQuantityLength::IfcQuantityLength(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_LengthValue, boost::optional< std::string > v5_Formula) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcQuantityLength_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LengthValue));data_->setArgument(3,attr);} if (v5_Formula) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Formula));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcQuantitySet


const IfcParse::entity& IfcQuantitySet::declaration() const { return *IfcQuantitySet_type; }
const IfcParse::entity& IfcQuantitySet::Class() { return *IfcQuantitySet_type; }
IfcQuantitySet::IfcQuantitySet(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcQuantitySet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcQuantitySet::IfcQuantitySet(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcQuantitySet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcQuantityTime
double IfcQuantityTime::TimeValue() const { return *data_->getArgument(3); }
void IfcQuantityTime::setTimeValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcQuantityTime::hasFormula() const { return !data_->getArgument(4)->isNull(); }
std::string IfcQuantityTime::Formula() const { return *data_->getArgument(4); }
void IfcQuantityTime::setFormula(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcQuantityTime::declaration() const { return *IfcQuantityTime_type; }
const IfcParse::entity& IfcQuantityTime::Class() { return *IfcQuantityTime_type; }
IfcQuantityTime::IfcQuantityTime(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcQuantityTime_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcQuantityTime::IfcQuantityTime(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_TimeValue, boost::optional< std::string > v5_Formula) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcQuantityTime_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TimeValue));data_->setArgument(3,attr);} if (v5_Formula) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Formula));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcQuantityVolume
double IfcQuantityVolume::VolumeValue() const { return *data_->getArgument(3); }
void IfcQuantityVolume::setVolumeValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcQuantityVolume::hasFormula() const { return !data_->getArgument(4)->isNull(); }
std::string IfcQuantityVolume::Formula() const { return *data_->getArgument(4); }
void IfcQuantityVolume::setFormula(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcQuantityVolume::declaration() const { return *IfcQuantityVolume_type; }
const IfcParse::entity& IfcQuantityVolume::Class() { return *IfcQuantityVolume_type; }
IfcQuantityVolume::IfcQuantityVolume(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcQuantityVolume_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcQuantityVolume::IfcQuantityVolume(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_VolumeValue, boost::optional< std::string > v5_Formula) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcQuantityVolume_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_VolumeValue));data_->setArgument(3,attr);} if (v5_Formula) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Formula));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcQuantityWeight
double IfcQuantityWeight::WeightValue() const { return *data_->getArgument(3); }
void IfcQuantityWeight::setWeightValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcQuantityWeight::hasFormula() const { return !data_->getArgument(4)->isNull(); }
std::string IfcQuantityWeight::Formula() const { return *data_->getArgument(4); }
void IfcQuantityWeight::setFormula(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcQuantityWeight::declaration() const { return *IfcQuantityWeight_type; }
const IfcParse::entity& IfcQuantityWeight::Class() { return *IfcQuantityWeight_type; }
IfcQuantityWeight::IfcQuantityWeight(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcQuantityWeight_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcQuantityWeight::IfcQuantityWeight(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_WeightValue, boost::optional< std::string > v5_Formula) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcQuantityWeight_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_WeightValue));data_->setArgument(3,attr);} if (v5_Formula) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Formula));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcRailing
bool IfcRailing::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcRailingTypeEnum::IfcRailingTypeEnum IfcRailing::PredefinedType() const { return IfcRailingTypeEnum::FromString(*data_->getArgument(8)); }
void IfcRailing::setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRailingTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcRailing::declaration() const { return *IfcRailing_type; }
const IfcParse::entity& IfcRailing::Class() { return *IfcRailing_type; }
IfcRailing::IfcRailing(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRailing_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRailing::IfcRailing(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRailingTypeEnum::IfcRailingTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRailing_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcRailingTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcRailingType
IfcRailingTypeEnum::IfcRailingTypeEnum IfcRailingType::PredefinedType() const { return IfcRailingTypeEnum::FromString(*data_->getArgument(9)); }
void IfcRailingType::setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRailingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcRailingType::declaration() const { return *IfcRailingType_type; }
const IfcParse::entity& IfcRailingType::Class() { return *IfcRailingType_type; }
IfcRailingType::IfcRailingType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRailingType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRailingType::IfcRailingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRailingTypeEnum::IfcRailingTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRailingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcRailingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcRamp
bool IfcRamp::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcRampTypeEnum::IfcRampTypeEnum IfcRamp::PredefinedType() const { return IfcRampTypeEnum::FromString(*data_->getArgument(8)); }
void IfcRamp::setPredefinedType(IfcRampTypeEnum::IfcRampTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRampTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcRamp::declaration() const { return *IfcRamp_type; }
const IfcParse::entity& IfcRamp::Class() { return *IfcRamp_type; }
IfcRamp::IfcRamp(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRamp_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRamp::IfcRamp(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRampTypeEnum::IfcRampTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRamp_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcRampTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcRampFlight
bool IfcRampFlight::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcRampFlightTypeEnum::IfcRampFlightTypeEnum IfcRampFlight::PredefinedType() const { return IfcRampFlightTypeEnum::FromString(*data_->getArgument(8)); }
void IfcRampFlight::setPredefinedType(IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRampFlightTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcRampFlight::declaration() const { return *IfcRampFlight_type; }
const IfcParse::entity& IfcRampFlight::Class() { return *IfcRampFlight_type; }
IfcRampFlight::IfcRampFlight(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRampFlight_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRampFlight::IfcRampFlight(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRampFlightTypeEnum::IfcRampFlightTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRampFlight_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcRampFlightTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcRampFlightType
IfcRampFlightTypeEnum::IfcRampFlightTypeEnum IfcRampFlightType::PredefinedType() const { return IfcRampFlightTypeEnum::FromString(*data_->getArgument(9)); }
void IfcRampFlightType::setPredefinedType(IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRampFlightTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcRampFlightType::declaration() const { return *IfcRampFlightType_type; }
const IfcParse::entity& IfcRampFlightType::Class() { return *IfcRampFlightType_type; }
IfcRampFlightType::IfcRampFlightType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRampFlightType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRampFlightType::IfcRampFlightType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRampFlightType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcRampFlightTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcRampType
IfcRampTypeEnum::IfcRampTypeEnum IfcRampType::PredefinedType() const { return IfcRampTypeEnum::FromString(*data_->getArgument(9)); }
void IfcRampType::setPredefinedType(IfcRampTypeEnum::IfcRampTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRampTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcRampType::declaration() const { return *IfcRampType_type; }
const IfcParse::entity& IfcRampType::Class() { return *IfcRampType_type; }
IfcRampType::IfcRampType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRampType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRampType::IfcRampType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRampTypeEnum::IfcRampTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRampType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcRampTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcRationalBSplineCurveWithKnots
std::vector< double > /*[2:?]*/ IfcRationalBSplineCurveWithKnots::WeightsData() const { return *data_->getArgument(8); }
void IfcRationalBSplineCurveWithKnots::setWeightsData(std::vector< double > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcRationalBSplineCurveWithKnots::declaration() const { return *IfcRationalBSplineCurveWithKnots_type; }
const IfcParse::entity& IfcRationalBSplineCurveWithKnots::Class() { return *IfcRationalBSplineCurveWithKnots_type; }
IfcRationalBSplineCurveWithKnots::IfcRationalBSplineCurveWithKnots(IfcEntityInstanceData* e) : IfcBSplineCurveWithKnots((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRationalBSplineCurveWithKnots_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRationalBSplineCurveWithKnots::IfcRationalBSplineCurveWithKnots(int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect, std::vector< int > /*[2:?]*/ v6_KnotMultiplicities, std::vector< double > /*[2:?]*/ v7_Knots, IfcKnotType::IfcKnotType v8_KnotSpec, std::vector< double > /*[2:?]*/ v9_WeightsData) : IfcBSplineCurveWithKnots((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRationalBSplineCurveWithKnots_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Degree));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ControlPointsList)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_CurveForm,IfcBSplineCurveForm::ToString(v3_CurveForm))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ClosedCurve));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SelfIntersect));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_KnotMultiplicities));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Knots));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_KnotSpec,IfcKnotType::ToString(v8_KnotSpec))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_WeightsData));data_->setArgument(8,attr);} }

// Function implementations for IfcRationalBSplineSurfaceWithKnots
std::vector< std::vector< double > > IfcRationalBSplineSurfaceWithKnots::WeightsData() const { return *data_->getArgument(12); }
void IfcRationalBSplineSurfaceWithKnots::setWeightsData(std::vector< std::vector< double > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& IfcRationalBSplineSurfaceWithKnots::declaration() const { return *IfcRationalBSplineSurfaceWithKnots_type; }
const IfcParse::entity& IfcRationalBSplineSurfaceWithKnots::Class() { return *IfcRationalBSplineSurfaceWithKnots_type; }
IfcRationalBSplineSurfaceWithKnots::IfcRationalBSplineSurfaceWithKnots(IfcEntityInstanceData* e) : IfcBSplineSurfaceWithKnots((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRationalBSplineSurfaceWithKnots_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRationalBSplineSurfaceWithKnots::IfcRationalBSplineSurfaceWithKnots(int v1_UDegree, int v2_VDegree, IfcTemplatedEntityListList< IfcCartesianPoint >::ptr v3_ControlPointsList, IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v4_SurfaceForm, bool v5_UClosed, bool v6_VClosed, bool v7_SelfIntersect, std::vector< int > /*[2:?]*/ v8_UMultiplicities, std::vector< int > /*[2:?]*/ v9_VMultiplicities, std::vector< double > /*[2:?]*/ v10_UKnots, std::vector< double > /*[2:?]*/ v11_VKnots, IfcKnotType::IfcKnotType v12_KnotSpec, std::vector< std::vector< double > > v13_WeightsData) : IfcBSplineSurfaceWithKnots((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRationalBSplineSurfaceWithKnots_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_UDegree));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_VDegree));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ControlPointsList)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_SurfaceForm,IfcBSplineSurfaceForm::ToString(v4_SurfaceForm))));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_UClosed));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_VClosed));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SelfIntersect));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_UMultiplicities));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_VMultiplicities));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_UKnots));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_VKnots));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_KnotSpec,IfcKnotType::ToString(v12_KnotSpec))));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_WeightsData));data_->setArgument(12,attr);} }

// Function implementations for IfcRectangleHollowProfileDef
double IfcRectangleHollowProfileDef::WallThickness() const { return *data_->getArgument(5); }
void IfcRectangleHollowProfileDef::setWallThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcRectangleHollowProfileDef::hasInnerFilletRadius() const { return !data_->getArgument(6)->isNull(); }
double IfcRectangleHollowProfileDef::InnerFilletRadius() const { return *data_->getArgument(6); }
void IfcRectangleHollowProfileDef::setInnerFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcRectangleHollowProfileDef::hasOuterFilletRadius() const { return !data_->getArgument(7)->isNull(); }
double IfcRectangleHollowProfileDef::OuterFilletRadius() const { return *data_->getArgument(7); }
void IfcRectangleHollowProfileDef::setOuterFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcRectangleHollowProfileDef::declaration() const { return *IfcRectangleHollowProfileDef_type; }
const IfcParse::entity& IfcRectangleHollowProfileDef::Class() { return *IfcRectangleHollowProfileDef_type; }
IfcRectangleHollowProfileDef::IfcRectangleHollowProfileDef(IfcEntityInstanceData* e) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRectangleHollowProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRectangleHollowProfileDef::IfcRectangleHollowProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_WallThickness, boost::optional< double > v7_InnerFilletRadius, boost::optional< double > v8_OuterFilletRadius) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRectangleHollowProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_XDim));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_YDim));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WallThickness));data_->setArgument(5,attr);} if (v7_InnerFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_InnerFilletRadius));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_OuterFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_OuterFilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcRectangleProfileDef
double IfcRectangleProfileDef::XDim() const { return *data_->getArgument(3); }
void IfcRectangleProfileDef::setXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcRectangleProfileDef::YDim() const { return *data_->getArgument(4); }
void IfcRectangleProfileDef::setYDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcRectangleProfileDef::declaration() const { return *IfcRectangleProfileDef_type; }
const IfcParse::entity& IfcRectangleProfileDef::Class() { return *IfcRectangleProfileDef_type; }
IfcRectangleProfileDef::IfcRectangleProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRectangleProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRectangleProfileDef::IfcRectangleProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRectangleProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_XDim));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_YDim));data_->setArgument(4,attr);} }

// Function implementations for IfcRectangularPyramid
double IfcRectangularPyramid::XLength() const { return *data_->getArgument(1); }
void IfcRectangularPyramid::setXLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcRectangularPyramid::YLength() const { return *data_->getArgument(2); }
void IfcRectangularPyramid::setYLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double IfcRectangularPyramid::Height() const { return *data_->getArgument(3); }
void IfcRectangularPyramid::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcRectangularPyramid::declaration() const { return *IfcRectangularPyramid_type; }
const IfcParse::entity& IfcRectangularPyramid::Class() { return *IfcRectangularPyramid_type; }
IfcRectangularPyramid::IfcRectangularPyramid(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRectangularPyramid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRectangularPyramid::IfcRectangularPyramid(IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_Height) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRectangularPyramid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_XLength));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YLength));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Height));data_->setArgument(3,attr);} }

// Function implementations for IfcRectangularTrimmedSurface
IfcSurface* IfcRectangularTrimmedSurface::BasisSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcRectangularTrimmedSurface::setBasisSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcRectangularTrimmedSurface::U1() const { return *data_->getArgument(1); }
void IfcRectangularTrimmedSurface::setU1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcRectangularTrimmedSurface::V1() const { return *data_->getArgument(2); }
void IfcRectangularTrimmedSurface::setV1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double IfcRectangularTrimmedSurface::U2() const { return *data_->getArgument(3); }
void IfcRectangularTrimmedSurface::setU2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcRectangularTrimmedSurface::V2() const { return *data_->getArgument(4); }
void IfcRectangularTrimmedSurface::setV2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcRectangularTrimmedSurface::Usense() const { return *data_->getArgument(5); }
void IfcRectangularTrimmedSurface::setUsense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcRectangularTrimmedSurface::Vsense() const { return *data_->getArgument(6); }
void IfcRectangularTrimmedSurface::setVsense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcRectangularTrimmedSurface::declaration() const { return *IfcRectangularTrimmedSurface_type; }
const IfcParse::entity& IfcRectangularTrimmedSurface::Class() { return *IfcRectangularTrimmedSurface_type; }
IfcRectangularTrimmedSurface::IfcRectangularTrimmedSurface(IfcEntityInstanceData* e) : IfcBoundedSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRectangularTrimmedSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRectangularTrimmedSurface::IfcRectangularTrimmedSurface(IfcSurface* v1_BasisSurface, double v2_U1, double v3_V1, double v4_U2, double v5_V2, bool v6_Usense, bool v7_Vsense) : IfcBoundedSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRectangularTrimmedSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_U1));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_V1));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_U2));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_V2));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Usense));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Vsense));data_->setArgument(6,attr);} }

// Function implementations for IfcRecurrencePattern
IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum IfcRecurrencePattern::RecurrenceType() const { return IfcRecurrenceTypeEnum::FromString(*data_->getArgument(0)); }
void IfcRecurrencePattern::setRecurrenceType(IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRecurrenceTypeEnum::ToString(v)));data_->setArgument(0,attr);} }
bool IfcRecurrencePattern::hasDayComponent() const { return !data_->getArgument(1)->isNull(); }
std::vector< int > /*[1:?]*/ IfcRecurrencePattern::DayComponent() const { return *data_->getArgument(1); }
void IfcRecurrencePattern::setDayComponent(std::vector< int > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcRecurrencePattern::hasWeekdayComponent() const { return !data_->getArgument(2)->isNull(); }
std::vector< int > /*[1:?]*/ IfcRecurrencePattern::WeekdayComponent() const { return *data_->getArgument(2); }
void IfcRecurrencePattern::setWeekdayComponent(std::vector< int > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcRecurrencePattern::hasMonthComponent() const { return !data_->getArgument(3)->isNull(); }
std::vector< int > /*[1:?]*/ IfcRecurrencePattern::MonthComponent() const { return *data_->getArgument(3); }
void IfcRecurrencePattern::setMonthComponent(std::vector< int > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcRecurrencePattern::hasPosition() const { return !data_->getArgument(4)->isNull(); }
int IfcRecurrencePattern::Position() const { return *data_->getArgument(4); }
void IfcRecurrencePattern::setPosition(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcRecurrencePattern::hasInterval() const { return !data_->getArgument(5)->isNull(); }
int IfcRecurrencePattern::Interval() const { return *data_->getArgument(5); }
void IfcRecurrencePattern::setInterval(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcRecurrencePattern::hasOccurrences() const { return !data_->getArgument(6)->isNull(); }
int IfcRecurrencePattern::Occurrences() const { return *data_->getArgument(6); }
void IfcRecurrencePattern::setOccurrences(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcRecurrencePattern::hasTimePeriods() const { return !data_->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcTimePeriod >::ptr IfcRecurrencePattern::TimePeriods() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcTimePeriod>(); }
void IfcRecurrencePattern::setTimePeriods(IfcTemplatedEntityList< IfcTimePeriod >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }


const IfcParse::entity& IfcRecurrencePattern::declaration() const { return *IfcRecurrencePattern_type; }
const IfcParse::entity& IfcRecurrencePattern::Class() { return *IfcRecurrencePattern_type; }
IfcRecurrencePattern::IfcRecurrencePattern(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcRecurrencePattern_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRecurrencePattern::IfcRecurrencePattern(IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum v1_RecurrenceType, boost::optional< std::vector< int > /*[1:?]*/ > v2_DayComponent, boost::optional< std::vector< int > /*[1:?]*/ > v3_WeekdayComponent, boost::optional< std::vector< int > /*[1:?]*/ > v4_MonthComponent, boost::optional< int > v5_Position, boost::optional< int > v6_Interval, boost::optional< int > v7_Occurrences, boost::optional< IfcTemplatedEntityList< IfcTimePeriod >::ptr > v8_TimePeriods) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcRecurrencePattern_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_RecurrenceType,IfcRecurrenceTypeEnum::ToString(v1_RecurrenceType))));data_->setArgument(0,attr);} if (v2_DayComponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DayComponent));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_WeekdayComponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_WeekdayComponent));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_MonthComponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_MonthComponent));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Position) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Position));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Interval) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Interval));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Occurrences) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Occurrences));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_TimePeriods) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_TimePeriods)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcReference
bool IfcReference::hasTypeIdentifier() const { return !data_->getArgument(0)->isNull(); }
std::string IfcReference::TypeIdentifier() const { return *data_->getArgument(0); }
void IfcReference::setTypeIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcReference::hasAttributeIdentifier() const { return !data_->getArgument(1)->isNull(); }
std::string IfcReference::AttributeIdentifier() const { return *data_->getArgument(1); }
void IfcReference::setAttributeIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcReference::hasInstanceName() const { return !data_->getArgument(2)->isNull(); }
std::string IfcReference::InstanceName() const { return *data_->getArgument(2); }
void IfcReference::setInstanceName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcReference::hasListPositions() const { return !data_->getArgument(3)->isNull(); }
std::vector< int > /*[1:?]*/ IfcReference::ListPositions() const { return *data_->getArgument(3); }
void IfcReference::setListPositions(std::vector< int > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcReference::hasInnerReference() const { return !data_->getArgument(4)->isNull(); }
IfcReference* IfcReference::InnerReference() const { return (IfcReference*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcReference::setInnerReference(IfcReference* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcReference::declaration() const { return *IfcReference_type; }
const IfcParse::entity& IfcReference::Class() { return *IfcReference_type; }
IfcReference::IfcReference(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcReference_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReference::IfcReference(boost::optional< std::string > v1_TypeIdentifier, boost::optional< std::string > v2_AttributeIdentifier, boost::optional< std::string > v3_InstanceName, boost::optional< std::vector< int > /*[1:?]*/ > v4_ListPositions, IfcReference* v5_InnerReference) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcReference_type);  if (v1_TypeIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_TypeIdentifier));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_AttributeIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_AttributeIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_InstanceName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_InstanceName));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ListPositions) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ListPositions));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_InnerReference));data_->setArgument(4,attr);} }

// Function implementations for IfcRegularTimeSeries
double IfcRegularTimeSeries::TimeStep() const { return *data_->getArgument(8); }
void IfcRegularTimeSeries::setTimeStep(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr IfcRegularTimeSeries::Values() const { IfcEntityList::ptr es = *data_->getArgument(9); return es->as<IfcTimeSeriesValue>(); }
void IfcRegularTimeSeries::setValues(IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(9,attr);} }


const IfcParse::entity& IfcRegularTimeSeries::declaration() const { return *IfcRegularTimeSeries_type; }
const IfcParse::entity& IfcRegularTimeSeries::Class() { return *IfcRegularTimeSeries_type; }
IfcRegularTimeSeries::IfcRegularTimeSeries(IfcEntityInstanceData* e) : IfcTimeSeries((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRegularTimeSeries_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRegularTimeSeries::IfcRegularTimeSeries(std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_StartTime, std::string v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit, double v9_TimeStep, IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr v10_Values) : IfcTimeSeries((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRegularTimeSeries_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_StartTime));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EndTime));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_TimeSeriesDataType,IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_DataOrigin,IfcDataOriginEnum::ToString(v6_DataOrigin))));data_->setArgument(5,attr);} if (v7_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedDataOrigin));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Unit));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_TimeStep));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_Values)->generalize());data_->setArgument(9,attr);} }

// Function implementations for IfcReinforcementBarProperties
double IfcReinforcementBarProperties::TotalCrossSectionArea() const { return *data_->getArgument(0); }
void IfcReinforcementBarProperties::setTotalCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::string IfcReinforcementBarProperties::SteelGrade() const { return *data_->getArgument(1); }
void IfcReinforcementBarProperties::setSteelGrade(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcReinforcementBarProperties::hasBarSurface() const { return !data_->getArgument(2)->isNull(); }
IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcementBarProperties::BarSurface() const { return IfcReinforcingBarSurfaceEnum::FromString(*data_->getArgument(2)); }
void IfcReinforcementBarProperties::setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarSurfaceEnum::ToString(v)));data_->setArgument(2,attr);} }
bool IfcReinforcementBarProperties::hasEffectiveDepth() const { return !data_->getArgument(3)->isNull(); }
double IfcReinforcementBarProperties::EffectiveDepth() const { return *data_->getArgument(3); }
void IfcReinforcementBarProperties::setEffectiveDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcReinforcementBarProperties::hasNominalBarDiameter() const { return !data_->getArgument(4)->isNull(); }
double IfcReinforcementBarProperties::NominalBarDiameter() const { return *data_->getArgument(4); }
void IfcReinforcementBarProperties::setNominalBarDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcReinforcementBarProperties::hasBarCount() const { return !data_->getArgument(5)->isNull(); }
double IfcReinforcementBarProperties::BarCount() const { return *data_->getArgument(5); }
void IfcReinforcementBarProperties::setBarCount(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcReinforcementBarProperties::declaration() const { return *IfcReinforcementBarProperties_type; }
const IfcParse::entity& IfcReinforcementBarProperties::Class() { return *IfcReinforcementBarProperties_type; }
IfcReinforcementBarProperties::IfcReinforcementBarProperties(IfcEntityInstanceData* e) : IfcPreDefinedProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcReinforcementBarProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReinforcementBarProperties::IfcReinforcementBarProperties(double v1_TotalCrossSectionArea, std::string v2_SteelGrade, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v3_BarSurface, boost::optional< double > v4_EffectiveDepth, boost::optional< double > v5_NominalBarDiameter, boost::optional< double > v6_BarCount) : IfcPreDefinedProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcReinforcementBarProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TotalCrossSectionArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SteelGrade));data_->setArgument(1,attr);} if (v3_BarSurface) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v3_BarSurface,IfcReinforcingBarSurfaceEnum::ToString(*v3_BarSurface))));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_EffectiveDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_EffectiveDepth));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_NominalBarDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_NominalBarDiameter));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_BarCount) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_BarCount));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcReinforcementDefinitionProperties
bool IfcReinforcementDefinitionProperties::hasDefinitionType() const { return !data_->getArgument(4)->isNull(); }
std::string IfcReinforcementDefinitionProperties::DefinitionType() const { return *data_->getArgument(4); }
void IfcReinforcementDefinitionProperties::setDefinitionType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr IfcReinforcementDefinitionProperties::ReinforcementSectionDefinitions() const { IfcEntityList::ptr es = *data_->getArgument(5); return es->as<IfcSectionReinforcementProperties>(); }
void IfcReinforcementDefinitionProperties::setReinforcementSectionDefinitions(IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& IfcReinforcementDefinitionProperties::declaration() const { return *IfcReinforcementDefinitionProperties_type; }
const IfcParse::entity& IfcReinforcementDefinitionProperties::Class() { return *IfcReinforcementDefinitionProperties_type; }
IfcReinforcementDefinitionProperties::IfcReinforcementDefinitionProperties(IfcEntityInstanceData* e) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcReinforcementDefinitionProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReinforcementDefinitionProperties::IfcReinforcementDefinitionProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_DefinitionType, IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr v6_ReinforcementSectionDefinitions) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcReinforcementDefinitionProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_DefinitionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_DefinitionType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReinforcementSectionDefinitions)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcReinforcingBar
bool IfcReinforcingBar::hasNominalDiameter() const { return !data_->getArgument(9)->isNull(); }
double IfcReinforcingBar::NominalDiameter() const { return *data_->getArgument(9); }
void IfcReinforcingBar::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcReinforcingBar::hasCrossSectionArea() const { return !data_->getArgument(10)->isNull(); }
double IfcReinforcingBar::CrossSectionArea() const { return *data_->getArgument(10); }
void IfcReinforcingBar::setCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcReinforcingBar::hasBarLength() const { return !data_->getArgument(11)->isNull(); }
double IfcReinforcingBar::BarLength() const { return *data_->getArgument(11); }
void IfcReinforcingBar::setBarLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcReinforcingBar::hasPredefinedType() const { return !data_->getArgument(12)->isNull(); }
IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum IfcReinforcingBar::PredefinedType() const { return IfcReinforcingBarTypeEnum::FromString(*data_->getArgument(12)); }
void IfcReinforcingBar::setPredefinedType(IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarTypeEnum::ToString(v)));data_->setArgument(12,attr);} }
bool IfcReinforcingBar::hasBarSurface() const { return !data_->getArgument(13)->isNull(); }
IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcingBar::BarSurface() const { return IfcReinforcingBarSurfaceEnum::FromString(*data_->getArgument(13)); }
void IfcReinforcingBar::setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarSurfaceEnum::ToString(v)));data_->setArgument(13,attr);} }


const IfcParse::entity& IfcReinforcingBar::declaration() const { return *IfcReinforcingBar_type; }
const IfcParse::entity& IfcReinforcingBar::Class() { return *IfcReinforcingBar_type; }
IfcReinforcingBar::IfcReinforcingBar(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcReinforcingBar_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReinforcingBar::IfcReinforcingBar(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< double > v10_NominalDiameter, boost::optional< double > v11_CrossSectionArea, boost::optional< double > v12_BarLength, boost::optional< IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum > v13_PredefinedType, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v14_BarSurface) : IfcReinforcingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcReinforcingBar_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_NominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_NominalDiameter));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_CrossSectionArea));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_BarLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_BarLength));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v13_PredefinedType,IfcReinforcingBarTypeEnum::ToString(*v13_PredefinedType))));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_BarSurface) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_BarSurface,IfcReinforcingBarSurfaceEnum::ToString(*v14_BarSurface))));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } }

// Function implementations for IfcReinforcingBarType
IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum IfcReinforcingBarType::PredefinedType() const { return IfcReinforcingBarTypeEnum::FromString(*data_->getArgument(9)); }
void IfcReinforcingBarType::setPredefinedType(IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcReinforcingBarType::hasNominalDiameter() const { return !data_->getArgument(10)->isNull(); }
double IfcReinforcingBarType::NominalDiameter() const { return *data_->getArgument(10); }
void IfcReinforcingBarType::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcReinforcingBarType::hasCrossSectionArea() const { return !data_->getArgument(11)->isNull(); }
double IfcReinforcingBarType::CrossSectionArea() const { return *data_->getArgument(11); }
void IfcReinforcingBarType::setCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcReinforcingBarType::hasBarLength() const { return !data_->getArgument(12)->isNull(); }
double IfcReinforcingBarType::BarLength() const { return *data_->getArgument(12); }
void IfcReinforcingBarType::setBarLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcReinforcingBarType::hasBarSurface() const { return !data_->getArgument(13)->isNull(); }
IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcingBarType::BarSurface() const { return IfcReinforcingBarSurfaceEnum::FromString(*data_->getArgument(13)); }
void IfcReinforcingBarType::setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarSurfaceEnum::ToString(v)));data_->setArgument(13,attr);} }
bool IfcReinforcingBarType::hasBendingShapeCode() const { return !data_->getArgument(14)->isNull(); }
std::string IfcReinforcingBarType::BendingShapeCode() const { return *data_->getArgument(14); }
void IfcReinforcingBarType::setBendingShapeCode(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
bool IfcReinforcingBarType::hasBendingParameters() const { return !data_->getArgument(15)->isNull(); }
IfcEntityList::ptr IfcReinforcingBarType::BendingParameters() const { return *data_->getArgument(15); }
void IfcReinforcingBarType::setBendingParameters(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }


const IfcParse::entity& IfcReinforcingBarType::declaration() const { return *IfcReinforcingBarType_type; }
const IfcParse::entity& IfcReinforcingBarType::Class() { return *IfcReinforcingBarType_type; }
IfcReinforcingBarType::IfcReinforcingBarType(IfcEntityInstanceData* e) : IfcReinforcingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcReinforcingBarType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReinforcingBarType::IfcReinforcingBarType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum v10_PredefinedType, boost::optional< double > v11_NominalDiameter, boost::optional< double > v12_CrossSectionArea, boost::optional< double > v13_BarLength, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v14_BarSurface, boost::optional< std::string > v15_BendingShapeCode, boost::optional< IfcEntityList::ptr > v16_BendingParameters) : IfcReinforcingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcReinforcingBarType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcReinforcingBarTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} if (v11_NominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_NominalDiameter));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_CrossSectionArea));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_BarLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_BarLength));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_BarSurface) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_BarSurface,IfcReinforcingBarSurfaceEnum::ToString(*v14_BarSurface))));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_BendingShapeCode) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_BendingShapeCode));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_BendingParameters) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_BendingParameters));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } }

// Function implementations for IfcReinforcingElement
bool IfcReinforcingElement::hasSteelGrade() const { return !data_->getArgument(8)->isNull(); }
std::string IfcReinforcingElement::SteelGrade() const { return *data_->getArgument(8); }
void IfcReinforcingElement::setSteelGrade(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcReinforcingElement::declaration() const { return *IfcReinforcingElement_type; }
const IfcParse::entity& IfcReinforcingElement::Class() { return *IfcReinforcingElement_type; }
IfcReinforcingElement::IfcReinforcingElement(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcReinforcingElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReinforcingElement::IfcReinforcingElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade) : IfcElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcReinforcingElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcReinforcingElementType


const IfcParse::entity& IfcReinforcingElementType::declaration() const { return *IfcReinforcingElementType_type; }
const IfcParse::entity& IfcReinforcingElementType::Class() { return *IfcReinforcingElementType_type; }
IfcReinforcingElementType::IfcReinforcingElementType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcReinforcingElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReinforcingElementType::IfcReinforcingElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementComponentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcReinforcingElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcReinforcingMesh
bool IfcReinforcingMesh::hasMeshLength() const { return !data_->getArgument(9)->isNull(); }
double IfcReinforcingMesh::MeshLength() const { return *data_->getArgument(9); }
void IfcReinforcingMesh::setMeshLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcReinforcingMesh::hasMeshWidth() const { return !data_->getArgument(10)->isNull(); }
double IfcReinforcingMesh::MeshWidth() const { return *data_->getArgument(10); }
void IfcReinforcingMesh::setMeshWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcReinforcingMesh::hasLongitudinalBarNominalDiameter() const { return !data_->getArgument(11)->isNull(); }
double IfcReinforcingMesh::LongitudinalBarNominalDiameter() const { return *data_->getArgument(11); }
void IfcReinforcingMesh::setLongitudinalBarNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcReinforcingMesh::hasTransverseBarNominalDiameter() const { return !data_->getArgument(12)->isNull(); }
double IfcReinforcingMesh::TransverseBarNominalDiameter() const { return *data_->getArgument(12); }
void IfcReinforcingMesh::setTransverseBarNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcReinforcingMesh::hasLongitudinalBarCrossSectionArea() const { return !data_->getArgument(13)->isNull(); }
double IfcReinforcingMesh::LongitudinalBarCrossSectionArea() const { return *data_->getArgument(13); }
void IfcReinforcingMesh::setLongitudinalBarCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
bool IfcReinforcingMesh::hasTransverseBarCrossSectionArea() const { return !data_->getArgument(14)->isNull(); }
double IfcReinforcingMesh::TransverseBarCrossSectionArea() const { return *data_->getArgument(14); }
void IfcReinforcingMesh::setTransverseBarCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
bool IfcReinforcingMesh::hasLongitudinalBarSpacing() const { return !data_->getArgument(15)->isNull(); }
double IfcReinforcingMesh::LongitudinalBarSpacing() const { return *data_->getArgument(15); }
void IfcReinforcingMesh::setLongitudinalBarSpacing(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }
bool IfcReinforcingMesh::hasTransverseBarSpacing() const { return !data_->getArgument(16)->isNull(); }
double IfcReinforcingMesh::TransverseBarSpacing() const { return *data_->getArgument(16); }
void IfcReinforcingMesh::setTransverseBarSpacing(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(16,attr);} }
bool IfcReinforcingMesh::hasPredefinedType() const { return !data_->getArgument(17)->isNull(); }
IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum IfcReinforcingMesh::PredefinedType() const { return IfcReinforcingMeshTypeEnum::FromString(*data_->getArgument(17)); }
void IfcReinforcingMesh::setPredefinedType(IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingMeshTypeEnum::ToString(v)));data_->setArgument(17,attr);} }


const IfcParse::entity& IfcReinforcingMesh::declaration() const { return *IfcReinforcingMesh_type; }
const IfcParse::entity& IfcReinforcingMesh::Class() { return *IfcReinforcingMesh_type; }
IfcReinforcingMesh::IfcReinforcingMesh(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcReinforcingMesh_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReinforcingMesh::IfcReinforcingMesh(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< double > v10_MeshLength, boost::optional< double > v11_MeshWidth, boost::optional< double > v12_LongitudinalBarNominalDiameter, boost::optional< double > v13_TransverseBarNominalDiameter, boost::optional< double > v14_LongitudinalBarCrossSectionArea, boost::optional< double > v15_TransverseBarCrossSectionArea, boost::optional< double > v16_LongitudinalBarSpacing, boost::optional< double > v17_TransverseBarSpacing, boost::optional< IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum > v18_PredefinedType) : IfcReinforcingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcReinforcingMesh_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_MeshLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_MeshLength));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_MeshWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MeshWidth));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_LongitudinalBarNominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_LongitudinalBarNominalDiameter));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_TransverseBarNominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_TransverseBarNominalDiameter));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_LongitudinalBarCrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_LongitudinalBarCrossSectionArea));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_TransverseBarCrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_TransverseBarCrossSectionArea));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_LongitudinalBarSpacing) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_LongitudinalBarSpacing));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_TransverseBarSpacing) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_TransverseBarSpacing));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } if (v18_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v18_PredefinedType,IfcReinforcingMeshTypeEnum::ToString(*v18_PredefinedType))));data_->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(17, attr); } }

// Function implementations for IfcReinforcingMeshType
IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum IfcReinforcingMeshType::PredefinedType() const { return IfcReinforcingMeshTypeEnum::FromString(*data_->getArgument(9)); }
void IfcReinforcingMeshType::setPredefinedType(IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingMeshTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcReinforcingMeshType::hasMeshLength() const { return !data_->getArgument(10)->isNull(); }
double IfcReinforcingMeshType::MeshLength() const { return *data_->getArgument(10); }
void IfcReinforcingMeshType::setMeshLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcReinforcingMeshType::hasMeshWidth() const { return !data_->getArgument(11)->isNull(); }
double IfcReinforcingMeshType::MeshWidth() const { return *data_->getArgument(11); }
void IfcReinforcingMeshType::setMeshWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcReinforcingMeshType::hasLongitudinalBarNominalDiameter() const { return !data_->getArgument(12)->isNull(); }
double IfcReinforcingMeshType::LongitudinalBarNominalDiameter() const { return *data_->getArgument(12); }
void IfcReinforcingMeshType::setLongitudinalBarNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcReinforcingMeshType::hasTransverseBarNominalDiameter() const { return !data_->getArgument(13)->isNull(); }
double IfcReinforcingMeshType::TransverseBarNominalDiameter() const { return *data_->getArgument(13); }
void IfcReinforcingMeshType::setTransverseBarNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
bool IfcReinforcingMeshType::hasLongitudinalBarCrossSectionArea() const { return !data_->getArgument(14)->isNull(); }
double IfcReinforcingMeshType::LongitudinalBarCrossSectionArea() const { return *data_->getArgument(14); }
void IfcReinforcingMeshType::setLongitudinalBarCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
bool IfcReinforcingMeshType::hasTransverseBarCrossSectionArea() const { return !data_->getArgument(15)->isNull(); }
double IfcReinforcingMeshType::TransverseBarCrossSectionArea() const { return *data_->getArgument(15); }
void IfcReinforcingMeshType::setTransverseBarCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }
bool IfcReinforcingMeshType::hasLongitudinalBarSpacing() const { return !data_->getArgument(16)->isNull(); }
double IfcReinforcingMeshType::LongitudinalBarSpacing() const { return *data_->getArgument(16); }
void IfcReinforcingMeshType::setLongitudinalBarSpacing(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(16,attr);} }
bool IfcReinforcingMeshType::hasTransverseBarSpacing() const { return !data_->getArgument(17)->isNull(); }
double IfcReinforcingMeshType::TransverseBarSpacing() const { return *data_->getArgument(17); }
void IfcReinforcingMeshType::setTransverseBarSpacing(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(17,attr);} }
bool IfcReinforcingMeshType::hasBendingShapeCode() const { return !data_->getArgument(18)->isNull(); }
std::string IfcReinforcingMeshType::BendingShapeCode() const { return *data_->getArgument(18); }
void IfcReinforcingMeshType::setBendingShapeCode(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(18,attr);} }
bool IfcReinforcingMeshType::hasBendingParameters() const { return !data_->getArgument(19)->isNull(); }
IfcEntityList::ptr IfcReinforcingMeshType::BendingParameters() const { return *data_->getArgument(19); }
void IfcReinforcingMeshType::setBendingParameters(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(19,attr);} }


const IfcParse::entity& IfcReinforcingMeshType::declaration() const { return *IfcReinforcingMeshType_type; }
const IfcParse::entity& IfcReinforcingMeshType::Class() { return *IfcReinforcingMeshType_type; }
IfcReinforcingMeshType::IfcReinforcingMeshType(IfcEntityInstanceData* e) : IfcReinforcingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcReinforcingMeshType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReinforcingMeshType::IfcReinforcingMeshType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum v10_PredefinedType, boost::optional< double > v11_MeshLength, boost::optional< double > v12_MeshWidth, boost::optional< double > v13_LongitudinalBarNominalDiameter, boost::optional< double > v14_TransverseBarNominalDiameter, boost::optional< double > v15_LongitudinalBarCrossSectionArea, boost::optional< double > v16_TransverseBarCrossSectionArea, boost::optional< double > v17_LongitudinalBarSpacing, boost::optional< double > v18_TransverseBarSpacing, boost::optional< std::string > v19_BendingShapeCode, boost::optional< IfcEntityList::ptr > v20_BendingParameters) : IfcReinforcingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcReinforcingMeshType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcReinforcingMeshTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} if (v11_MeshLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MeshLength));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_MeshWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_MeshWidth));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_LongitudinalBarNominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_LongitudinalBarNominalDiameter));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_TransverseBarNominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_TransverseBarNominalDiameter));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_LongitudinalBarCrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_LongitudinalBarCrossSectionArea));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_TransverseBarCrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_TransverseBarCrossSectionArea));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_LongitudinalBarSpacing) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_LongitudinalBarSpacing));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } if (v18_TransverseBarSpacing) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_TransverseBarSpacing));data_->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(17, attr); } if (v19_BendingShapeCode) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_BendingShapeCode));data_->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(18, attr); } if (v20_BendingParameters) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v20_BendingParameters));data_->setArgument(19,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(19, attr); } }

// Function implementations for IfcRelAggregates
IfcObjectDefinition* IfcRelAggregates::RelatingObject() const { return (IfcObjectDefinition*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelAggregates::setRelatingObject(IfcObjectDefinition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcObjectDefinition >::ptr IfcRelAggregates::RelatedObjects() const { IfcEntityList::ptr es = *data_->getArgument(5); return es->as<IfcObjectDefinition>(); }
void IfcRelAggregates::setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelAggregates::declaration() const { return *IfcRelAggregates_type; }
const IfcParse::entity& IfcRelAggregates::Class() { return *IfcRelAggregates_type; }
IfcRelAggregates::IfcRelAggregates(IfcEntityInstanceData* e) : IfcRelDecomposes((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAggregates_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAggregates::IfcRelAggregates(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects) : IfcRelDecomposes((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAggregates_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingObject));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedObjects)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssigns
IfcTemplatedEntityList< IfcObjectDefinition >::ptr IfcRelAssigns::RelatedObjects() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcObjectDefinition>(); }
void IfcRelAssigns::setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }
bool IfcRelAssigns::hasRelatedObjectsType() const { return !data_->getArgument(5)->isNull(); }
IfcObjectTypeEnum::IfcObjectTypeEnum IfcRelAssigns::RelatedObjectsType() const { return IfcObjectTypeEnum::FromString(*data_->getArgument(5)); }
void IfcRelAssigns::setRelatedObjectsType(IfcObjectTypeEnum::IfcObjectTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcObjectTypeEnum::ToString(v)));data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelAssigns::declaration() const { return *IfcRelAssigns_type; }
const IfcParse::entity& IfcRelAssigns::Class() { return *IfcRelAssigns_type; }
IfcRelAssigns::IfcRelAssigns(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssigns_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssigns::IfcRelAssigns(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssigns_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcRelAssignsToActor
IfcActor* IfcRelAssignsToActor::RelatingActor() const { return (IfcActor*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelAssignsToActor::setRelatingActor(IfcActor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcRelAssignsToActor::hasActingRole() const { return !data_->getArgument(7)->isNull(); }
IfcActorRole* IfcRelAssignsToActor::ActingRole() const { return (IfcActorRole*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcRelAssignsToActor::setActingRole(IfcActorRole* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcRelAssignsToActor::declaration() const { return *IfcRelAssignsToActor_type; }
const IfcParse::entity& IfcRelAssignsToActor::Class() { return *IfcRelAssignsToActor_type; }
IfcRelAssignsToActor::IfcRelAssignsToActor(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssignsToActor_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssignsToActor::IfcRelAssignsToActor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcActor* v7_RelatingActor, IfcActorRole* v8_ActingRole) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssignsToActor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingActor));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ActingRole));data_->setArgument(7,attr);} }

// Function implementations for IfcRelAssignsToControl
IfcControl* IfcRelAssignsToControl::RelatingControl() const { return (IfcControl*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelAssignsToControl::setRelatingControl(IfcControl* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcRelAssignsToControl::declaration() const { return *IfcRelAssignsToControl_type; }
const IfcParse::entity& IfcRelAssignsToControl::Class() { return *IfcRelAssignsToControl_type; }
IfcRelAssignsToControl::IfcRelAssignsToControl(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssignsToControl_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssignsToControl::IfcRelAssignsToControl(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssignsToControl_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingControl));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToGroup
IfcGroup* IfcRelAssignsToGroup::RelatingGroup() const { return (IfcGroup*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelAssignsToGroup::setRelatingGroup(IfcGroup* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcRelAssignsToGroup::declaration() const { return *IfcRelAssignsToGroup_type; }
const IfcParse::entity& IfcRelAssignsToGroup::Class() { return *IfcRelAssignsToGroup_type; }
IfcRelAssignsToGroup::IfcRelAssignsToGroup(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssignsToGroup_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssignsToGroup::IfcRelAssignsToGroup(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcGroup* v7_RelatingGroup) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssignsToGroup_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingGroup));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToGroupByFactor
double IfcRelAssignsToGroupByFactor::Factor() const { return *data_->getArgument(7); }
void IfcRelAssignsToGroupByFactor::setFactor(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcRelAssignsToGroupByFactor::declaration() const { return *IfcRelAssignsToGroupByFactor_type; }
const IfcParse::entity& IfcRelAssignsToGroupByFactor::Class() { return *IfcRelAssignsToGroupByFactor_type; }
IfcRelAssignsToGroupByFactor::IfcRelAssignsToGroupByFactor(IfcEntityInstanceData* e) : IfcRelAssignsToGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssignsToGroupByFactor_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssignsToGroupByFactor::IfcRelAssignsToGroupByFactor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcGroup* v7_RelatingGroup, double v8_Factor) : IfcRelAssignsToGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssignsToGroupByFactor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingGroup));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Factor));data_->setArgument(7,attr);} }

// Function implementations for IfcRelAssignsToProcess
IfcProcessSelect* IfcRelAssignsToProcess::RelatingProcess() const { return (IfcProcessSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelAssignsToProcess::setRelatingProcess(IfcProcessSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcRelAssignsToProcess::hasQuantityInProcess() const { return !data_->getArgument(7)->isNull(); }
IfcMeasureWithUnit* IfcRelAssignsToProcess::QuantityInProcess() const { return (IfcMeasureWithUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcRelAssignsToProcess::setQuantityInProcess(IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcRelAssignsToProcess::declaration() const { return *IfcRelAssignsToProcess_type; }
const IfcParse::entity& IfcRelAssignsToProcess::Class() { return *IfcRelAssignsToProcess_type; }
IfcRelAssignsToProcess::IfcRelAssignsToProcess(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssignsToProcess_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssignsToProcess::IfcRelAssignsToProcess(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProcessSelect* v7_RelatingProcess, IfcMeasureWithUnit* v8_QuantityInProcess) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssignsToProcess_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingProcess));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_QuantityInProcess));data_->setArgument(7,attr);} }

// Function implementations for IfcRelAssignsToProduct
IfcProductSelect* IfcRelAssignsToProduct::RelatingProduct() const { return (IfcProductSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelAssignsToProduct::setRelatingProduct(IfcProductSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcRelAssignsToProduct::declaration() const { return *IfcRelAssignsToProduct_type; }
const IfcParse::entity& IfcRelAssignsToProduct::Class() { return *IfcRelAssignsToProduct_type; }
IfcRelAssignsToProduct::IfcRelAssignsToProduct(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssignsToProduct_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssignsToProduct::IfcRelAssignsToProduct(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProductSelect* v7_RelatingProduct) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssignsToProduct_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingProduct));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToResource
IfcResourceSelect* IfcRelAssignsToResource::RelatingResource() const { return (IfcResourceSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelAssignsToResource::setRelatingResource(IfcResourceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcRelAssignsToResource::declaration() const { return *IfcRelAssignsToResource_type; }
const IfcParse::entity& IfcRelAssignsToResource::Class() { return *IfcRelAssignsToResource_type; }
IfcRelAssignsToResource::IfcRelAssignsToResource(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssignsToResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssignsToResource::IfcRelAssignsToResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcResourceSelect* v7_RelatingResource) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssignsToResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingResource));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssociates
IfcEntityList::ptr IfcRelAssociates::RelatedObjects() const { return *data_->getArgument(4); }
void IfcRelAssociates::setRelatedObjects(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcRelAssociates::declaration() const { return *IfcRelAssociates_type; }
const IfcParse::entity& IfcRelAssociates::Class() { return *IfcRelAssociates_type; }
IfcRelAssociates::IfcRelAssociates(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssociates_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssociates::IfcRelAssociates(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssociates_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects));data_->setArgument(4,attr);} }

// Function implementations for IfcRelAssociatesApproval
IfcApproval* IfcRelAssociatesApproval::RelatingApproval() const { return (IfcApproval*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelAssociatesApproval::setRelatingApproval(IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelAssociatesApproval::declaration() const { return *IfcRelAssociatesApproval_type; }
const IfcParse::entity& IfcRelAssociatesApproval::Class() { return *IfcRelAssociatesApproval_type; }
IfcRelAssociatesApproval::IfcRelAssociatesApproval(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssociatesApproval_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssociatesApproval::IfcRelAssociatesApproval(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcApproval* v6_RelatingApproval) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssociatesApproval_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingApproval));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesClassification
IfcClassificationSelect* IfcRelAssociatesClassification::RelatingClassification() const { return (IfcClassificationSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelAssociatesClassification::setRelatingClassification(IfcClassificationSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelAssociatesClassification::declaration() const { return *IfcRelAssociatesClassification_type; }
const IfcParse::entity& IfcRelAssociatesClassification::Class() { return *IfcRelAssociatesClassification_type; }
IfcRelAssociatesClassification::IfcRelAssociatesClassification(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssociatesClassification_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssociatesClassification::IfcRelAssociatesClassification(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcClassificationSelect* v6_RelatingClassification) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssociatesClassification_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingClassification));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesConstraint
bool IfcRelAssociatesConstraint::hasIntent() const { return !data_->getArgument(5)->isNull(); }
std::string IfcRelAssociatesConstraint::Intent() const { return *data_->getArgument(5); }
void IfcRelAssociatesConstraint::setIntent(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
IfcConstraint* IfcRelAssociatesConstraint::RelatingConstraint() const { return (IfcConstraint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelAssociatesConstraint::setRelatingConstraint(IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcRelAssociatesConstraint::declaration() const { return *IfcRelAssociatesConstraint_type; }
const IfcParse::entity& IfcRelAssociatesConstraint::Class() { return *IfcRelAssociatesConstraint_type; }
IfcRelAssociatesConstraint::IfcRelAssociatesConstraint(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssociatesConstraint_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssociatesConstraint::IfcRelAssociatesConstraint(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, boost::optional< std::string > v6_Intent, IfcConstraint* v7_RelatingConstraint) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssociatesConstraint_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects));data_->setArgument(4,attr);} if (v6_Intent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Intent));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingConstraint));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssociatesDocument
IfcDocumentSelect* IfcRelAssociatesDocument::RelatingDocument() const { return (IfcDocumentSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelAssociatesDocument::setRelatingDocument(IfcDocumentSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelAssociatesDocument::declaration() const { return *IfcRelAssociatesDocument_type; }
const IfcParse::entity& IfcRelAssociatesDocument::Class() { return *IfcRelAssociatesDocument_type; }
IfcRelAssociatesDocument::IfcRelAssociatesDocument(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssociatesDocument_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssociatesDocument::IfcRelAssociatesDocument(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcDocumentSelect* v6_RelatingDocument) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssociatesDocument_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingDocument));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesLibrary
IfcLibrarySelect* IfcRelAssociatesLibrary::RelatingLibrary() const { return (IfcLibrarySelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelAssociatesLibrary::setRelatingLibrary(IfcLibrarySelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelAssociatesLibrary::declaration() const { return *IfcRelAssociatesLibrary_type; }
const IfcParse::entity& IfcRelAssociatesLibrary::Class() { return *IfcRelAssociatesLibrary_type; }
IfcRelAssociatesLibrary::IfcRelAssociatesLibrary(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssociatesLibrary_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssociatesLibrary::IfcRelAssociatesLibrary(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcLibrarySelect* v6_RelatingLibrary) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssociatesLibrary_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingLibrary));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesMaterial
IfcMaterialSelect* IfcRelAssociatesMaterial::RelatingMaterial() const { return (IfcMaterialSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelAssociatesMaterial::setRelatingMaterial(IfcMaterialSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelAssociatesMaterial::declaration() const { return *IfcRelAssociatesMaterial_type; }
const IfcParse::entity& IfcRelAssociatesMaterial::Class() { return *IfcRelAssociatesMaterial_type; }
IfcRelAssociatesMaterial::IfcRelAssociatesMaterial(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelAssociatesMaterial_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelAssociatesMaterial::IfcRelAssociatesMaterial(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcMaterialSelect* v6_RelatingMaterial) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelAssociatesMaterial_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingMaterial));data_->setArgument(5,attr);} }

// Function implementations for IfcRelConnects


const IfcParse::entity& IfcRelConnects::declaration() const { return *IfcRelConnects_type; }
const IfcParse::entity& IfcRelConnects::Class() { return *IfcRelConnects_type; }
IfcRelConnects::IfcRelConnects(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelConnects_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelConnects::IfcRelConnects(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelConnects_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcRelConnectsElements
bool IfcRelConnectsElements::hasConnectionGeometry() const { return !data_->getArgument(4)->isNull(); }
IfcConnectionGeometry* IfcRelConnectsElements::ConnectionGeometry() const { return (IfcConnectionGeometry*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelConnectsElements::setConnectionGeometry(IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcElement* IfcRelConnectsElements::RelatingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelConnectsElements::setRelatingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
IfcElement* IfcRelConnectsElements::RelatedElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelConnectsElements::setRelatedElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcRelConnectsElements::declaration() const { return *IfcRelConnectsElements_type; }
const IfcParse::entity& IfcRelConnectsElements::Class() { return *IfcRelConnectsElements_type; }
IfcRelConnectsElements::IfcRelConnectsElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelConnectsElements_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelConnectsElements::IfcRelConnectsElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelConnectsElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConnectionGeometry));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatedElement));data_->setArgument(6,attr);} }

// Function implementations for IfcRelConnectsPathElements
std::vector< int > /*[0:?]*/ IfcRelConnectsPathElements::RelatingPriorities() const { return *data_->getArgument(7); }
void IfcRelConnectsPathElements::setRelatingPriorities(std::vector< int > /*[0:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
std::vector< int > /*[0:?]*/ IfcRelConnectsPathElements::RelatedPriorities() const { return *data_->getArgument(8); }
void IfcRelConnectsPathElements::setRelatedPriorities(std::vector< int > /*[0:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
IfcConnectionTypeEnum::IfcConnectionTypeEnum IfcRelConnectsPathElements::RelatedConnectionType() const { return IfcConnectionTypeEnum::FromString(*data_->getArgument(9)); }
void IfcRelConnectsPathElements::setRelatedConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConnectionTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
IfcConnectionTypeEnum::IfcConnectionTypeEnum IfcRelConnectsPathElements::RelatingConnectionType() const { return IfcConnectionTypeEnum::FromString(*data_->getArgument(10)); }
void IfcRelConnectsPathElements::setRelatingConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConnectionTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& IfcRelConnectsPathElements::declaration() const { return *IfcRelConnectsPathElements_type; }
const IfcParse::entity& IfcRelConnectsPathElements::Class() { return *IfcRelConnectsPathElements_type; }
IfcRelConnectsPathElements::IfcRelConnectsPathElements(IfcEntityInstanceData* e) : IfcRelConnectsElements((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelConnectsPathElements_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelConnectsPathElements::IfcRelConnectsPathElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, std::vector< int > /*[0:?]*/ v8_RelatingPriorities, std::vector< int > /*[0:?]*/ v9_RelatedPriorities, IfcConnectionTypeEnum::IfcConnectionTypeEnum v10_RelatedConnectionType, IfcConnectionTypeEnum::IfcConnectionTypeEnum v11_RelatingConnectionType) : IfcRelConnectsElements((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelConnectsPathElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConnectionGeometry));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatedElement));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RelatingPriorities));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_RelatedPriorities));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_RelatedConnectionType,IfcConnectionTypeEnum::ToString(v10_RelatedConnectionType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v11_RelatingConnectionType,IfcConnectionTypeEnum::ToString(v11_RelatingConnectionType))));data_->setArgument(10,attr);} }

// Function implementations for IfcRelConnectsPortToElement
IfcPort* IfcRelConnectsPortToElement::RelatingPort() const { return (IfcPort*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelConnectsPortToElement::setRelatingPort(IfcPort* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcDistributionElement* IfcRelConnectsPortToElement::RelatedElement() const { return (IfcDistributionElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelConnectsPortToElement::setRelatedElement(IfcDistributionElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelConnectsPortToElement::declaration() const { return *IfcRelConnectsPortToElement_type; }
const IfcParse::entity& IfcRelConnectsPortToElement::Class() { return *IfcRelConnectsPortToElement_type; }
IfcRelConnectsPortToElement::IfcRelConnectsPortToElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelConnectsPortToElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelConnectsPortToElement::IfcRelConnectsPortToElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPort* v5_RelatingPort, IfcDistributionElement* v6_RelatedElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelConnectsPortToElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingPort));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelConnectsPorts
IfcPort* IfcRelConnectsPorts::RelatingPort() const { return (IfcPort*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelConnectsPorts::setRelatingPort(IfcPort* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcPort* IfcRelConnectsPorts::RelatedPort() const { return (IfcPort*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelConnectsPorts::setRelatedPort(IfcPort* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcRelConnectsPorts::hasRealizingElement() const { return !data_->getArgument(6)->isNull(); }
IfcElement* IfcRelConnectsPorts::RealizingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelConnectsPorts::setRealizingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcRelConnectsPorts::declaration() const { return *IfcRelConnectsPorts_type; }
const IfcParse::entity& IfcRelConnectsPorts::Class() { return *IfcRelConnectsPorts_type; }
IfcRelConnectsPorts::IfcRelConnectsPorts(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelConnectsPorts_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelConnectsPorts::IfcRelConnectsPorts(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPort* v5_RelatingPort, IfcPort* v6_RelatedPort, IfcElement* v7_RealizingElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelConnectsPorts_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingPort));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedPort));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RealizingElement));data_->setArgument(6,attr);} }

// Function implementations for IfcRelConnectsStructuralActivity
IfcStructuralActivityAssignmentSelect* IfcRelConnectsStructuralActivity::RelatingElement() const { return (IfcStructuralActivityAssignmentSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelConnectsStructuralActivity::setRelatingElement(IfcStructuralActivityAssignmentSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcStructuralActivity* IfcRelConnectsStructuralActivity::RelatedStructuralActivity() const { return (IfcStructuralActivity*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelConnectsStructuralActivity::setRelatedStructuralActivity(IfcStructuralActivity* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelConnectsStructuralActivity::declaration() const { return *IfcRelConnectsStructuralActivity_type; }
const IfcParse::entity& IfcRelConnectsStructuralActivity::Class() { return *IfcRelConnectsStructuralActivity_type; }
IfcRelConnectsStructuralActivity::IfcRelConnectsStructuralActivity(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelConnectsStructuralActivity_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelConnectsStructuralActivity::IfcRelConnectsStructuralActivity(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralActivityAssignmentSelect* v5_RelatingElement, IfcStructuralActivity* v6_RelatedStructuralActivity) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelConnectsStructuralActivity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralActivity));data_->setArgument(5,attr);} }

// Function implementations for IfcRelConnectsStructuralMember
IfcStructuralMember* IfcRelConnectsStructuralMember::RelatingStructuralMember() const { return (IfcStructuralMember*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelConnectsStructuralMember::setRelatingStructuralMember(IfcStructuralMember* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcStructuralConnection* IfcRelConnectsStructuralMember::RelatedStructuralConnection() const { return (IfcStructuralConnection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelConnectsStructuralMember::setRelatedStructuralConnection(IfcStructuralConnection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcRelConnectsStructuralMember::hasAppliedCondition() const { return !data_->getArgument(6)->isNull(); }
IfcBoundaryCondition* IfcRelConnectsStructuralMember::AppliedCondition() const { return (IfcBoundaryCondition*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelConnectsStructuralMember::setAppliedCondition(IfcBoundaryCondition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcRelConnectsStructuralMember::hasAdditionalConditions() const { return !data_->getArgument(7)->isNull(); }
IfcStructuralConnectionCondition* IfcRelConnectsStructuralMember::AdditionalConditions() const { return (IfcStructuralConnectionCondition*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcRelConnectsStructuralMember::setAdditionalConditions(IfcStructuralConnectionCondition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcRelConnectsStructuralMember::hasSupportedLength() const { return !data_->getArgument(8)->isNull(); }
double IfcRelConnectsStructuralMember::SupportedLength() const { return *data_->getArgument(8); }
void IfcRelConnectsStructuralMember::setSupportedLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcRelConnectsStructuralMember::hasConditionCoordinateSystem() const { return !data_->getArgument(9)->isNull(); }
IfcAxis2Placement3D* IfcRelConnectsStructuralMember::ConditionCoordinateSystem() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcRelConnectsStructuralMember::setConditionCoordinateSystem(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcRelConnectsStructuralMember::declaration() const { return *IfcRelConnectsStructuralMember_type; }
const IfcParse::entity& IfcRelConnectsStructuralMember::Class() { return *IfcRelConnectsStructuralMember_type; }
IfcRelConnectsStructuralMember::IfcRelConnectsStructuralMember(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelConnectsStructuralMember_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelConnectsStructuralMember::IfcRelConnectsStructuralMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelConnectsStructuralMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingStructuralMember));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralConnection));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_AppliedCondition));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AdditionalConditions));data_->setArgument(7,attr);} if (v9_SupportedLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SupportedLength));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ConditionCoordinateSystem));data_->setArgument(9,attr);} }

// Function implementations for IfcRelConnectsWithEccentricity
IfcConnectionGeometry* IfcRelConnectsWithEccentricity::ConnectionConstraint() const { return (IfcConnectionGeometry*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(10))); }
void IfcRelConnectsWithEccentricity::setConnectionConstraint(IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcRelConnectsWithEccentricity::declaration() const { return *IfcRelConnectsWithEccentricity_type; }
const IfcParse::entity& IfcRelConnectsWithEccentricity::Class() { return *IfcRelConnectsWithEccentricity_type; }
IfcRelConnectsWithEccentricity::IfcRelConnectsWithEccentricity(IfcEntityInstanceData* e) : IfcRelConnectsStructuralMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelConnectsWithEccentricity_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelConnectsWithEccentricity::IfcRelConnectsWithEccentricity(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem, IfcConnectionGeometry* v11_ConnectionConstraint) : IfcRelConnectsStructuralMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelConnectsWithEccentricity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingStructuralMember));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralConnection));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_AppliedCondition));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AdditionalConditions));data_->setArgument(7,attr);} if (v9_SupportedLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SupportedLength));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ConditionCoordinateSystem));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ConnectionConstraint));data_->setArgument(10,attr);} }

// Function implementations for IfcRelConnectsWithRealizingElements
IfcTemplatedEntityList< IfcElement >::ptr IfcRelConnectsWithRealizingElements::RealizingElements() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcElement>(); }
void IfcRelConnectsWithRealizingElements::setRealizingElements(IfcTemplatedEntityList< IfcElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }
bool IfcRelConnectsWithRealizingElements::hasConnectionType() const { return !data_->getArgument(8)->isNull(); }
std::string IfcRelConnectsWithRealizingElements::ConnectionType() const { return *data_->getArgument(8); }
void IfcRelConnectsWithRealizingElements::setConnectionType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcRelConnectsWithRealizingElements::declaration() const { return *IfcRelConnectsWithRealizingElements_type; }
const IfcParse::entity& IfcRelConnectsWithRealizingElements::Class() { return *IfcRelConnectsWithRealizingElements_type; }
IfcRelConnectsWithRealizingElements::IfcRelConnectsWithRealizingElements(IfcEntityInstanceData* e) : IfcRelConnectsElements((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelConnectsWithRealizingElements_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelConnectsWithRealizingElements::IfcRelConnectsWithRealizingElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, IfcTemplatedEntityList< IfcElement >::ptr v8_RealizingElements, boost::optional< std::string > v9_ConnectionType) : IfcRelConnectsElements((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelConnectsWithRealizingElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConnectionGeometry));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatedElement));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RealizingElements)->generalize());data_->setArgument(7,attr);} if (v9_ConnectionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ConnectionType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcRelContainedInSpatialStructure
IfcTemplatedEntityList< IfcProduct >::ptr IfcRelContainedInSpatialStructure::RelatedElements() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcProduct>(); }
void IfcRelContainedInSpatialStructure::setRelatedElements(IfcTemplatedEntityList< IfcProduct >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }
IfcSpatialElement* IfcRelContainedInSpatialStructure::RelatingStructure() const { return (IfcSpatialElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelContainedInSpatialStructure::setRelatingStructure(IfcSpatialElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelContainedInSpatialStructure::declaration() const { return *IfcRelContainedInSpatialStructure_type; }
const IfcParse::entity& IfcRelContainedInSpatialStructure::Class() { return *IfcRelContainedInSpatialStructure_type; }
IfcRelContainedInSpatialStructure::IfcRelContainedInSpatialStructure(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelContainedInSpatialStructure_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelContainedInSpatialStructure::IfcRelContainedInSpatialStructure(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProduct >::ptr v5_RelatedElements, IfcSpatialElement* v6_RelatingStructure) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelContainedInSpatialStructure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedElements)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingStructure));data_->setArgument(5,attr);} }

// Function implementations for IfcRelCoversBldgElements
IfcElement* IfcRelCoversBldgElements::RelatingBuildingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelCoversBldgElements::setRelatingBuildingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcCovering >::ptr IfcRelCoversBldgElements::RelatedCoverings() const { IfcEntityList::ptr es = *data_->getArgument(5); return es->as<IfcCovering>(); }
void IfcRelCoversBldgElements::setRelatedCoverings(IfcTemplatedEntityList< IfcCovering >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelCoversBldgElements::declaration() const { return *IfcRelCoversBldgElements_type; }
const IfcParse::entity& IfcRelCoversBldgElements::Class() { return *IfcRelCoversBldgElements_type; }
IfcRelCoversBldgElements::IfcRelCoversBldgElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelCoversBldgElements_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelCoversBldgElements::IfcRelCoversBldgElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingBuildingElement, IfcTemplatedEntityList< IfcCovering >::ptr v6_RelatedCoverings) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelCoversBldgElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingBuildingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedCoverings)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelCoversSpaces
IfcSpace* IfcRelCoversSpaces::RelatingSpace() const { return (IfcSpace*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelCoversSpaces::setRelatingSpace(IfcSpace* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcCovering >::ptr IfcRelCoversSpaces::RelatedCoverings() const { IfcEntityList::ptr es = *data_->getArgument(5); return es->as<IfcCovering>(); }
void IfcRelCoversSpaces::setRelatedCoverings(IfcTemplatedEntityList< IfcCovering >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelCoversSpaces::declaration() const { return *IfcRelCoversSpaces_type; }
const IfcParse::entity& IfcRelCoversSpaces::Class() { return *IfcRelCoversSpaces_type; }
IfcRelCoversSpaces::IfcRelCoversSpaces(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelCoversSpaces_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelCoversSpaces::IfcRelCoversSpaces(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpace* v5_RelatingSpace, IfcTemplatedEntityList< IfcCovering >::ptr v6_RelatedCoverings) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelCoversSpaces_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingSpace));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedCoverings)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelDeclares
IfcContext* IfcRelDeclares::RelatingContext() const { return (IfcContext*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelDeclares::setRelatingContext(IfcContext* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcEntityList::ptr IfcRelDeclares::RelatedDefinitions() const { return *data_->getArgument(5); }
void IfcRelDeclares::setRelatedDefinitions(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelDeclares::declaration() const { return *IfcRelDeclares_type; }
const IfcParse::entity& IfcRelDeclares::Class() { return *IfcRelDeclares_type; }
IfcRelDeclares::IfcRelDeclares(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelDeclares_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelDeclares::IfcRelDeclares(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcContext* v5_RelatingContext, IfcEntityList::ptr v6_RelatedDefinitions) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelDeclares_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingContext));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedDefinitions));data_->setArgument(5,attr);} }

// Function implementations for IfcRelDecomposes


const IfcParse::entity& IfcRelDecomposes::declaration() const { return *IfcRelDecomposes_type; }
const IfcParse::entity& IfcRelDecomposes::Class() { return *IfcRelDecomposes_type; }
IfcRelDecomposes::IfcRelDecomposes(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelDecomposes_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelDecomposes::IfcRelDecomposes(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelDecomposes_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcRelDefines


const IfcParse::entity& IfcRelDefines::declaration() const { return *IfcRelDefines_type; }
const IfcParse::entity& IfcRelDefines::Class() { return *IfcRelDefines_type; }
IfcRelDefines::IfcRelDefines(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelDefines_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelDefines::IfcRelDefines(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelDefines_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcRelDefinesByObject
IfcTemplatedEntityList< IfcObject >::ptr IfcRelDefinesByObject::RelatedObjects() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcObject>(); }
void IfcRelDefinesByObject::setRelatedObjects(IfcTemplatedEntityList< IfcObject >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }
IfcObject* IfcRelDefinesByObject::RelatingObject() const { return (IfcObject*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelDefinesByObject::setRelatingObject(IfcObject* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelDefinesByObject::declaration() const { return *IfcRelDefinesByObject_type; }
const IfcParse::entity& IfcRelDefinesByObject::Class() { return *IfcRelDefinesByObject_type; }
IfcRelDefinesByObject::IfcRelDefinesByObject(IfcEntityInstanceData* e) : IfcRelDefines((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelDefinesByObject_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelDefinesByObject::IfcRelDefinesByObject(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcObject* v6_RelatingObject) : IfcRelDefines((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelDefinesByObject_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingObject));data_->setArgument(5,attr);} }

// Function implementations for IfcRelDefinesByProperties
IfcTemplatedEntityList< IfcObjectDefinition >::ptr IfcRelDefinesByProperties::RelatedObjects() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcObjectDefinition>(); }
void IfcRelDefinesByProperties::setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }
IfcPropertySetDefinitionSelect* IfcRelDefinesByProperties::RelatingPropertyDefinition() const { return (IfcPropertySetDefinitionSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelDefinesByProperties::setRelatingPropertyDefinition(IfcPropertySetDefinitionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelDefinesByProperties::declaration() const { return *IfcRelDefinesByProperties_type; }
const IfcParse::entity& IfcRelDefinesByProperties::Class() { return *IfcRelDefinesByProperties_type; }
IfcRelDefinesByProperties::IfcRelDefinesByProperties(IfcEntityInstanceData* e) : IfcRelDefines((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelDefinesByProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelDefinesByProperties::IfcRelDefinesByProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, IfcPropertySetDefinitionSelect* v6_RelatingPropertyDefinition) : IfcRelDefines((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelDefinesByProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingPropertyDefinition));data_->setArgument(5,attr);} }

// Function implementations for IfcRelDefinesByTemplate
IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr IfcRelDefinesByTemplate::RelatedPropertySets() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcPropertySetDefinition>(); }
void IfcRelDefinesByTemplate::setRelatedPropertySets(IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }
IfcPropertySetTemplate* IfcRelDefinesByTemplate::RelatingTemplate() const { return (IfcPropertySetTemplate*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelDefinesByTemplate::setRelatingTemplate(IfcPropertySetTemplate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelDefinesByTemplate::declaration() const { return *IfcRelDefinesByTemplate_type; }
const IfcParse::entity& IfcRelDefinesByTemplate::Class() { return *IfcRelDefinesByTemplate_type; }
IfcRelDefinesByTemplate::IfcRelDefinesByTemplate(IfcEntityInstanceData* e) : IfcRelDefines((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelDefinesByTemplate_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelDefinesByTemplate::IfcRelDefinesByTemplate(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v5_RelatedPropertySets, IfcPropertySetTemplate* v6_RelatingTemplate) : IfcRelDefines((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelDefinesByTemplate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedPropertySets)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingTemplate));data_->setArgument(5,attr);} }

// Function implementations for IfcRelDefinesByType
IfcTemplatedEntityList< IfcObject >::ptr IfcRelDefinesByType::RelatedObjects() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcObject>(); }
void IfcRelDefinesByType::setRelatedObjects(IfcTemplatedEntityList< IfcObject >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }
IfcTypeObject* IfcRelDefinesByType::RelatingType() const { return (IfcTypeObject*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelDefinesByType::setRelatingType(IfcTypeObject* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelDefinesByType::declaration() const { return *IfcRelDefinesByType_type; }
const IfcParse::entity& IfcRelDefinesByType::Class() { return *IfcRelDefinesByType_type; }
IfcRelDefinesByType::IfcRelDefinesByType(IfcEntityInstanceData* e) : IfcRelDefines((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelDefinesByType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelDefinesByType::IfcRelDefinesByType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcTypeObject* v6_RelatingType) : IfcRelDefines((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelDefinesByType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingType));data_->setArgument(5,attr);} }

// Function implementations for IfcRelFillsElement
IfcOpeningElement* IfcRelFillsElement::RelatingOpeningElement() const { return (IfcOpeningElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelFillsElement::setRelatingOpeningElement(IfcOpeningElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcElement* IfcRelFillsElement::RelatedBuildingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelFillsElement::setRelatedBuildingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelFillsElement::declaration() const { return *IfcRelFillsElement_type; }
const IfcParse::entity& IfcRelFillsElement::Class() { return *IfcRelFillsElement_type; }
IfcRelFillsElement::IfcRelFillsElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelFillsElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelFillsElement::IfcRelFillsElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcOpeningElement* v5_RelatingOpeningElement, IfcElement* v6_RelatedBuildingElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelFillsElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingOpeningElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildingElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelFlowControlElements
IfcTemplatedEntityList< IfcDistributionControlElement >::ptr IfcRelFlowControlElements::RelatedControlElements() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcDistributionControlElement>(); }
void IfcRelFlowControlElements::setRelatedControlElements(IfcTemplatedEntityList< IfcDistributionControlElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }
IfcDistributionFlowElement* IfcRelFlowControlElements::RelatingFlowElement() const { return (IfcDistributionFlowElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelFlowControlElements::setRelatingFlowElement(IfcDistributionFlowElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelFlowControlElements::declaration() const { return *IfcRelFlowControlElements_type; }
const IfcParse::entity& IfcRelFlowControlElements::Class() { return *IfcRelFlowControlElements_type; }
IfcRelFlowControlElements::IfcRelFlowControlElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelFlowControlElements_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelFlowControlElements::IfcRelFlowControlElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcDistributionControlElement >::ptr v5_RelatedControlElements, IfcDistributionFlowElement* v6_RelatingFlowElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelFlowControlElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedControlElements)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingFlowElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelInterferesElements
IfcElement* IfcRelInterferesElements::RelatingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelInterferesElements::setRelatingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcElement* IfcRelInterferesElements::RelatedElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelInterferesElements::setRelatedElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcRelInterferesElements::hasInterferenceGeometry() const { return !data_->getArgument(6)->isNull(); }
IfcConnectionGeometry* IfcRelInterferesElements::InterferenceGeometry() const { return (IfcConnectionGeometry*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelInterferesElements::setInterferenceGeometry(IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcRelInterferesElements::hasInterferenceType() const { return !data_->getArgument(7)->isNull(); }
std::string IfcRelInterferesElements::InterferenceType() const { return *data_->getArgument(7); }
void IfcRelInterferesElements::setInterferenceType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcRelInterferesElements::ImpliedOrder() const { return *data_->getArgument(8); }
void IfcRelInterferesElements::setImpliedOrder(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcRelInterferesElements::declaration() const { return *IfcRelInterferesElements_type; }
const IfcParse::entity& IfcRelInterferesElements::Class() { return *IfcRelInterferesElements_type; }
IfcRelInterferesElements::IfcRelInterferesElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelInterferesElements_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelInterferesElements::IfcRelInterferesElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingElement, IfcElement* v6_RelatedElement, IfcConnectionGeometry* v7_InterferenceGeometry, boost::optional< std::string > v8_InterferenceType, bool v9_ImpliedOrder) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelInterferesElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_InterferenceGeometry));data_->setArgument(6,attr);} if (v8_InterferenceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_InterferenceType));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ImpliedOrder));data_->setArgument(8,attr);} }

// Function implementations for IfcRelNests
IfcObjectDefinition* IfcRelNests::RelatingObject() const { return (IfcObjectDefinition*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelNests::setRelatingObject(IfcObjectDefinition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcObjectDefinition >::ptr IfcRelNests::RelatedObjects() const { IfcEntityList::ptr es = *data_->getArgument(5); return es->as<IfcObjectDefinition>(); }
void IfcRelNests::setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelNests::declaration() const { return *IfcRelNests_type; }
const IfcParse::entity& IfcRelNests::Class() { return *IfcRelNests_type; }
IfcRelNests::IfcRelNests(IfcEntityInstanceData* e) : IfcRelDecomposes((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelNests_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelNests::IfcRelNests(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects) : IfcRelDecomposes((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelNests_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingObject));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedObjects)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelProjectsElement
IfcElement* IfcRelProjectsElement::RelatingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelProjectsElement::setRelatingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcFeatureElementAddition* IfcRelProjectsElement::RelatedFeatureElement() const { return (IfcFeatureElementAddition*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelProjectsElement::setRelatedFeatureElement(IfcFeatureElementAddition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelProjectsElement::declaration() const { return *IfcRelProjectsElement_type; }
const IfcParse::entity& IfcRelProjectsElement::Class() { return *IfcRelProjectsElement_type; }
IfcRelProjectsElement::IfcRelProjectsElement(IfcEntityInstanceData* e) : IfcRelDecomposes((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelProjectsElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelProjectsElement::IfcRelProjectsElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingElement, IfcFeatureElementAddition* v6_RelatedFeatureElement) : IfcRelDecomposes((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelProjectsElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedFeatureElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelReferencedInSpatialStructure
IfcTemplatedEntityList< IfcProduct >::ptr IfcRelReferencedInSpatialStructure::RelatedElements() const { IfcEntityList::ptr es = *data_->getArgument(4); return es->as<IfcProduct>(); }
void IfcRelReferencedInSpatialStructure::setRelatedElements(IfcTemplatedEntityList< IfcProduct >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(4,attr);} }
IfcSpatialElement* IfcRelReferencedInSpatialStructure::RelatingStructure() const { return (IfcSpatialElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelReferencedInSpatialStructure::setRelatingStructure(IfcSpatialElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelReferencedInSpatialStructure::declaration() const { return *IfcRelReferencedInSpatialStructure_type; }
const IfcParse::entity& IfcRelReferencedInSpatialStructure::Class() { return *IfcRelReferencedInSpatialStructure_type; }
IfcRelReferencedInSpatialStructure::IfcRelReferencedInSpatialStructure(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelReferencedInSpatialStructure_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelReferencedInSpatialStructure::IfcRelReferencedInSpatialStructure(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProduct >::ptr v5_RelatedElements, IfcSpatialElement* v6_RelatingStructure) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelReferencedInSpatialStructure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedElements)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingStructure));data_->setArgument(5,attr);} }

// Function implementations for IfcRelSequence
IfcProcess* IfcRelSequence::RelatingProcess() const { return (IfcProcess*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelSequence::setRelatingProcess(IfcProcess* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcProcess* IfcRelSequence::RelatedProcess() const { return (IfcProcess*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelSequence::setRelatedProcess(IfcProcess* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcRelSequence::hasTimeLag() const { return !data_->getArgument(6)->isNull(); }
IfcLagTime* IfcRelSequence::TimeLag() const { return (IfcLagTime*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelSequence::setTimeLag(IfcLagTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcRelSequence::hasSequenceType() const { return !data_->getArgument(7)->isNull(); }
IfcSequenceEnum::IfcSequenceEnum IfcRelSequence::SequenceType() const { return IfcSequenceEnum::FromString(*data_->getArgument(7)); }
void IfcRelSequence::setSequenceType(IfcSequenceEnum::IfcSequenceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSequenceEnum::ToString(v)));data_->setArgument(7,attr);} }
bool IfcRelSequence::hasUserDefinedSequenceType() const { return !data_->getArgument(8)->isNull(); }
std::string IfcRelSequence::UserDefinedSequenceType() const { return *data_->getArgument(8); }
void IfcRelSequence::setUserDefinedSequenceType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcRelSequence::declaration() const { return *IfcRelSequence_type; }
const IfcParse::entity& IfcRelSequence::Class() { return *IfcRelSequence_type; }
IfcRelSequence::IfcRelSequence(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelSequence_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelSequence::IfcRelSequence(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcProcess* v5_RelatingProcess, IfcProcess* v6_RelatedProcess, IfcLagTime* v7_TimeLag, boost::optional< IfcSequenceEnum::IfcSequenceEnum > v8_SequenceType, boost::optional< std::string > v9_UserDefinedSequenceType) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelSequence_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingProcess));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedProcess));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_TimeLag));data_->setArgument(6,attr);} if (v8_SequenceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_SequenceType,IfcSequenceEnum::ToString(*v8_SequenceType))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_UserDefinedSequenceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_UserDefinedSequenceType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcRelServicesBuildings
IfcSystem* IfcRelServicesBuildings::RelatingSystem() const { return (IfcSystem*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelServicesBuildings::setRelatingSystem(IfcSystem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcSpatialElement >::ptr IfcRelServicesBuildings::RelatedBuildings() const { IfcEntityList::ptr es = *data_->getArgument(5); return es->as<IfcSpatialElement>(); }
void IfcRelServicesBuildings::setRelatedBuildings(IfcTemplatedEntityList< IfcSpatialElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelServicesBuildings::declaration() const { return *IfcRelServicesBuildings_type; }
const IfcParse::entity& IfcRelServicesBuildings::Class() { return *IfcRelServicesBuildings_type; }
IfcRelServicesBuildings::IfcRelServicesBuildings(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelServicesBuildings_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelServicesBuildings::IfcRelServicesBuildings(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSystem* v5_RelatingSystem, IfcTemplatedEntityList< IfcSpatialElement >::ptr v6_RelatedBuildings) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelServicesBuildings_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingSystem));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildings)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelSpaceBoundary
IfcSpaceBoundarySelect* IfcRelSpaceBoundary::RelatingSpace() const { return (IfcSpaceBoundarySelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelSpaceBoundary::setRelatingSpace(IfcSpaceBoundarySelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcElement* IfcRelSpaceBoundary::RelatedBuildingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelSpaceBoundary::setRelatedBuildingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcRelSpaceBoundary::hasConnectionGeometry() const { return !data_->getArgument(6)->isNull(); }
IfcConnectionGeometry* IfcRelSpaceBoundary::ConnectionGeometry() const { return (IfcConnectionGeometry*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcRelSpaceBoundary::setConnectionGeometry(IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum IfcRelSpaceBoundary::PhysicalOrVirtualBoundary() const { return IfcPhysicalOrVirtualEnum::FromString(*data_->getArgument(7)); }
void IfcRelSpaceBoundary::setPhysicalOrVirtualBoundary(IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPhysicalOrVirtualEnum::ToString(v)));data_->setArgument(7,attr);} }
IfcInternalOrExternalEnum::IfcInternalOrExternalEnum IfcRelSpaceBoundary::InternalOrExternalBoundary() const { return IfcInternalOrExternalEnum::FromString(*data_->getArgument(8)); }
void IfcRelSpaceBoundary::setInternalOrExternalBoundary(IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcInternalOrExternalEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcRelSpaceBoundary::declaration() const { return *IfcRelSpaceBoundary_type; }
const IfcParse::entity& IfcRelSpaceBoundary::Class() { return *IfcRelSpaceBoundary_type; }
IfcRelSpaceBoundary::IfcRelSpaceBoundary(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelSpaceBoundary_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelSpaceBoundary::IfcRelSpaceBoundary(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpaceBoundarySelect* v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelSpaceBoundary_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingSpace));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConnectionGeometry));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PhysicalOrVirtualBoundary,IfcPhysicalOrVirtualEnum::ToString(v8_PhysicalOrVirtualBoundary))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_InternalOrExternalBoundary,IfcInternalOrExternalEnum::ToString(v9_InternalOrExternalBoundary))));data_->setArgument(8,attr);} }

// Function implementations for IfcRelSpaceBoundary1stLevel
bool IfcRelSpaceBoundary1stLevel::hasParentBoundary() const { return !data_->getArgument(9)->isNull(); }
IfcRelSpaceBoundary1stLevel* IfcRelSpaceBoundary1stLevel::ParentBoundary() const { return (IfcRelSpaceBoundary1stLevel*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcRelSpaceBoundary1stLevel::setParentBoundary(IfcRelSpaceBoundary1stLevel* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }

IfcRelSpaceBoundary1stLevel::list::ptr IfcRelSpaceBoundary1stLevel::InnerBoundaries() const { return data_->getInverse(IfcRelSpaceBoundary1stLevel_type, 9)->as<IfcRelSpaceBoundary1stLevel>(); }

const IfcParse::entity& IfcRelSpaceBoundary1stLevel::declaration() const { return *IfcRelSpaceBoundary1stLevel_type; }
const IfcParse::entity& IfcRelSpaceBoundary1stLevel::Class() { return *IfcRelSpaceBoundary1stLevel_type; }
IfcRelSpaceBoundary1stLevel::IfcRelSpaceBoundary1stLevel(IfcEntityInstanceData* e) : IfcRelSpaceBoundary((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelSpaceBoundary1stLevel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelSpaceBoundary1stLevel::IfcRelSpaceBoundary1stLevel(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpaceBoundarySelect* v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel* v10_ParentBoundary) : IfcRelSpaceBoundary((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelSpaceBoundary1stLevel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingSpace));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConnectionGeometry));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PhysicalOrVirtualBoundary,IfcPhysicalOrVirtualEnum::ToString(v8_PhysicalOrVirtualBoundary))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_InternalOrExternalBoundary,IfcInternalOrExternalEnum::ToString(v9_InternalOrExternalBoundary))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ParentBoundary));data_->setArgument(9,attr);} }

// Function implementations for IfcRelSpaceBoundary2ndLevel
bool IfcRelSpaceBoundary2ndLevel::hasCorrespondingBoundary() const { return !data_->getArgument(10)->isNull(); }
IfcRelSpaceBoundary2ndLevel* IfcRelSpaceBoundary2ndLevel::CorrespondingBoundary() const { return (IfcRelSpaceBoundary2ndLevel*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(10))); }
void IfcRelSpaceBoundary2ndLevel::setCorrespondingBoundary(IfcRelSpaceBoundary2ndLevel* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }

IfcRelSpaceBoundary2ndLevel::list::ptr IfcRelSpaceBoundary2ndLevel::Corresponds() const { return data_->getInverse(IfcRelSpaceBoundary2ndLevel_type, 10)->as<IfcRelSpaceBoundary2ndLevel>(); }

const IfcParse::entity& IfcRelSpaceBoundary2ndLevel::declaration() const { return *IfcRelSpaceBoundary2ndLevel_type; }
const IfcParse::entity& IfcRelSpaceBoundary2ndLevel::Class() { return *IfcRelSpaceBoundary2ndLevel_type; }
IfcRelSpaceBoundary2ndLevel::IfcRelSpaceBoundary2ndLevel(IfcEntityInstanceData* e) : IfcRelSpaceBoundary1stLevel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelSpaceBoundary2ndLevel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelSpaceBoundary2ndLevel::IfcRelSpaceBoundary2ndLevel(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpaceBoundarySelect* v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel* v10_ParentBoundary, IfcRelSpaceBoundary2ndLevel* v11_CorrespondingBoundary) : IfcRelSpaceBoundary1stLevel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelSpaceBoundary2ndLevel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingSpace));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConnectionGeometry));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PhysicalOrVirtualBoundary,IfcPhysicalOrVirtualEnum::ToString(v8_PhysicalOrVirtualBoundary))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_InternalOrExternalBoundary,IfcInternalOrExternalEnum::ToString(v9_InternalOrExternalBoundary))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ParentBoundary));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CorrespondingBoundary));data_->setArgument(10,attr);} }

// Function implementations for IfcRelVoidsElement
IfcElement* IfcRelVoidsElement::RelatingBuildingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRelVoidsElement::setRelatingBuildingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcFeatureElementSubtraction* IfcRelVoidsElement::RelatedOpeningElement() const { return (IfcFeatureElementSubtraction*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcRelVoidsElement::setRelatedOpeningElement(IfcFeatureElementSubtraction* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRelVoidsElement::declaration() const { return *IfcRelVoidsElement_type; }
const IfcParse::entity& IfcRelVoidsElement::Class() { return *IfcRelVoidsElement_type; }
IfcRelVoidsElement::IfcRelVoidsElement(IfcEntityInstanceData* e) : IfcRelDecomposes((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelVoidsElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelVoidsElement::IfcRelVoidsElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingBuildingElement, IfcFeatureElementSubtraction* v6_RelatedOpeningElement) : IfcRelDecomposes((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelVoidsElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingBuildingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedOpeningElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelationship


const IfcParse::entity& IfcRelationship::declaration() const { return *IfcRelationship_type; }
const IfcParse::entity& IfcRelationship::Class() { return *IfcRelationship_type; }
IfcRelationship::IfcRelationship(IfcEntityInstanceData* e) : IfcRoot((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRelationship::IfcRelationship(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRoot((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcReparametrisedCompositeCurveSegment
double IfcReparametrisedCompositeCurveSegment::ParamLength() const { return *data_->getArgument(3); }
void IfcReparametrisedCompositeCurveSegment::setParamLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcReparametrisedCompositeCurveSegment::declaration() const { return *IfcReparametrisedCompositeCurveSegment_type; }
const IfcParse::entity& IfcReparametrisedCompositeCurveSegment::Class() { return *IfcReparametrisedCompositeCurveSegment_type; }
IfcReparametrisedCompositeCurveSegment::IfcReparametrisedCompositeCurveSegment(IfcEntityInstanceData* e) : IfcCompositeCurveSegment((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcReparametrisedCompositeCurveSegment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcReparametrisedCompositeCurveSegment::IfcReparametrisedCompositeCurveSegment(IfcTransitionCode::IfcTransitionCode v1_Transition, bool v2_SameSense, IfcCurve* v3_ParentCurve, double v4_ParamLength) : IfcCompositeCurveSegment((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcReparametrisedCompositeCurveSegment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Transition,IfcTransitionCode::ToString(v1_Transition))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SameSense));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentCurve));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ParamLength));data_->setArgument(3,attr);} }

// Function implementations for IfcRepresentation
IfcRepresentationContext* IfcRepresentation::ContextOfItems() const { return (IfcRepresentationContext*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcRepresentation::setContextOfItems(IfcRepresentationContext* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcRepresentation::hasRepresentationIdentifier() const { return !data_->getArgument(1)->isNull(); }
std::string IfcRepresentation::RepresentationIdentifier() const { return *data_->getArgument(1); }
void IfcRepresentation::setRepresentationIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcRepresentation::hasRepresentationType() const { return !data_->getArgument(2)->isNull(); }
std::string IfcRepresentation::RepresentationType() const { return *data_->getArgument(2); }
void IfcRepresentation::setRepresentationType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcRepresentationItem >::ptr IfcRepresentation::Items() const { IfcEntityList::ptr es = *data_->getArgument(3); return es->as<IfcRepresentationItem>(); }
void IfcRepresentation::setItems(IfcTemplatedEntityList< IfcRepresentationItem >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(3,attr);} }

IfcRepresentationMap::list::ptr IfcRepresentation::RepresentationMap() const { return data_->getInverse(IfcRepresentationMap_type, 1)->as<IfcRepresentationMap>(); }
IfcPresentationLayerAssignment::list::ptr IfcRepresentation::LayerAssignments() const { return data_->getInverse(IfcPresentationLayerAssignment_type, 2)->as<IfcPresentationLayerAssignment>(); }
IfcProductRepresentation::list::ptr IfcRepresentation::OfProductRepresentation() const { return data_->getInverse(IfcProductRepresentation_type, 2)->as<IfcProductRepresentation>(); }

const IfcParse::entity& IfcRepresentation::declaration() const { return *IfcRepresentation_type; }
const IfcParse::entity& IfcRepresentation::Class() { return *IfcRepresentation_type; }
IfcRepresentation::IfcRepresentation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcRepresentation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRepresentation::IfcRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcRepresentation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcRepresentationContext
bool IfcRepresentationContext::hasContextIdentifier() const { return !data_->getArgument(0)->isNull(); }
std::string IfcRepresentationContext::ContextIdentifier() const { return *data_->getArgument(0); }
void IfcRepresentationContext::setContextIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcRepresentationContext::hasContextType() const { return !data_->getArgument(1)->isNull(); }
std::string IfcRepresentationContext::ContextType() const { return *data_->getArgument(1); }
void IfcRepresentationContext::setContextType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }

IfcRepresentation::list::ptr IfcRepresentationContext::RepresentationsInContext() const { return data_->getInverse(IfcRepresentation_type, 0)->as<IfcRepresentation>(); }

const IfcParse::entity& IfcRepresentationContext::declaration() const { return *IfcRepresentationContext_type; }
const IfcParse::entity& IfcRepresentationContext::Class() { return *IfcRepresentationContext_type; }
IfcRepresentationContext::IfcRepresentationContext(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcRepresentationContext_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRepresentationContext::IfcRepresentationContext(boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcRepresentationContext_type);  if (v1_ContextIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ContextIdentifier));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ContextType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ContextType));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcRepresentationItem

IfcPresentationLayerAssignment::list::ptr IfcRepresentationItem::LayerAssignment() const { return data_->getInverse(IfcPresentationLayerAssignment_type, 2)->as<IfcPresentationLayerAssignment>(); }
IfcStyledItem::list::ptr IfcRepresentationItem::StyledByItem() const { return data_->getInverse(IfcStyledItem_type, 0)->as<IfcStyledItem>(); }

const IfcParse::entity& IfcRepresentationItem::declaration() const { return *IfcRepresentationItem_type; }
const IfcParse::entity& IfcRepresentationItem::Class() { return *IfcRepresentationItem_type; }
IfcRepresentationItem::IfcRepresentationItem(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcRepresentationItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRepresentationItem::IfcRepresentationItem() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcRepresentationItem_type);  }

// Function implementations for IfcRepresentationMap
IfcAxis2Placement* IfcRepresentationMap::MappingOrigin() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcRepresentationMap::setMappingOrigin(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcRepresentation* IfcRepresentationMap::MappedRepresentation() const { return (IfcRepresentation*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcRepresentationMap::setMappedRepresentation(IfcRepresentation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }

IfcShapeAspect::list::ptr IfcRepresentationMap::HasShapeAspects() const { return data_->getInverse(IfcShapeAspect_type, 4)->as<IfcShapeAspect>(); }
IfcMappedItem::list::ptr IfcRepresentationMap::MapUsage() const { return data_->getInverse(IfcMappedItem_type, 0)->as<IfcMappedItem>(); }

const IfcParse::entity& IfcRepresentationMap::declaration() const { return *IfcRepresentationMap_type; }
const IfcParse::entity& IfcRepresentationMap::Class() { return *IfcRepresentationMap_type; }
IfcRepresentationMap::IfcRepresentationMap(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcRepresentationMap_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRepresentationMap::IfcRepresentationMap(IfcAxis2Placement* v1_MappingOrigin, IfcRepresentation* v2_MappedRepresentation) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcRepresentationMap_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MappingOrigin));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MappedRepresentation));data_->setArgument(1,attr);} }

// Function implementations for IfcResource
bool IfcResource::hasIdentification() const { return !data_->getArgument(5)->isNull(); }
std::string IfcResource::Identification() const { return *data_->getArgument(5); }
void IfcResource::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcResource::hasLongDescription() const { return !data_->getArgument(6)->isNull(); }
std::string IfcResource::LongDescription() const { return *data_->getArgument(6); }
void IfcResource::setLongDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }

IfcRelAssignsToResource::list::ptr IfcResource::ResourceOf() const { return data_->getInverse(IfcRelAssignsToResource_type, 6)->as<IfcRelAssignsToResource>(); }

const IfcParse::entity& IfcResource::declaration() const { return *IfcResource_type; }
const IfcParse::entity& IfcResource::Class() { return *IfcResource_type; }
IfcResource::IfcResource(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcResource::IfcResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcResourceApprovalRelationship
IfcEntityList::ptr IfcResourceApprovalRelationship::RelatedResourceObjects() const { return *data_->getArgument(2); }
void IfcResourceApprovalRelationship::setRelatedResourceObjects(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcApproval* IfcResourceApprovalRelationship::RelatingApproval() const { return (IfcApproval*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcResourceApprovalRelationship::setRelatingApproval(IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcResourceApprovalRelationship::declaration() const { return *IfcResourceApprovalRelationship_type; }
const IfcParse::entity& IfcResourceApprovalRelationship::Class() { return *IfcResourceApprovalRelationship_type; }
IfcResourceApprovalRelationship::IfcResourceApprovalRelationship(IfcEntityInstanceData* e) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcResourceApprovalRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcResourceApprovalRelationship::IfcResourceApprovalRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_RelatedResourceObjects, IfcApproval* v4_RelatingApproval) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcResourceApprovalRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatedResourceObjects));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatingApproval));data_->setArgument(3,attr);} }

// Function implementations for IfcResourceConstraintRelationship
IfcConstraint* IfcResourceConstraintRelationship::RelatingConstraint() const { return (IfcConstraint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcResourceConstraintRelationship::setRelatingConstraint(IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcEntityList::ptr IfcResourceConstraintRelationship::RelatedResourceObjects() const { return *data_->getArgument(3); }
void IfcResourceConstraintRelationship::setRelatedResourceObjects(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcResourceConstraintRelationship::declaration() const { return *IfcResourceConstraintRelationship_type; }
const IfcParse::entity& IfcResourceConstraintRelationship::Class() { return *IfcResourceConstraintRelationship_type; }
IfcResourceConstraintRelationship::IfcResourceConstraintRelationship(IfcEntityInstanceData* e) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcResourceConstraintRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcResourceConstraintRelationship::IfcResourceConstraintRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcConstraint* v3_RelatingConstraint, IfcEntityList::ptr v4_RelatedResourceObjects) : IfcResourceLevelRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcResourceConstraintRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingConstraint));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedResourceObjects));data_->setArgument(3,attr);} }

// Function implementations for IfcResourceLevelRelationship
bool IfcResourceLevelRelationship::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcResourceLevelRelationship::Name() const { return *data_->getArgument(0); }
void IfcResourceLevelRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcResourceLevelRelationship::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcResourceLevelRelationship::Description() const { return *data_->getArgument(1); }
void IfcResourceLevelRelationship::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcResourceLevelRelationship::declaration() const { return *IfcResourceLevelRelationship_type; }
const IfcParse::entity& IfcResourceLevelRelationship::Class() { return *IfcResourceLevelRelationship_type; }
IfcResourceLevelRelationship::IfcResourceLevelRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcResourceLevelRelationship_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcResourceLevelRelationship::IfcResourceLevelRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcResourceLevelRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcResourceTime
bool IfcResourceTime::hasScheduleWork() const { return !data_->getArgument(3)->isNull(); }
std::string IfcResourceTime::ScheduleWork() const { return *data_->getArgument(3); }
void IfcResourceTime::setScheduleWork(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcResourceTime::hasScheduleUsage() const { return !data_->getArgument(4)->isNull(); }
double IfcResourceTime::ScheduleUsage() const { return *data_->getArgument(4); }
void IfcResourceTime::setScheduleUsage(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcResourceTime::hasScheduleStart() const { return !data_->getArgument(5)->isNull(); }
std::string IfcResourceTime::ScheduleStart() const { return *data_->getArgument(5); }
void IfcResourceTime::setScheduleStart(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcResourceTime::hasScheduleFinish() const { return !data_->getArgument(6)->isNull(); }
std::string IfcResourceTime::ScheduleFinish() const { return *data_->getArgument(6); }
void IfcResourceTime::setScheduleFinish(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcResourceTime::hasScheduleContour() const { return !data_->getArgument(7)->isNull(); }
std::string IfcResourceTime::ScheduleContour() const { return *data_->getArgument(7); }
void IfcResourceTime::setScheduleContour(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcResourceTime::hasLevelingDelay() const { return !data_->getArgument(8)->isNull(); }
std::string IfcResourceTime::LevelingDelay() const { return *data_->getArgument(8); }
void IfcResourceTime::setLevelingDelay(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcResourceTime::hasIsOverAllocated() const { return !data_->getArgument(9)->isNull(); }
bool IfcResourceTime::IsOverAllocated() const { return *data_->getArgument(9); }
void IfcResourceTime::setIsOverAllocated(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcResourceTime::hasStatusTime() const { return !data_->getArgument(10)->isNull(); }
std::string IfcResourceTime::StatusTime() const { return *data_->getArgument(10); }
void IfcResourceTime::setStatusTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcResourceTime::hasActualWork() const { return !data_->getArgument(11)->isNull(); }
std::string IfcResourceTime::ActualWork() const { return *data_->getArgument(11); }
void IfcResourceTime::setActualWork(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcResourceTime::hasActualUsage() const { return !data_->getArgument(12)->isNull(); }
double IfcResourceTime::ActualUsage() const { return *data_->getArgument(12); }
void IfcResourceTime::setActualUsage(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcResourceTime::hasActualStart() const { return !data_->getArgument(13)->isNull(); }
std::string IfcResourceTime::ActualStart() const { return *data_->getArgument(13); }
void IfcResourceTime::setActualStart(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
bool IfcResourceTime::hasActualFinish() const { return !data_->getArgument(14)->isNull(); }
std::string IfcResourceTime::ActualFinish() const { return *data_->getArgument(14); }
void IfcResourceTime::setActualFinish(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
bool IfcResourceTime::hasRemainingWork() const { return !data_->getArgument(15)->isNull(); }
std::string IfcResourceTime::RemainingWork() const { return *data_->getArgument(15); }
void IfcResourceTime::setRemainingWork(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }
bool IfcResourceTime::hasRemainingUsage() const { return !data_->getArgument(16)->isNull(); }
double IfcResourceTime::RemainingUsage() const { return *data_->getArgument(16); }
void IfcResourceTime::setRemainingUsage(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(16,attr);} }
bool IfcResourceTime::hasCompletion() const { return !data_->getArgument(17)->isNull(); }
double IfcResourceTime::Completion() const { return *data_->getArgument(17); }
void IfcResourceTime::setCompletion(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(17,attr);} }


const IfcParse::entity& IfcResourceTime::declaration() const { return *IfcResourceTime_type; }
const IfcParse::entity& IfcResourceTime::Class() { return *IfcResourceTime_type; }
IfcResourceTime::IfcResourceTime(IfcEntityInstanceData* e) : IfcSchedulingTime((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcResourceTime_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcResourceTime::IfcResourceTime(boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, boost::optional< std::string > v4_ScheduleWork, boost::optional< double > v5_ScheduleUsage, boost::optional< std::string > v6_ScheduleStart, boost::optional< std::string > v7_ScheduleFinish, boost::optional< std::string > v8_ScheduleContour, boost::optional< std::string > v9_LevelingDelay, boost::optional< bool > v10_IsOverAllocated, boost::optional< std::string > v11_StatusTime, boost::optional< std::string > v12_ActualWork, boost::optional< double > v13_ActualUsage, boost::optional< std::string > v14_ActualStart, boost::optional< std::string > v15_ActualFinish, boost::optional< std::string > v16_RemainingWork, boost::optional< double > v17_RemainingUsage, boost::optional< double > v18_Completion) : IfcSchedulingTime((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcResourceTime_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin))));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedDataOrigin));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ScheduleWork) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ScheduleWork));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ScheduleUsage) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ScheduleUsage));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ScheduleStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ScheduleStart));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ScheduleFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ScheduleFinish));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ScheduleContour) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_ScheduleContour));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_LevelingDelay) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_LevelingDelay));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_IsOverAllocated) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_IsOverAllocated));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_StatusTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_StatusTime));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_ActualWork) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_ActualWork));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_ActualUsage) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_ActualUsage));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_ActualStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_ActualStart));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_ActualFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_ActualFinish));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_RemainingWork) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_RemainingWork));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_RemainingUsage) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_RemainingUsage));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } if (v18_Completion) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_Completion));data_->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(17, attr); } }

// Function implementations for IfcRevolvedAreaSolid
IfcAxis1Placement* IfcRevolvedAreaSolid::Axis() const { return (IfcAxis1Placement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcRevolvedAreaSolid::setAxis(IfcAxis1Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double IfcRevolvedAreaSolid::Angle() const { return *data_->getArgument(3); }
void IfcRevolvedAreaSolid::setAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcRevolvedAreaSolid::declaration() const { return *IfcRevolvedAreaSolid_type; }
const IfcParse::entity& IfcRevolvedAreaSolid::Class() { return *IfcRevolvedAreaSolid_type; }
IfcRevolvedAreaSolid::IfcRevolvedAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRevolvedAreaSolid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRevolvedAreaSolid::IfcRevolvedAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_Axis, double v4_Angle) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRevolvedAreaSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Axis));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Angle));data_->setArgument(3,attr);} }

// Function implementations for IfcRevolvedAreaSolidTapered
IfcProfileDef* IfcRevolvedAreaSolidTapered::EndSweptArea() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcRevolvedAreaSolidTapered::setEndSweptArea(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcRevolvedAreaSolidTapered::declaration() const { return *IfcRevolvedAreaSolidTapered_type; }
const IfcParse::entity& IfcRevolvedAreaSolidTapered::Class() { return *IfcRevolvedAreaSolidTapered_type; }
IfcRevolvedAreaSolidTapered::IfcRevolvedAreaSolidTapered(IfcEntityInstanceData* e) : IfcRevolvedAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRevolvedAreaSolidTapered_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRevolvedAreaSolidTapered::IfcRevolvedAreaSolidTapered(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_Axis, double v4_Angle, IfcProfileDef* v5_EndSweptArea) : IfcRevolvedAreaSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRevolvedAreaSolidTapered_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Axis));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Angle));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_EndSweptArea));data_->setArgument(4,attr);} }

// Function implementations for IfcRightCircularCone
double IfcRightCircularCone::Height() const { return *data_->getArgument(1); }
void IfcRightCircularCone::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcRightCircularCone::BottomRadius() const { return *data_->getArgument(2); }
void IfcRightCircularCone::setBottomRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcRightCircularCone::declaration() const { return *IfcRightCircularCone_type; }
const IfcParse::entity& IfcRightCircularCone::Class() { return *IfcRightCircularCone_type; }
IfcRightCircularCone::IfcRightCircularCone(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRightCircularCone_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRightCircularCone::IfcRightCircularCone(IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_BottomRadius) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRightCircularCone_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Height));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_BottomRadius));data_->setArgument(2,attr);} }

// Function implementations for IfcRightCircularCylinder
double IfcRightCircularCylinder::Height() const { return *data_->getArgument(1); }
void IfcRightCircularCylinder::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double IfcRightCircularCylinder::Radius() const { return *data_->getArgument(2); }
void IfcRightCircularCylinder::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcRightCircularCylinder::declaration() const { return *IfcRightCircularCylinder_type; }
const IfcParse::entity& IfcRightCircularCylinder::Class() { return *IfcRightCircularCylinder_type; }
IfcRightCircularCylinder::IfcRightCircularCylinder(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRightCircularCylinder_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRightCircularCylinder::IfcRightCircularCylinder(IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_Radius) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRightCircularCylinder_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Height));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Radius));data_->setArgument(2,attr);} }

// Function implementations for IfcRoof
bool IfcRoof::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcRoofTypeEnum::IfcRoofTypeEnum IfcRoof::PredefinedType() const { return IfcRoofTypeEnum::FromString(*data_->getArgument(8)); }
void IfcRoof::setPredefinedType(IfcRoofTypeEnum::IfcRoofTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRoofTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcRoof::declaration() const { return *IfcRoof_type; }
const IfcParse::entity& IfcRoof::Class() { return *IfcRoof_type; }
IfcRoof::IfcRoof(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRoof_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRoof::IfcRoof(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRoofTypeEnum::IfcRoofTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRoof_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcRoofTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcRoofType
IfcRoofTypeEnum::IfcRoofTypeEnum IfcRoofType::PredefinedType() const { return IfcRoofTypeEnum::FromString(*data_->getArgument(9)); }
void IfcRoofType::setPredefinedType(IfcRoofTypeEnum::IfcRoofTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRoofTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcRoofType::declaration() const { return *IfcRoofType_type; }
const IfcParse::entity& IfcRoofType::Class() { return *IfcRoofType_type; }
IfcRoofType::IfcRoofType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRoofType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRoofType::IfcRoofType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRoofTypeEnum::IfcRoofTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRoofType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcRoofTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcRoot
std::string IfcRoot::GlobalId() const { return *data_->getArgument(0); }
void IfcRoot::setGlobalId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcRoot::hasOwnerHistory() const { return !data_->getArgument(1)->isNull(); }
IfcOwnerHistory* IfcRoot::OwnerHistory() const { return (IfcOwnerHistory*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcRoot::setOwnerHistory(IfcOwnerHistory* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcRoot::hasName() const { return !data_->getArgument(2)->isNull(); }
std::string IfcRoot::Name() const { return *data_->getArgument(2); }
void IfcRoot::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcRoot::hasDescription() const { return !data_->getArgument(3)->isNull(); }
std::string IfcRoot::Description() const { return *data_->getArgument(3); }
void IfcRoot::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcRoot::declaration() const { return *IfcRoot_type; }
const IfcParse::entity& IfcRoot::Class() { return *IfcRoot_type; }
IfcRoot::IfcRoot(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcRoot_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRoot::IfcRoot(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcRoot_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcRoundedRectangleProfileDef
double IfcRoundedRectangleProfileDef::RoundingRadius() const { return *data_->getArgument(5); }
void IfcRoundedRectangleProfileDef::setRoundingRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcRoundedRectangleProfileDef::declaration() const { return *IfcRoundedRectangleProfileDef_type; }
const IfcParse::entity& IfcRoundedRectangleProfileDef::Class() { return *IfcRoundedRectangleProfileDef_type; }
IfcRoundedRectangleProfileDef::IfcRoundedRectangleProfileDef(IfcEntityInstanceData* e) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcRoundedRectangleProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcRoundedRectangleProfileDef::IfcRoundedRectangleProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_RoundingRadius) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcRoundedRectangleProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_XDim));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_YDim));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RoundingRadius));data_->setArgument(5,attr);} }

// Function implementations for IfcSIUnit
bool IfcSIUnit::hasPrefix() const { return !data_->getArgument(2)->isNull(); }
IfcSIPrefix::IfcSIPrefix IfcSIUnit::Prefix() const { return IfcSIPrefix::FromString(*data_->getArgument(2)); }
void IfcSIUnit::setPrefix(IfcSIPrefix::IfcSIPrefix v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSIPrefix::ToString(v)));data_->setArgument(2,attr);} }
IfcSIUnitName::IfcSIUnitName IfcSIUnit::Name() const { return IfcSIUnitName::FromString(*data_->getArgument(3)); }
void IfcSIUnit::setName(IfcSIUnitName::IfcSIUnitName v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSIUnitName::ToString(v)));data_->setArgument(3,attr);} }


const IfcParse::entity& IfcSIUnit::declaration() const { return *IfcSIUnit_type; }
const IfcParse::entity& IfcSIUnit::Class() { return *IfcSIUnit_type; }
IfcSIUnit::IfcSIUnit(IfcEntityInstanceData* e) : IfcNamedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSIUnit_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSIUnit::IfcSIUnit(IfcUnitEnum::IfcUnitEnum v2_UnitType, boost::optional< IfcSIPrefix::IfcSIPrefix > v3_Prefix, IfcSIUnitName::IfcSIUnitName v4_Name) : IfcNamedUnit((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSIUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);} if (v3_Prefix) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v3_Prefix,IfcSIPrefix::ToString(*v3_Prefix))));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_Name,IfcSIUnitName::ToString(v4_Name))));data_->setArgument(3,attr);} }

// Function implementations for IfcSanitaryTerminal
bool IfcSanitaryTerminal::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum IfcSanitaryTerminal::PredefinedType() const { return IfcSanitaryTerminalTypeEnum::FromString(*data_->getArgument(8)); }
void IfcSanitaryTerminal::setPredefinedType(IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSanitaryTerminalTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSanitaryTerminal::declaration() const { return *IfcSanitaryTerminal_type; }
const IfcParse::entity& IfcSanitaryTerminal::Class() { return *IfcSanitaryTerminal_type; }
IfcSanitaryTerminal::IfcSanitaryTerminal(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSanitaryTerminal_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSanitaryTerminal::IfcSanitaryTerminal(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSanitaryTerminal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSanitaryTerminalTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSanitaryTerminalType
IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum IfcSanitaryTerminalType::PredefinedType() const { return IfcSanitaryTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSanitaryTerminalType::setPredefinedType(IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSanitaryTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcSanitaryTerminalType::declaration() const { return *IfcSanitaryTerminalType_type; }
const IfcParse::entity& IfcSanitaryTerminalType::Class() { return *IfcSanitaryTerminalType_type; }
IfcSanitaryTerminalType::IfcSanitaryTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSanitaryTerminalType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSanitaryTerminalType::IfcSanitaryTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSanitaryTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSanitaryTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcSchedulingTime
bool IfcSchedulingTime::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcSchedulingTime::Name() const { return *data_->getArgument(0); }
void IfcSchedulingTime::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcSchedulingTime::hasDataOrigin() const { return !data_->getArgument(1)->isNull(); }
IfcDataOriginEnum::IfcDataOriginEnum IfcSchedulingTime::DataOrigin() const { return IfcDataOriginEnum::FromString(*data_->getArgument(1)); }
void IfcSchedulingTime::setDataOrigin(IfcDataOriginEnum::IfcDataOriginEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDataOriginEnum::ToString(v)));data_->setArgument(1,attr);} }
bool IfcSchedulingTime::hasUserDefinedDataOrigin() const { return !data_->getArgument(2)->isNull(); }
std::string IfcSchedulingTime::UserDefinedDataOrigin() const { return *data_->getArgument(2); }
void IfcSchedulingTime::setUserDefinedDataOrigin(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcSchedulingTime::declaration() const { return *IfcSchedulingTime_type; }
const IfcParse::entity& IfcSchedulingTime::Class() { return *IfcSchedulingTime_type; }
IfcSchedulingTime::IfcSchedulingTime(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcSchedulingTime_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSchedulingTime::IfcSchedulingTime(boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcSchedulingTime_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin))));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedDataOrigin));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcSectionProperties
IfcSectionTypeEnum::IfcSectionTypeEnum IfcSectionProperties::SectionType() const { return IfcSectionTypeEnum::FromString(*data_->getArgument(0)); }
void IfcSectionProperties::setSectionType(IfcSectionTypeEnum::IfcSectionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSectionTypeEnum::ToString(v)));data_->setArgument(0,attr);} }
IfcProfileDef* IfcSectionProperties::StartProfile() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcSectionProperties::setStartProfile(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcSectionProperties::hasEndProfile() const { return !data_->getArgument(2)->isNull(); }
IfcProfileDef* IfcSectionProperties::EndProfile() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcSectionProperties::setEndProfile(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcSectionProperties::declaration() const { return *IfcSectionProperties_type; }
const IfcParse::entity& IfcSectionProperties::Class() { return *IfcSectionProperties_type; }
IfcSectionProperties::IfcSectionProperties(IfcEntityInstanceData* e) : IfcPreDefinedProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSectionProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSectionProperties::IfcSectionProperties(IfcSectionTypeEnum::IfcSectionTypeEnum v1_SectionType, IfcProfileDef* v2_StartProfile, IfcProfileDef* v3_EndProfile) : IfcPreDefinedProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSectionProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_SectionType,IfcSectionTypeEnum::ToString(v1_SectionType))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_StartProfile));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EndProfile));data_->setArgument(2,attr);} }

// Function implementations for IfcSectionReinforcementProperties
double IfcSectionReinforcementProperties::LongitudinalStartPosition() const { return *data_->getArgument(0); }
void IfcSectionReinforcementProperties::setLongitudinalStartPosition(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcSectionReinforcementProperties::LongitudinalEndPosition() const { return *data_->getArgument(1); }
void IfcSectionReinforcementProperties::setLongitudinalEndPosition(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcSectionReinforcementProperties::hasTransversePosition() const { return !data_->getArgument(2)->isNull(); }
double IfcSectionReinforcementProperties::TransversePosition() const { return *data_->getArgument(2); }
void IfcSectionReinforcementProperties::setTransversePosition(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum IfcSectionReinforcementProperties::ReinforcementRole() const { return IfcReinforcingBarRoleEnum::FromString(*data_->getArgument(3)); }
void IfcSectionReinforcementProperties::setReinforcementRole(IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarRoleEnum::ToString(v)));data_->setArgument(3,attr);} }
IfcSectionProperties* IfcSectionReinforcementProperties::SectionDefinition() const { return (IfcSectionProperties*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcSectionReinforcementProperties::setSectionDefinition(IfcSectionProperties* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr IfcSectionReinforcementProperties::CrossSectionReinforcementDefinitions() const { IfcEntityList::ptr es = *data_->getArgument(5); return es->as<IfcReinforcementBarProperties>(); }
void IfcSectionReinforcementProperties::setCrossSectionReinforcementDefinitions(IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& IfcSectionReinforcementProperties::declaration() const { return *IfcSectionReinforcementProperties_type; }
const IfcParse::entity& IfcSectionReinforcementProperties::Class() { return *IfcSectionReinforcementProperties_type; }
IfcSectionReinforcementProperties::IfcSectionReinforcementProperties(IfcEntityInstanceData* e) : IfcPreDefinedProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSectionReinforcementProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSectionReinforcementProperties::IfcSectionReinforcementProperties(double v1_LongitudinalStartPosition, double v2_LongitudinalEndPosition, boost::optional< double > v3_TransversePosition, IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v4_ReinforcementRole, IfcSectionProperties* v5_SectionDefinition, IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr v6_CrossSectionReinforcementDefinitions) : IfcPreDefinedProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSectionReinforcementProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LongitudinalStartPosition));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LongitudinalEndPosition));data_->setArgument(1,attr);} if (v3_TransversePosition) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_TransversePosition));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_ReinforcementRole,IfcReinforcingBarRoleEnum::ToString(v4_ReinforcementRole))));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SectionDefinition));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_CrossSectionReinforcementDefinitions)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcSectionedSpine
IfcCompositeCurve* IfcSectionedSpine::SpineCurve() const { return (IfcCompositeCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcSectionedSpine::setSpineCurve(IfcCompositeCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcProfileDef >::ptr IfcSectionedSpine::CrossSections() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcProfileDef>(); }
void IfcSectionedSpine::setCrossSections(IfcTemplatedEntityList< IfcProfileDef >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }
IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr IfcSectionedSpine::CrossSectionPositions() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcAxis2Placement3D>(); }
void IfcSectionedSpine::setCrossSectionPositions(IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& IfcSectionedSpine::declaration() const { return *IfcSectionedSpine_type; }
const IfcParse::entity& IfcSectionedSpine::Class() { return *IfcSectionedSpine_type; }
IfcSectionedSpine::IfcSectionedSpine(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSectionedSpine_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSectionedSpine::IfcSectionedSpine(IfcCompositeCurve* v1_SpineCurve, IfcTemplatedEntityList< IfcProfileDef >::ptr v2_CrossSections, IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr v3_CrossSectionPositions) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSectionedSpine_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SpineCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CrossSections)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CrossSectionPositions)->generalize());data_->setArgument(2,attr);} }

// Function implementations for IfcSensor
bool IfcSensor::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcSensorTypeEnum::IfcSensorTypeEnum IfcSensor::PredefinedType() const { return IfcSensorTypeEnum::FromString(*data_->getArgument(8)); }
void IfcSensor::setPredefinedType(IfcSensorTypeEnum::IfcSensorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSensorTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSensor::declaration() const { return *IfcSensor_type; }
const IfcParse::entity& IfcSensor::Class() { return *IfcSensor_type; }
IfcSensor::IfcSensor(IfcEntityInstanceData* e) : IfcDistributionControlElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSensor_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSensor::IfcSensor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSensorTypeEnum::IfcSensorTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSensor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSensorTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSensorType
IfcSensorTypeEnum::IfcSensorTypeEnum IfcSensorType::PredefinedType() const { return IfcSensorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSensorType::setPredefinedType(IfcSensorTypeEnum::IfcSensorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSensorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcSensorType::declaration() const { return *IfcSensorType_type; }
const IfcParse::entity& IfcSensorType::Class() { return *IfcSensorType_type; }
IfcSensorType::IfcSensorType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSensorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSensorType::IfcSensorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSensorTypeEnum::IfcSensorTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSensorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSensorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcShadingDevice
bool IfcShadingDevice::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum IfcShadingDevice::PredefinedType() const { return IfcShadingDeviceTypeEnum::FromString(*data_->getArgument(8)); }
void IfcShadingDevice::setPredefinedType(IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcShadingDeviceTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcShadingDevice::declaration() const { return *IfcShadingDevice_type; }
const IfcParse::entity& IfcShadingDevice::Class() { return *IfcShadingDevice_type; }
IfcShadingDevice::IfcShadingDevice(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcShadingDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcShadingDevice::IfcShadingDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcShadingDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcShadingDeviceTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcShadingDeviceType
IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum IfcShadingDeviceType::PredefinedType() const { return IfcShadingDeviceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcShadingDeviceType::setPredefinedType(IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcShadingDeviceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcShadingDeviceType::declaration() const { return *IfcShadingDeviceType_type; }
const IfcParse::entity& IfcShadingDeviceType::Class() { return *IfcShadingDeviceType_type; }
IfcShadingDeviceType::IfcShadingDeviceType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcShadingDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcShadingDeviceType::IfcShadingDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcShadingDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcShadingDeviceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcShapeAspect
IfcTemplatedEntityList< IfcShapeModel >::ptr IfcShapeAspect::ShapeRepresentations() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcShapeModel>(); }
void IfcShapeAspect::setShapeRepresentations(IfcTemplatedEntityList< IfcShapeModel >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }
bool IfcShapeAspect::hasName() const { return !data_->getArgument(1)->isNull(); }
std::string IfcShapeAspect::Name() const { return *data_->getArgument(1); }
void IfcShapeAspect::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcShapeAspect::hasDescription() const { return !data_->getArgument(2)->isNull(); }
std::string IfcShapeAspect::Description() const { return *data_->getArgument(2); }
void IfcShapeAspect::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcShapeAspect::ProductDefinitional() const { return *data_->getArgument(3); }
void IfcShapeAspect::setProductDefinitional(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcShapeAspect::hasPartOfProductDefinitionShape() const { return !data_->getArgument(4)->isNull(); }
IfcProductRepresentationSelect* IfcShapeAspect::PartOfProductDefinitionShape() const { return (IfcProductRepresentationSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcShapeAspect::setPartOfProductDefinitionShape(IfcProductRepresentationSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcShapeAspect::declaration() const { return *IfcShapeAspect_type; }
const IfcParse::entity& IfcShapeAspect::Class() { return *IfcShapeAspect_type; }
IfcShapeAspect::IfcShapeAspect(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcShapeAspect_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcShapeAspect::IfcShapeAspect(IfcTemplatedEntityList< IfcShapeModel >::ptr v1_ShapeRepresentations, boost::optional< std::string > v2_Name, boost::optional< std::string > v3_Description, bool v4_ProductDefinitional, IfcProductRepresentationSelect* v5_PartOfProductDefinitionShape) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcShapeAspect_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ShapeRepresentations)->generalize());data_->setArgument(0,attr);} if (v2_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Name));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ProductDefinitional));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_PartOfProductDefinitionShape));data_->setArgument(4,attr);} }

// Function implementations for IfcShapeModel

IfcShapeAspect::list::ptr IfcShapeModel::OfShapeAspect() const { return data_->getInverse(IfcShapeAspect_type, 0)->as<IfcShapeAspect>(); }

const IfcParse::entity& IfcShapeModel::declaration() const { return *IfcShapeModel_type; }
const IfcParse::entity& IfcShapeModel::Class() { return *IfcShapeModel_type; }
IfcShapeModel::IfcShapeModel(IfcEntityInstanceData* e) : IfcRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcShapeModel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcShapeModel::IfcShapeModel(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcRepresentation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcShapeModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcShapeRepresentation


const IfcParse::entity& IfcShapeRepresentation::declaration() const { return *IfcShapeRepresentation_type; }
const IfcParse::entity& IfcShapeRepresentation::Class() { return *IfcShapeRepresentation_type; }
IfcShapeRepresentation::IfcShapeRepresentation(IfcEntityInstanceData* e) : IfcShapeModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcShapeRepresentation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcShapeRepresentation::IfcShapeRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcShapeModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcShapeRepresentation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcShellBasedSurfaceModel
IfcEntityList::ptr IfcShellBasedSurfaceModel::SbsmBoundary() const { return *data_->getArgument(0); }
void IfcShellBasedSurfaceModel::setSbsmBoundary(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcShellBasedSurfaceModel::declaration() const { return *IfcShellBasedSurfaceModel_type; }
const IfcParse::entity& IfcShellBasedSurfaceModel::Class() { return *IfcShellBasedSurfaceModel_type; }
IfcShellBasedSurfaceModel::IfcShellBasedSurfaceModel(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcShellBasedSurfaceModel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcShellBasedSurfaceModel::IfcShellBasedSurfaceModel(IfcEntityList::ptr v1_SbsmBoundary) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcShellBasedSurfaceModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SbsmBoundary));data_->setArgument(0,attr);} }

// Function implementations for IfcSimpleProperty


const IfcParse::entity& IfcSimpleProperty::declaration() const { return *IfcSimpleProperty_type; }
const IfcParse::entity& IfcSimpleProperty::Class() { return *IfcSimpleProperty_type; }
IfcSimpleProperty::IfcSimpleProperty(IfcEntityInstanceData* e) : IfcProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSimpleProperty_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSimpleProperty::IfcSimpleProperty(std::string v1_Name, boost::optional< std::string > v2_Description) : IfcProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSimpleProperty_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcSimplePropertyTemplate
bool IfcSimplePropertyTemplate::hasTemplateType() const { return !data_->getArgument(4)->isNull(); }
IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum IfcSimplePropertyTemplate::TemplateType() const { return IfcSimplePropertyTemplateTypeEnum::FromString(*data_->getArgument(4)); }
void IfcSimplePropertyTemplate::setTemplateType(IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSimplePropertyTemplateTypeEnum::ToString(v)));data_->setArgument(4,attr);} }
bool IfcSimplePropertyTemplate::hasPrimaryMeasureType() const { return !data_->getArgument(5)->isNull(); }
std::string IfcSimplePropertyTemplate::PrimaryMeasureType() const { return *data_->getArgument(5); }
void IfcSimplePropertyTemplate::setPrimaryMeasureType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcSimplePropertyTemplate::hasSecondaryMeasureType() const { return !data_->getArgument(6)->isNull(); }
std::string IfcSimplePropertyTemplate::SecondaryMeasureType() const { return *data_->getArgument(6); }
void IfcSimplePropertyTemplate::setSecondaryMeasureType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcSimplePropertyTemplate::hasEnumerators() const { return !data_->getArgument(7)->isNull(); }
IfcPropertyEnumeration* IfcSimplePropertyTemplate::Enumerators() const { return (IfcPropertyEnumeration*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcSimplePropertyTemplate::setEnumerators(IfcPropertyEnumeration* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcSimplePropertyTemplate::hasPrimaryUnit() const { return !data_->getArgument(8)->isNull(); }
IfcUnit* IfcSimplePropertyTemplate::PrimaryUnit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcSimplePropertyTemplate::setPrimaryUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcSimplePropertyTemplate::hasSecondaryUnit() const { return !data_->getArgument(9)->isNull(); }
IfcUnit* IfcSimplePropertyTemplate::SecondaryUnit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcSimplePropertyTemplate::setSecondaryUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcSimplePropertyTemplate::hasExpression() const { return !data_->getArgument(10)->isNull(); }
std::string IfcSimplePropertyTemplate::Expression() const { return *data_->getArgument(10); }
void IfcSimplePropertyTemplate::setExpression(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcSimplePropertyTemplate::hasAccessState() const { return !data_->getArgument(11)->isNull(); }
IfcStateEnum::IfcStateEnum IfcSimplePropertyTemplate::AccessState() const { return IfcStateEnum::FromString(*data_->getArgument(11)); }
void IfcSimplePropertyTemplate::setAccessState(IfcStateEnum::IfcStateEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStateEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcSimplePropertyTemplate::declaration() const { return *IfcSimplePropertyTemplate_type; }
const IfcParse::entity& IfcSimplePropertyTemplate::Class() { return *IfcSimplePropertyTemplate_type; }
IfcSimplePropertyTemplate::IfcSimplePropertyTemplate(IfcEntityInstanceData* e) : IfcPropertyTemplate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSimplePropertyTemplate_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSimplePropertyTemplate::IfcSimplePropertyTemplate(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum > v5_TemplateType, boost::optional< std::string > v6_PrimaryMeasureType, boost::optional< std::string > v7_SecondaryMeasureType, IfcPropertyEnumeration* v8_Enumerators, IfcUnit* v9_PrimaryUnit, IfcUnit* v10_SecondaryUnit, boost::optional< std::string > v11_Expression, boost::optional< IfcStateEnum::IfcStateEnum > v12_AccessState) : IfcPropertyTemplate((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSimplePropertyTemplate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_TemplateType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v5_TemplateType,IfcSimplePropertyTemplateTypeEnum::ToString(*v5_TemplateType))));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_PrimaryMeasureType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_PrimaryMeasureType));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_SecondaryMeasureType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_SecondaryMeasureType));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Enumerators));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_PrimaryUnit));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_SecondaryUnit));data_->setArgument(9,attr);} if (v11_Expression) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_Expression));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_AccessState) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v12_AccessState,IfcStateEnum::ToString(*v12_AccessState))));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } }

// Function implementations for IfcSite
bool IfcSite::hasRefLatitude() const { return !data_->getArgument(9)->isNull(); }
std::vector< int > /*[3:4]*/ IfcSite::RefLatitude() const { return *data_->getArgument(9); }
void IfcSite::setRefLatitude(std::vector< int > /*[3:4]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcSite::hasRefLongitude() const { return !data_->getArgument(10)->isNull(); }
std::vector< int > /*[3:4]*/ IfcSite::RefLongitude() const { return *data_->getArgument(10); }
void IfcSite::setRefLongitude(std::vector< int > /*[3:4]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcSite::hasRefElevation() const { return !data_->getArgument(11)->isNull(); }
double IfcSite::RefElevation() const { return *data_->getArgument(11); }
void IfcSite::setRefElevation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcSite::hasLandTitleNumber() const { return !data_->getArgument(12)->isNull(); }
std::string IfcSite::LandTitleNumber() const { return *data_->getArgument(12); }
void IfcSite::setLandTitleNumber(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcSite::hasSiteAddress() const { return !data_->getArgument(13)->isNull(); }
IfcPostalAddress* IfcSite::SiteAddress() const { return (IfcPostalAddress*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(13))); }
void IfcSite::setSiteAddress(IfcPostalAddress* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }


const IfcParse::entity& IfcSite::declaration() const { return *IfcSite_type; }
const IfcParse::entity& IfcSite::Class() { return *IfcSite_type; }
IfcSite::IfcSite(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSite_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSite::IfcSite(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< std::vector< int > /*[3:4]*/ > v10_RefLatitude, boost::optional< std::vector< int > /*[3:4]*/ > v11_RefLongitude, boost::optional< double > v12_RefElevation, boost::optional< std::string > v13_LandTitleNumber, IfcPostalAddress* v14_SiteAddress) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSite_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_CompositionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_RefLatitude) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_RefLatitude));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_RefLongitude) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_RefLongitude));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_RefElevation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_RefElevation));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_LandTitleNumber) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_LandTitleNumber));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_SiteAddress));data_->setArgument(13,attr);} }

// Function implementations for IfcSlab
bool IfcSlab::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcSlabTypeEnum::IfcSlabTypeEnum IfcSlab::PredefinedType() const { return IfcSlabTypeEnum::FromString(*data_->getArgument(8)); }
void IfcSlab::setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSlabTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSlab::declaration() const { return *IfcSlab_type; }
const IfcParse::entity& IfcSlab::Class() { return *IfcSlab_type; }
IfcSlab::IfcSlab(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSlab_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSlab::IfcSlab(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSlab_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSlabTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSlabElementedCase


const IfcParse::entity& IfcSlabElementedCase::declaration() const { return *IfcSlabElementedCase_type; }
const IfcParse::entity& IfcSlabElementedCase::Class() { return *IfcSlabElementedCase_type; }
IfcSlabElementedCase::IfcSlabElementedCase(IfcEntityInstanceData* e) : IfcSlab((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSlabElementedCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSlabElementedCase::IfcSlabElementedCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType) : IfcSlab((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSlabElementedCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSlabTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSlabStandardCase


const IfcParse::entity& IfcSlabStandardCase::declaration() const { return *IfcSlabStandardCase_type; }
const IfcParse::entity& IfcSlabStandardCase::Class() { return *IfcSlabStandardCase_type; }
IfcSlabStandardCase::IfcSlabStandardCase(IfcEntityInstanceData* e) : IfcSlab((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSlabStandardCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSlabStandardCase::IfcSlabStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType) : IfcSlab((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSlabStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSlabTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSlabType
IfcSlabTypeEnum::IfcSlabTypeEnum IfcSlabType::PredefinedType() const { return IfcSlabTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSlabType::setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSlabTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcSlabType::declaration() const { return *IfcSlabType_type; }
const IfcParse::entity& IfcSlabType::Class() { return *IfcSlabType_type; }
IfcSlabType::IfcSlabType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSlabType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSlabType::IfcSlabType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSlabTypeEnum::IfcSlabTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSlabType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSlabTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcSlippageConnectionCondition
bool IfcSlippageConnectionCondition::hasSlippageX() const { return !data_->getArgument(1)->isNull(); }
double IfcSlippageConnectionCondition::SlippageX() const { return *data_->getArgument(1); }
void IfcSlippageConnectionCondition::setSlippageX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcSlippageConnectionCondition::hasSlippageY() const { return !data_->getArgument(2)->isNull(); }
double IfcSlippageConnectionCondition::SlippageY() const { return *data_->getArgument(2); }
void IfcSlippageConnectionCondition::setSlippageY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcSlippageConnectionCondition::hasSlippageZ() const { return !data_->getArgument(3)->isNull(); }
double IfcSlippageConnectionCondition::SlippageZ() const { return *data_->getArgument(3); }
void IfcSlippageConnectionCondition::setSlippageZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcSlippageConnectionCondition::declaration() const { return *IfcSlippageConnectionCondition_type; }
const IfcParse::entity& IfcSlippageConnectionCondition::Class() { return *IfcSlippageConnectionCondition_type; }
IfcSlippageConnectionCondition::IfcSlippageConnectionCondition(IfcEntityInstanceData* e) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSlippageConnectionCondition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSlippageConnectionCondition::IfcSlippageConnectionCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_SlippageX, boost::optional< double > v3_SlippageY, boost::optional< double > v4_SlippageZ) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSlippageConnectionCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_SlippageX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_SlippageX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_SlippageY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_SlippageY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_SlippageZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_SlippageZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcSolarDevice
bool IfcSolarDevice::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum IfcSolarDevice::PredefinedType() const { return IfcSolarDeviceTypeEnum::FromString(*data_->getArgument(8)); }
void IfcSolarDevice::setPredefinedType(IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSolarDeviceTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSolarDevice::declaration() const { return *IfcSolarDevice_type; }
const IfcParse::entity& IfcSolarDevice::Class() { return *IfcSolarDevice_type; }
IfcSolarDevice::IfcSolarDevice(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSolarDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSolarDevice::IfcSolarDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSolarDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSolarDeviceTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSolarDeviceType
IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum IfcSolarDeviceType::PredefinedType() const { return IfcSolarDeviceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSolarDeviceType::setPredefinedType(IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSolarDeviceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcSolarDeviceType::declaration() const { return *IfcSolarDeviceType_type; }
const IfcParse::entity& IfcSolarDeviceType::Class() { return *IfcSolarDeviceType_type; }
IfcSolarDeviceType::IfcSolarDeviceType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSolarDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSolarDeviceType::IfcSolarDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSolarDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSolarDeviceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcSolidModel


const IfcParse::entity& IfcSolidModel::declaration() const { return *IfcSolidModel_type; }
const IfcParse::entity& IfcSolidModel::Class() { return *IfcSolidModel_type; }
IfcSolidModel::IfcSolidModel(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSolidModel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSolidModel::IfcSolidModel() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSolidModel_type);  }

// Function implementations for IfcSpace
bool IfcSpace::hasPredefinedType() const { return !data_->getArgument(9)->isNull(); }
IfcSpaceTypeEnum::IfcSpaceTypeEnum IfcSpace::PredefinedType() const { return IfcSpaceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSpace::setPredefinedType(IfcSpaceTypeEnum::IfcSpaceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSpaceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcSpace::hasElevationWithFlooring() const { return !data_->getArgument(10)->isNull(); }
double IfcSpace::ElevationWithFlooring() const { return *data_->getArgument(10); }
void IfcSpace::setElevationWithFlooring(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }

IfcRelCoversSpaces::list::ptr IfcSpace::HasCoverings() const { return data_->getInverse(IfcRelCoversSpaces_type, 4)->as<IfcRelCoversSpaces>(); }
IfcRelSpaceBoundary::list::ptr IfcSpace::BoundedBy() const { return data_->getInverse(IfcRelSpaceBoundary_type, 4)->as<IfcRelSpaceBoundary>(); }

const IfcParse::entity& IfcSpace::declaration() const { return *IfcSpace_type; }
const IfcParse::entity& IfcSpace::Class() { return *IfcSpace_type; }
IfcSpace::IfcSpace(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpace_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpace::IfcSpace(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< IfcSpaceTypeEnum::IfcSpaceTypeEnum > v10_PredefinedType, boost::optional< double > v11_ElevationWithFlooring) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpace_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_CompositionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v10_PredefinedType,IfcSpaceTypeEnum::ToString(*v10_PredefinedType))));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_ElevationWithFlooring) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ElevationWithFlooring));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcSpaceHeater
bool IfcSpaceHeater::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum IfcSpaceHeater::PredefinedType() const { return IfcSpaceHeaterTypeEnum::FromString(*data_->getArgument(8)); }
void IfcSpaceHeater::setPredefinedType(IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSpaceHeaterTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSpaceHeater::declaration() const { return *IfcSpaceHeater_type; }
const IfcParse::entity& IfcSpaceHeater::Class() { return *IfcSpaceHeater_type; }
IfcSpaceHeater::IfcSpaceHeater(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpaceHeater_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpaceHeater::IfcSpaceHeater(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpaceHeater_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSpaceHeaterTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSpaceHeaterType
IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum IfcSpaceHeaterType::PredefinedType() const { return IfcSpaceHeaterTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSpaceHeaterType::setPredefinedType(IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSpaceHeaterTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcSpaceHeaterType::declaration() const { return *IfcSpaceHeaterType_type; }
const IfcParse::entity& IfcSpaceHeaterType::Class() { return *IfcSpaceHeaterType_type; }
IfcSpaceHeaterType::IfcSpaceHeaterType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpaceHeaterType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpaceHeaterType::IfcSpaceHeaterType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpaceHeaterType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSpaceHeaterTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcSpaceType
IfcSpaceTypeEnum::IfcSpaceTypeEnum IfcSpaceType::PredefinedType() const { return IfcSpaceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSpaceType::setPredefinedType(IfcSpaceTypeEnum::IfcSpaceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSpaceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcSpaceType::hasLongName() const { return !data_->getArgument(10)->isNull(); }
std::string IfcSpaceType::LongName() const { return *data_->getArgument(10); }
void IfcSpaceType::setLongName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcSpaceType::declaration() const { return *IfcSpaceType_type; }
const IfcParse::entity& IfcSpaceType::Class() { return *IfcSpaceType_type; }
IfcSpaceType::IfcSpaceType(IfcEntityInstanceData* e) : IfcSpatialStructureElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpaceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpaceType::IfcSpaceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpaceTypeEnum::IfcSpaceTypeEnum v10_PredefinedType, boost::optional< std::string > v11_LongName) : IfcSpatialStructureElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpaceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSpaceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} if (v11_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_LongName));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcSpatialElement
bool IfcSpatialElement::hasLongName() const { return !data_->getArgument(7)->isNull(); }
std::string IfcSpatialElement::LongName() const { return *data_->getArgument(7); }
void IfcSpatialElement::setLongName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }

IfcRelContainedInSpatialStructure::list::ptr IfcSpatialElement::ContainsElements() const { return data_->getInverse(IfcRelContainedInSpatialStructure_type, 5)->as<IfcRelContainedInSpatialStructure>(); }
IfcRelServicesBuildings::list::ptr IfcSpatialElement::ServicedBySystems() const { return data_->getInverse(IfcRelServicesBuildings_type, 5)->as<IfcRelServicesBuildings>(); }
IfcRelReferencedInSpatialStructure::list::ptr IfcSpatialElement::ReferencesElements() const { return data_->getInverse(IfcRelReferencedInSpatialStructure_type, 5)->as<IfcRelReferencedInSpatialStructure>(); }

const IfcParse::entity& IfcSpatialElement::declaration() const { return *IfcSpatialElement_type; }
const IfcParse::entity& IfcSpatialElement::Class() { return *IfcSpatialElement_type; }
IfcSpatialElement::IfcSpatialElement(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpatialElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpatialElement::IfcSpatialElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpatialElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcSpatialElementType
bool IfcSpatialElementType::hasElementType() const { return !data_->getArgument(8)->isNull(); }
std::string IfcSpatialElementType::ElementType() const { return *data_->getArgument(8); }
void IfcSpatialElementType::setElementType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSpatialElementType::declaration() const { return *IfcSpatialElementType_type; }
const IfcParse::entity& IfcSpatialElementType::Class() { return *IfcSpatialElementType_type; }
IfcSpatialElementType::IfcSpatialElementType(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpatialElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpatialElementType::IfcSpatialElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcTypeProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpatialElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSpatialStructureElement
bool IfcSpatialStructureElement::hasCompositionType() const { return !data_->getArgument(8)->isNull(); }
IfcElementCompositionEnum::IfcElementCompositionEnum IfcSpatialStructureElement::CompositionType() const { return IfcElementCompositionEnum::FromString(*data_->getArgument(8)); }
void IfcSpatialStructureElement::setCompositionType(IfcElementCompositionEnum::IfcElementCompositionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElementCompositionEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSpatialStructureElement::declaration() const { return *IfcSpatialStructureElement_type; }
const IfcParse::entity& IfcSpatialStructureElement::Class() { return *IfcSpatialStructureElement_type; }
IfcSpatialStructureElement::IfcSpatialStructureElement(IfcEntityInstanceData* e) : IfcSpatialElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpatialStructureElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpatialStructureElement::IfcSpatialStructureElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType) : IfcSpatialElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpatialStructureElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_CompositionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSpatialStructureElementType


const IfcParse::entity& IfcSpatialStructureElementType::declaration() const { return *IfcSpatialStructureElementType_type; }
const IfcParse::entity& IfcSpatialStructureElementType::Class() { return *IfcSpatialStructureElementType_type; }
IfcSpatialStructureElementType::IfcSpatialStructureElementType(IfcEntityInstanceData* e) : IfcSpatialElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpatialStructureElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpatialStructureElementType::IfcSpatialStructureElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcSpatialElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpatialStructureElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSpatialZone
bool IfcSpatialZone::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum IfcSpatialZone::PredefinedType() const { return IfcSpatialZoneTypeEnum::FromString(*data_->getArgument(8)); }
void IfcSpatialZone::setPredefinedType(IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSpatialZoneTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSpatialZone::declaration() const { return *IfcSpatialZone_type; }
const IfcParse::entity& IfcSpatialZone::Class() { return *IfcSpatialZone_type; }
IfcSpatialZone::IfcSpatialZone(IfcEntityInstanceData* e) : IfcSpatialElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpatialZone_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpatialZone::IfcSpatialZone(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum > v9_PredefinedType) : IfcSpatialElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpatialZone_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSpatialZoneTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSpatialZoneType
IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum IfcSpatialZoneType::PredefinedType() const { return IfcSpatialZoneTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSpatialZoneType::setPredefinedType(IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSpatialZoneTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcSpatialZoneType::hasLongName() const { return !data_->getArgument(10)->isNull(); }
std::string IfcSpatialZoneType::LongName() const { return *data_->getArgument(10); }
void IfcSpatialZoneType::setLongName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcSpatialZoneType::declaration() const { return *IfcSpatialZoneType_type; }
const IfcParse::entity& IfcSpatialZoneType::Class() { return *IfcSpatialZoneType_type; }
IfcSpatialZoneType::IfcSpatialZoneType(IfcEntityInstanceData* e) : IfcSpatialElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSpatialZoneType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSpatialZoneType::IfcSpatialZoneType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum v10_PredefinedType, boost::optional< std::string > v11_LongName) : IfcSpatialElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSpatialZoneType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSpatialZoneTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} if (v11_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_LongName));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcSphere
double IfcSphere::Radius() const { return *data_->getArgument(1); }
void IfcSphere::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcSphere::declaration() const { return *IfcSphere_type; }
const IfcParse::entity& IfcSphere::Class() { return *IfcSphere_type; }
IfcSphere::IfcSphere(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSphere_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSphere::IfcSphere(IfcAxis2Placement3D* v1_Position, double v2_Radius) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSphere_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));data_->setArgument(1,attr);} }

// Function implementations for IfcStackTerminal
bool IfcStackTerminal::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum IfcStackTerminal::PredefinedType() const { return IfcStackTerminalTypeEnum::FromString(*data_->getArgument(8)); }
void IfcStackTerminal::setPredefinedType(IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStackTerminalTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcStackTerminal::declaration() const { return *IfcStackTerminal_type; }
const IfcParse::entity& IfcStackTerminal::Class() { return *IfcStackTerminal_type; }
IfcStackTerminal::IfcStackTerminal(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStackTerminal_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStackTerminal::IfcStackTerminal(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStackTerminal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcStackTerminalTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcStackTerminalType
IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum IfcStackTerminalType::PredefinedType() const { return IfcStackTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void IfcStackTerminalType::setPredefinedType(IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStackTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcStackTerminalType::declaration() const { return *IfcStackTerminalType_type; }
const IfcParse::entity& IfcStackTerminalType::Class() { return *IfcStackTerminalType_type; }
IfcStackTerminalType::IfcStackTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStackTerminalType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStackTerminalType::IfcStackTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStackTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcStackTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcStair
bool IfcStair::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcStairTypeEnum::IfcStairTypeEnum IfcStair::PredefinedType() const { return IfcStairTypeEnum::FromString(*data_->getArgument(8)); }
void IfcStair::setPredefinedType(IfcStairTypeEnum::IfcStairTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStairTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcStair::declaration() const { return *IfcStair_type; }
const IfcParse::entity& IfcStair::Class() { return *IfcStair_type; }
IfcStair::IfcStair(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStair_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStair::IfcStair(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcStairTypeEnum::IfcStairTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStair_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcStairTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcStairFlight
bool IfcStairFlight::hasNumberOfRisers() const { return !data_->getArgument(8)->isNull(); }
int IfcStairFlight::NumberOfRisers() const { return *data_->getArgument(8); }
void IfcStairFlight::setNumberOfRisers(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcStairFlight::hasNumberOfTreads() const { return !data_->getArgument(9)->isNull(); }
int IfcStairFlight::NumberOfTreads() const { return *data_->getArgument(9); }
void IfcStairFlight::setNumberOfTreads(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcStairFlight::hasRiserHeight() const { return !data_->getArgument(10)->isNull(); }
double IfcStairFlight::RiserHeight() const { return *data_->getArgument(10); }
void IfcStairFlight::setRiserHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcStairFlight::hasTreadLength() const { return !data_->getArgument(11)->isNull(); }
double IfcStairFlight::TreadLength() const { return *data_->getArgument(11); }
void IfcStairFlight::setTreadLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcStairFlight::hasPredefinedType() const { return !data_->getArgument(12)->isNull(); }
IfcStairFlightTypeEnum::IfcStairFlightTypeEnum IfcStairFlight::PredefinedType() const { return IfcStairFlightTypeEnum::FromString(*data_->getArgument(12)); }
void IfcStairFlight::setPredefinedType(IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStairFlightTypeEnum::ToString(v)));data_->setArgument(12,attr);} }


const IfcParse::entity& IfcStairFlight::declaration() const { return *IfcStairFlight_type; }
const IfcParse::entity& IfcStairFlight::Class() { return *IfcStairFlight_type; }
IfcStairFlight::IfcStairFlight(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStairFlight_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStairFlight::IfcStairFlight(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< int > v9_NumberOfRisers, boost::optional< int > v10_NumberOfTreads, boost::optional< double > v11_RiserHeight, boost::optional< double > v12_TreadLength, boost::optional< IfcStairFlightTypeEnum::IfcStairFlightTypeEnum > v13_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStairFlight_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_NumberOfRisers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_NumberOfRisers));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_NumberOfTreads) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_NumberOfTreads));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_RiserHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_RiserHeight));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_TreadLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_TreadLength));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v13_PredefinedType,IfcStairFlightTypeEnum::ToString(*v13_PredefinedType))));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcStairFlightType
IfcStairFlightTypeEnum::IfcStairFlightTypeEnum IfcStairFlightType::PredefinedType() const { return IfcStairFlightTypeEnum::FromString(*data_->getArgument(9)); }
void IfcStairFlightType::setPredefinedType(IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStairFlightTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcStairFlightType::declaration() const { return *IfcStairFlightType_type; }
const IfcParse::entity& IfcStairFlightType::Class() { return *IfcStairFlightType_type; }
IfcStairFlightType::IfcStairFlightType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStairFlightType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStairFlightType::IfcStairFlightType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStairFlightType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcStairFlightTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcStairType
IfcStairTypeEnum::IfcStairTypeEnum IfcStairType::PredefinedType() const { return IfcStairTypeEnum::FromString(*data_->getArgument(9)); }
void IfcStairType::setPredefinedType(IfcStairTypeEnum::IfcStairTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStairTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcStairType::declaration() const { return *IfcStairType_type; }
const IfcParse::entity& IfcStairType::Class() { return *IfcStairType_type; }
IfcStairType::IfcStairType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStairType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStairType::IfcStairType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStairTypeEnum::IfcStairTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStairType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcStairTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcStructuralAction
bool IfcStructuralAction::hasDestabilizingLoad() const { return !data_->getArgument(9)->isNull(); }
bool IfcStructuralAction::DestabilizingLoad() const { return *data_->getArgument(9); }
void IfcStructuralAction::setDestabilizingLoad(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcStructuralAction::declaration() const { return *IfcStructuralAction_type; }
const IfcParse::entity& IfcStructuralAction::Class() { return *IfcStructuralAction_type; }
IfcStructuralAction::IfcStructuralAction(IfcEntityInstanceData* e) : IfcStructuralActivity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralAction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralAction::IfcStructuralAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad) : IfcStructuralActivity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} if (v10_DestabilizingLoad) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_DestabilizingLoad));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcStructuralActivity
IfcStructuralLoad* IfcStructuralActivity::AppliedLoad() const { return (IfcStructuralLoad*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcStructuralActivity::setAppliedLoad(IfcStructuralLoad* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum IfcStructuralActivity::GlobalOrLocal() const { return IfcGlobalOrLocalEnum::FromString(*data_->getArgument(8)); }
void IfcStructuralActivity::setGlobalOrLocal(IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcGlobalOrLocalEnum::ToString(v)));data_->setArgument(8,attr);} }

IfcRelConnectsStructuralActivity::list::ptr IfcStructuralActivity::AssignedToStructuralItem() const { return data_->getInverse(IfcRelConnectsStructuralActivity_type, 5)->as<IfcRelConnectsStructuralActivity>(); }

const IfcParse::entity& IfcStructuralActivity::declaration() const { return *IfcStructuralActivity_type; }
const IfcParse::entity& IfcStructuralActivity::Class() { return *IfcStructuralActivity_type; }
IfcStructuralActivity::IfcStructuralActivity(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralActivity_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralActivity::IfcStructuralActivity(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralActivity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralAnalysisModel
IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum IfcStructuralAnalysisModel::PredefinedType() const { return IfcAnalysisModelTypeEnum::FromString(*data_->getArgument(5)); }
void IfcStructuralAnalysisModel::setPredefinedType(IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAnalysisModelTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
bool IfcStructuralAnalysisModel::hasOrientationOf2DPlane() const { return !data_->getArgument(6)->isNull(); }
IfcAxis2Placement3D* IfcStructuralAnalysisModel::OrientationOf2DPlane() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcStructuralAnalysisModel::setOrientationOf2DPlane(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcStructuralAnalysisModel::hasLoadedBy() const { return !data_->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr IfcStructuralAnalysisModel::LoadedBy() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcStructuralLoadGroup>(); }
void IfcStructuralAnalysisModel::setLoadedBy(IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }
bool IfcStructuralAnalysisModel::hasHasResults() const { return !data_->getArgument(8)->isNull(); }
IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr IfcStructuralAnalysisModel::HasResults() const { IfcEntityList::ptr es = *data_->getArgument(8); return es->as<IfcStructuralResultGroup>(); }
void IfcStructuralAnalysisModel::setHasResults(IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(8,attr);} }
bool IfcStructuralAnalysisModel::hasSharedPlacement() const { return !data_->getArgument(9)->isNull(); }
IfcObjectPlacement* IfcStructuralAnalysisModel::SharedPlacement() const { return (IfcObjectPlacement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(9))); }
void IfcStructuralAnalysisModel::setSharedPlacement(IfcObjectPlacement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcStructuralAnalysisModel::declaration() const { return *IfcStructuralAnalysisModel_type; }
const IfcParse::entity& IfcStructuralAnalysisModel::Class() { return *IfcStructuralAnalysisModel_type; }
IfcStructuralAnalysisModel::IfcStructuralAnalysisModel(IfcEntityInstanceData* e) : IfcSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralAnalysisModel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralAnalysisModel::IfcStructuralAnalysisModel(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v6_PredefinedType, IfcAxis2Placement3D* v7_OrientationOf2DPlane, boost::optional< IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr > v8_LoadedBy, boost::optional< IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr > v9_HasResults, IfcObjectPlacement* v10_SharedPlacement) : IfcSystem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralAnalysisModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PredefinedType,IfcAnalysisModelTypeEnum::ToString(v6_PredefinedType))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_OrientationOf2DPlane));data_->setArgument(6,attr);} if (v8_LoadedBy) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LoadedBy)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_HasResults) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_HasResults)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_SharedPlacement));data_->setArgument(9,attr);} }

// Function implementations for IfcStructuralConnection
bool IfcStructuralConnection::hasAppliedCondition() const { return !data_->getArgument(7)->isNull(); }
IfcBoundaryCondition* IfcStructuralConnection::AppliedCondition() const { return (IfcBoundaryCondition*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcStructuralConnection::setAppliedCondition(IfcBoundaryCondition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }

IfcRelConnectsStructuralMember::list::ptr IfcStructuralConnection::ConnectsStructuralMembers() const { return data_->getInverse(IfcRelConnectsStructuralMember_type, 5)->as<IfcRelConnectsStructuralMember>(); }

const IfcParse::entity& IfcStructuralConnection::declaration() const { return *IfcStructuralConnection_type; }
const IfcParse::entity& IfcStructuralConnection::Class() { return *IfcStructuralConnection_type; }
IfcStructuralConnection::IfcStructuralConnection(IfcEntityInstanceData* e) : IfcStructuralItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralConnection_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralConnection::IfcStructuralConnection(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralConnection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralConnectionCondition
bool IfcStructuralConnectionCondition::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcStructuralConnectionCondition::Name() const { return *data_->getArgument(0); }
void IfcStructuralConnectionCondition::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcStructuralConnectionCondition::declaration() const { return *IfcStructuralConnectionCondition_type; }
const IfcParse::entity& IfcStructuralConnectionCondition::Class() { return *IfcStructuralConnectionCondition_type; }
IfcStructuralConnectionCondition::IfcStructuralConnectionCondition(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcStructuralConnectionCondition_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralConnectionCondition::IfcStructuralConnectionCondition(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcStructuralConnectionCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcStructuralCurveAction
bool IfcStructuralCurveAction::hasProjectedOrTrue() const { return !data_->getArgument(10)->isNull(); }
IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum IfcStructuralCurveAction::ProjectedOrTrue() const { return IfcProjectedOrTrueLengthEnum::FromString(*data_->getArgument(10)); }
void IfcStructuralCurveAction::setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProjectedOrTrueLengthEnum::ToString(v)));data_->setArgument(10,attr);} }
IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum IfcStructuralCurveAction::PredefinedType() const { return IfcStructuralCurveActivityTypeEnum::FromString(*data_->getArgument(11)); }
void IfcStructuralCurveAction::setPredefinedType(IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStructuralCurveActivityTypeEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcStructuralCurveAction::declaration() const { return *IfcStructuralCurveAction_type; }
const IfcParse::entity& IfcStructuralCurveAction::Class() { return *IfcStructuralCurveAction_type; }
IfcStructuralCurveAction::IfcStructuralCurveAction(IfcEntityInstanceData* e) : IfcStructuralAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralCurveAction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralCurveAction::IfcStructuralCurveAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v12_PredefinedType) : IfcStructuralAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralCurveAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} if (v10_DestabilizingLoad) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_DestabilizingLoad));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_ProjectedOrTrue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(*v11_ProjectedOrTrue))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcStructuralCurveActivityTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcStructuralCurveConnection
IfcDirection* IfcStructuralCurveConnection::Axis() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcStructuralCurveConnection::setAxis(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcStructuralCurveConnection::declaration() const { return *IfcStructuralCurveConnection_type; }
const IfcParse::entity& IfcStructuralCurveConnection::Class() { return *IfcStructuralCurveConnection_type; }
IfcStructuralCurveConnection::IfcStructuralCurveConnection(IfcEntityInstanceData* e) : IfcStructuralConnection((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralCurveConnection_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralCurveConnection::IfcStructuralCurveConnection(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition, IfcDirection* v9_Axis) : IfcStructuralConnection((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralCurveConnection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_Axis));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralCurveMember
IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum IfcStructuralCurveMember::PredefinedType() const { return IfcStructuralCurveMemberTypeEnum::FromString(*data_->getArgument(7)); }
void IfcStructuralCurveMember::setPredefinedType(IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStructuralCurveMemberTypeEnum::ToString(v)));data_->setArgument(7,attr);} }
IfcDirection* IfcStructuralCurveMember::Axis() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcStructuralCurveMember::setAxis(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcStructuralCurveMember::declaration() const { return *IfcStructuralCurveMember_type; }
const IfcParse::entity& IfcStructuralCurveMember::Class() { return *IfcStructuralCurveMember_type; }
IfcStructuralCurveMember::IfcStructuralCurveMember(IfcEntityInstanceData* e) : IfcStructuralMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralCurveMember_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralCurveMember::IfcStructuralCurveMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum v8_PredefinedType, IfcDirection* v9_Axis) : IfcStructuralMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralCurveMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,IfcStructuralCurveMemberTypeEnum::ToString(v8_PredefinedType))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_Axis));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralCurveMemberVarying


const IfcParse::entity& IfcStructuralCurveMemberVarying::declaration() const { return *IfcStructuralCurveMemberVarying_type; }
const IfcParse::entity& IfcStructuralCurveMemberVarying::Class() { return *IfcStructuralCurveMemberVarying_type; }
IfcStructuralCurveMemberVarying::IfcStructuralCurveMemberVarying(IfcEntityInstanceData* e) : IfcStructuralCurveMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralCurveMemberVarying_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralCurveMemberVarying::IfcStructuralCurveMemberVarying(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum v8_PredefinedType, IfcDirection* v9_Axis) : IfcStructuralCurveMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralCurveMemberVarying_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,IfcStructuralCurveMemberTypeEnum::ToString(v8_PredefinedType))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_Axis));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralCurveReaction
IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum IfcStructuralCurveReaction::PredefinedType() const { return IfcStructuralCurveActivityTypeEnum::FromString(*data_->getArgument(9)); }
void IfcStructuralCurveReaction::setPredefinedType(IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStructuralCurveActivityTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcStructuralCurveReaction::declaration() const { return *IfcStructuralCurveReaction_type; }
const IfcParse::entity& IfcStructuralCurveReaction::Class() { return *IfcStructuralCurveReaction_type; }
IfcStructuralCurveReaction::IfcStructuralCurveReaction(IfcEntityInstanceData* e) : IfcStructuralReaction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralCurveReaction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralCurveReaction::IfcStructuralCurveReaction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v10_PredefinedType) : IfcStructuralReaction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralCurveReaction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcStructuralCurveActivityTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcStructuralItem

IfcRelConnectsStructuralActivity::list::ptr IfcStructuralItem::AssignedStructuralActivity() const { return data_->getInverse(IfcRelConnectsStructuralActivity_type, 4)->as<IfcRelConnectsStructuralActivity>(); }

const IfcParse::entity& IfcStructuralItem::declaration() const { return *IfcStructuralItem_type; }
const IfcParse::entity& IfcStructuralItem::Class() { return *IfcStructuralItem_type; }
IfcStructuralItem::IfcStructuralItem(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralItem::IfcStructuralItem(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcStructuralLinearAction


const IfcParse::entity& IfcStructuralLinearAction::declaration() const { return *IfcStructuralLinearAction_type; }
const IfcParse::entity& IfcStructuralLinearAction::Class() { return *IfcStructuralLinearAction_type; }
IfcStructuralLinearAction::IfcStructuralLinearAction(IfcEntityInstanceData* e) : IfcStructuralCurveAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLinearAction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLinearAction::IfcStructuralLinearAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v12_PredefinedType) : IfcStructuralCurveAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLinearAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} if (v10_DestabilizingLoad) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_DestabilizingLoad));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_ProjectedOrTrue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(*v11_ProjectedOrTrue))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcStructuralCurveActivityTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcStructuralLoad
bool IfcStructuralLoad::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcStructuralLoad::Name() const { return *data_->getArgument(0); }
void IfcStructuralLoad::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcStructuralLoad::declaration() const { return *IfcStructuralLoad_type; }
const IfcParse::entity& IfcStructuralLoad::Class() { return *IfcStructuralLoad_type; }
IfcStructuralLoad::IfcStructuralLoad(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcStructuralLoad_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoad::IfcStructuralLoad(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcStructuralLoad_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcStructuralLoadCase
bool IfcStructuralLoadCase::hasSelfWeightCoefficients() const { return !data_->getArgument(10)->isNull(); }
std::vector< double > /*[3:3]*/ IfcStructuralLoadCase::SelfWeightCoefficients() const { return *data_->getArgument(10); }
void IfcStructuralLoadCase::setSelfWeightCoefficients(std::vector< double > /*[3:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcStructuralLoadCase::declaration() const { return *IfcStructuralLoadCase_type; }
const IfcParse::entity& IfcStructuralLoadCase::Class() { return *IfcStructuralLoadCase_type; }
IfcStructuralLoadCase::IfcStructuralLoadCase(IfcEntityInstanceData* e) : IfcStructuralLoadGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadCase::IfcStructuralLoadCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v6_PredefinedType, IfcActionTypeEnum::IfcActionTypeEnum v7_ActionType, IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v8_ActionSource, boost::optional< double > v9_Coefficient, boost::optional< std::string > v10_Purpose, boost::optional< std::vector< double > /*[3:3]*/ > v11_SelfWeightCoefficients) : IfcStructuralLoadGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PredefinedType,IfcLoadGroupTypeEnum::ToString(v6_PredefinedType))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_ActionType,IfcActionTypeEnum::ToString(v7_ActionType))));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_ActionSource,IfcActionSourceTypeEnum::ToString(v8_ActionSource))));data_->setArgument(7,attr);} if (v9_Coefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Coefficient));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Purpose));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_SelfWeightCoefficients) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_SelfWeightCoefficients));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcStructuralLoadConfiguration
IfcTemplatedEntityList< IfcStructuralLoadOrResult >::ptr IfcStructuralLoadConfiguration::Values() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcStructuralLoadOrResult>(); }
void IfcStructuralLoadConfiguration::setValues(IfcTemplatedEntityList< IfcStructuralLoadOrResult >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }
bool IfcStructuralLoadConfiguration::hasLocations() const { return !data_->getArgument(2)->isNull(); }
std::vector< std::vector< double > > IfcStructuralLoadConfiguration::Locations() const { return *data_->getArgument(2); }
void IfcStructuralLoadConfiguration::setLocations(std::vector< std::vector< double > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcStructuralLoadConfiguration::declaration() const { return *IfcStructuralLoadConfiguration_type; }
const IfcParse::entity& IfcStructuralLoadConfiguration::Class() { return *IfcStructuralLoadConfiguration_type; }
IfcStructuralLoadConfiguration::IfcStructuralLoadConfiguration(IfcEntityInstanceData* e) : IfcStructuralLoad((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadConfiguration_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadConfiguration::IfcStructuralLoadConfiguration(boost::optional< std::string > v1_Name, IfcTemplatedEntityList< IfcStructuralLoadOrResult >::ptr v2_Values, boost::optional< std::vector< std::vector< double > > > v3_Locations) : IfcStructuralLoad((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadConfiguration_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Values)->generalize());data_->setArgument(1,attr);} if (v3_Locations) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Locations));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcStructuralLoadGroup
IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum IfcStructuralLoadGroup::PredefinedType() const { return IfcLoadGroupTypeEnum::FromString(*data_->getArgument(5)); }
void IfcStructuralLoadGroup::setPredefinedType(IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLoadGroupTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
IfcActionTypeEnum::IfcActionTypeEnum IfcStructuralLoadGroup::ActionType() const { return IfcActionTypeEnum::FromString(*data_->getArgument(6)); }
void IfcStructuralLoadGroup::setActionType(IfcActionTypeEnum::IfcActionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcActionTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
IfcActionSourceTypeEnum::IfcActionSourceTypeEnum IfcStructuralLoadGroup::ActionSource() const { return IfcActionSourceTypeEnum::FromString(*data_->getArgument(7)); }
void IfcStructuralLoadGroup::setActionSource(IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcActionSourceTypeEnum::ToString(v)));data_->setArgument(7,attr);} }
bool IfcStructuralLoadGroup::hasCoefficient() const { return !data_->getArgument(8)->isNull(); }
double IfcStructuralLoadGroup::Coefficient() const { return *data_->getArgument(8); }
void IfcStructuralLoadGroup::setCoefficient(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcStructuralLoadGroup::hasPurpose() const { return !data_->getArgument(9)->isNull(); }
std::string IfcStructuralLoadGroup::Purpose() const { return *data_->getArgument(9); }
void IfcStructuralLoadGroup::setPurpose(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }

IfcStructuralResultGroup::list::ptr IfcStructuralLoadGroup::SourceOfResultGroup() const { return data_->getInverse(IfcStructuralResultGroup_type, 6)->as<IfcStructuralResultGroup>(); }
IfcStructuralAnalysisModel::list::ptr IfcStructuralLoadGroup::LoadGroupFor() const { return data_->getInverse(IfcStructuralAnalysisModel_type, 7)->as<IfcStructuralAnalysisModel>(); }

const IfcParse::entity& IfcStructuralLoadGroup::declaration() const { return *IfcStructuralLoadGroup_type; }
const IfcParse::entity& IfcStructuralLoadGroup::Class() { return *IfcStructuralLoadGroup_type; }
IfcStructuralLoadGroup::IfcStructuralLoadGroup(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadGroup_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadGroup::IfcStructuralLoadGroup(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v6_PredefinedType, IfcActionTypeEnum::IfcActionTypeEnum v7_ActionType, IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v8_ActionSource, boost::optional< double > v9_Coefficient, boost::optional< std::string > v10_Purpose) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadGroup_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PredefinedType,IfcLoadGroupTypeEnum::ToString(v6_PredefinedType))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_ActionType,IfcActionTypeEnum::ToString(v7_ActionType))));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_ActionSource,IfcActionSourceTypeEnum::ToString(v8_ActionSource))));data_->setArgument(7,attr);} if (v9_Coefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Coefficient));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Purpose));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcStructuralLoadLinearForce
bool IfcStructuralLoadLinearForce::hasLinearForceX() const { return !data_->getArgument(1)->isNull(); }
double IfcStructuralLoadLinearForce::LinearForceX() const { return *data_->getArgument(1); }
void IfcStructuralLoadLinearForce::setLinearForceX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearForceY() const { return !data_->getArgument(2)->isNull(); }
double IfcStructuralLoadLinearForce::LinearForceY() const { return *data_->getArgument(2); }
void IfcStructuralLoadLinearForce::setLinearForceY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearForceZ() const { return !data_->getArgument(3)->isNull(); }
double IfcStructuralLoadLinearForce::LinearForceZ() const { return *data_->getArgument(3); }
void IfcStructuralLoadLinearForce::setLinearForceZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearMomentX() const { return !data_->getArgument(4)->isNull(); }
double IfcStructuralLoadLinearForce::LinearMomentX() const { return *data_->getArgument(4); }
void IfcStructuralLoadLinearForce::setLinearMomentX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearMomentY() const { return !data_->getArgument(5)->isNull(); }
double IfcStructuralLoadLinearForce::LinearMomentY() const { return *data_->getArgument(5); }
void IfcStructuralLoadLinearForce::setLinearMomentY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearMomentZ() const { return !data_->getArgument(6)->isNull(); }
double IfcStructuralLoadLinearForce::LinearMomentZ() const { return *data_->getArgument(6); }
void IfcStructuralLoadLinearForce::setLinearMomentZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcStructuralLoadLinearForce::declaration() const { return *IfcStructuralLoadLinearForce_type; }
const IfcParse::entity& IfcStructuralLoadLinearForce::Class() { return *IfcStructuralLoadLinearForce_type; }
IfcStructuralLoadLinearForce::IfcStructuralLoadLinearForce(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadLinearForce_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadLinearForce::IfcStructuralLoadLinearForce(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearForceX, boost::optional< double > v3_LinearForceY, boost::optional< double > v4_LinearForceZ, boost::optional< double > v5_LinearMomentX, boost::optional< double > v6_LinearMomentY, boost::optional< double > v7_LinearMomentZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadLinearForce_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_LinearForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearForceX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_LinearForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearForceY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_LinearForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearForceZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_LinearMomentX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LinearMomentX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LinearMomentY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LinearMomentY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LinearMomentZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LinearMomentZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcStructuralLoadOrResult


const IfcParse::entity& IfcStructuralLoadOrResult::declaration() const { return *IfcStructuralLoadOrResult_type; }
const IfcParse::entity& IfcStructuralLoadOrResult::Class() { return *IfcStructuralLoadOrResult_type; }
IfcStructuralLoadOrResult::IfcStructuralLoadOrResult(IfcEntityInstanceData* e) : IfcStructuralLoad((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadOrResult_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadOrResult::IfcStructuralLoadOrResult(boost::optional< std::string > v1_Name) : IfcStructuralLoad((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadOrResult_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcStructuralLoadPlanarForce
bool IfcStructuralLoadPlanarForce::hasPlanarForceX() const { return !data_->getArgument(1)->isNull(); }
double IfcStructuralLoadPlanarForce::PlanarForceX() const { return *data_->getArgument(1); }
void IfcStructuralLoadPlanarForce::setPlanarForceX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcStructuralLoadPlanarForce::hasPlanarForceY() const { return !data_->getArgument(2)->isNull(); }
double IfcStructuralLoadPlanarForce::PlanarForceY() const { return *data_->getArgument(2); }
void IfcStructuralLoadPlanarForce::setPlanarForceY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcStructuralLoadPlanarForce::hasPlanarForceZ() const { return !data_->getArgument(3)->isNull(); }
double IfcStructuralLoadPlanarForce::PlanarForceZ() const { return *data_->getArgument(3); }
void IfcStructuralLoadPlanarForce::setPlanarForceZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcStructuralLoadPlanarForce::declaration() const { return *IfcStructuralLoadPlanarForce_type; }
const IfcParse::entity& IfcStructuralLoadPlanarForce::Class() { return *IfcStructuralLoadPlanarForce_type; }
IfcStructuralLoadPlanarForce::IfcStructuralLoadPlanarForce(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadPlanarForce_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadPlanarForce::IfcStructuralLoadPlanarForce(boost::optional< std::string > v1_Name, boost::optional< double > v2_PlanarForceX, boost::optional< double > v3_PlanarForceY, boost::optional< double > v4_PlanarForceZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadPlanarForce_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_PlanarForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_PlanarForceX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_PlanarForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_PlanarForceY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_PlanarForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_PlanarForceZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcStructuralLoadSingleDisplacement
bool IfcStructuralLoadSingleDisplacement::hasDisplacementX() const { return !data_->getArgument(1)->isNull(); }
double IfcStructuralLoadSingleDisplacement::DisplacementX() const { return *data_->getArgument(1); }
void IfcStructuralLoadSingleDisplacement::setDisplacementX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasDisplacementY() const { return !data_->getArgument(2)->isNull(); }
double IfcStructuralLoadSingleDisplacement::DisplacementY() const { return *data_->getArgument(2); }
void IfcStructuralLoadSingleDisplacement::setDisplacementY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasDisplacementZ() const { return !data_->getArgument(3)->isNull(); }
double IfcStructuralLoadSingleDisplacement::DisplacementZ() const { return *data_->getArgument(3); }
void IfcStructuralLoadSingleDisplacement::setDisplacementZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasRotationalDisplacementRX() const { return !data_->getArgument(4)->isNull(); }
double IfcStructuralLoadSingleDisplacement::RotationalDisplacementRX() const { return *data_->getArgument(4); }
void IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasRotationalDisplacementRY() const { return !data_->getArgument(5)->isNull(); }
double IfcStructuralLoadSingleDisplacement::RotationalDisplacementRY() const { return *data_->getArgument(5); }
void IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasRotationalDisplacementRZ() const { return !data_->getArgument(6)->isNull(); }
double IfcStructuralLoadSingleDisplacement::RotationalDisplacementRZ() const { return *data_->getArgument(6); }
void IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcStructuralLoadSingleDisplacement::declaration() const { return *IfcStructuralLoadSingleDisplacement_type; }
const IfcParse::entity& IfcStructuralLoadSingleDisplacement::Class() { return *IfcStructuralLoadSingleDisplacement_type; }
IfcStructuralLoadSingleDisplacement::IfcStructuralLoadSingleDisplacement(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadSingleDisplacement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadSingleDisplacement::IfcStructuralLoadSingleDisplacement(boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadSingleDisplacement_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DisplacementX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DisplacementX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_DisplacementY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DisplacementY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DisplacementZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DisplacementZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_RotationalDisplacementRX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalDisplacementRX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_RotationalDisplacementRY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalDisplacementRY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RotationalDisplacementRZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalDisplacementRZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcStructuralLoadSingleDisplacementDistortion
bool IfcStructuralLoadSingleDisplacementDistortion::hasDistortion() const { return !data_->getArgument(7)->isNull(); }
double IfcStructuralLoadSingleDisplacementDistortion::Distortion() const { return *data_->getArgument(7); }
void IfcStructuralLoadSingleDisplacementDistortion::setDistortion(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcStructuralLoadSingleDisplacementDistortion::declaration() const { return *IfcStructuralLoadSingleDisplacementDistortion_type; }
const IfcParse::entity& IfcStructuralLoadSingleDisplacementDistortion::Class() { return *IfcStructuralLoadSingleDisplacementDistortion_type; }
IfcStructuralLoadSingleDisplacementDistortion::IfcStructuralLoadSingleDisplacementDistortion(IfcEntityInstanceData* e) : IfcStructuralLoadSingleDisplacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadSingleDisplacementDistortion_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadSingleDisplacementDistortion::IfcStructuralLoadSingleDisplacementDistortion(boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ, boost::optional< double > v8_Distortion) : IfcStructuralLoadSingleDisplacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadSingleDisplacementDistortion_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DisplacementX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DisplacementX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_DisplacementY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DisplacementY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DisplacementZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DisplacementZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_RotationalDisplacementRX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalDisplacementRX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_RotationalDisplacementRY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalDisplacementRY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RotationalDisplacementRZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalDisplacementRZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Distortion) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Distortion));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcStructuralLoadSingleForce
bool IfcStructuralLoadSingleForce::hasForceX() const { return !data_->getArgument(1)->isNull(); }
double IfcStructuralLoadSingleForce::ForceX() const { return *data_->getArgument(1); }
void IfcStructuralLoadSingleForce::setForceX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcStructuralLoadSingleForce::hasForceY() const { return !data_->getArgument(2)->isNull(); }
double IfcStructuralLoadSingleForce::ForceY() const { return *data_->getArgument(2); }
void IfcStructuralLoadSingleForce::setForceY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcStructuralLoadSingleForce::hasForceZ() const { return !data_->getArgument(3)->isNull(); }
double IfcStructuralLoadSingleForce::ForceZ() const { return *data_->getArgument(3); }
void IfcStructuralLoadSingleForce::setForceZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcStructuralLoadSingleForce::hasMomentX() const { return !data_->getArgument(4)->isNull(); }
double IfcStructuralLoadSingleForce::MomentX() const { return *data_->getArgument(4); }
void IfcStructuralLoadSingleForce::setMomentX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcStructuralLoadSingleForce::hasMomentY() const { return !data_->getArgument(5)->isNull(); }
double IfcStructuralLoadSingleForce::MomentY() const { return *data_->getArgument(5); }
void IfcStructuralLoadSingleForce::setMomentY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcStructuralLoadSingleForce::hasMomentZ() const { return !data_->getArgument(6)->isNull(); }
double IfcStructuralLoadSingleForce::MomentZ() const { return *data_->getArgument(6); }
void IfcStructuralLoadSingleForce::setMomentZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcStructuralLoadSingleForce::declaration() const { return *IfcStructuralLoadSingleForce_type; }
const IfcParse::entity& IfcStructuralLoadSingleForce::Class() { return *IfcStructuralLoadSingleForce_type; }
IfcStructuralLoadSingleForce::IfcStructuralLoadSingleForce(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadSingleForce_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadSingleForce::IfcStructuralLoadSingleForce(boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadSingleForce_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ForceX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_ForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ForceY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ForceZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MomentX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MomentX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_MomentY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MomentY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_MomentZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_MomentZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcStructuralLoadSingleForceWarping
bool IfcStructuralLoadSingleForceWarping::hasWarpingMoment() const { return !data_->getArgument(7)->isNull(); }
double IfcStructuralLoadSingleForceWarping::WarpingMoment() const { return *data_->getArgument(7); }
void IfcStructuralLoadSingleForceWarping::setWarpingMoment(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& IfcStructuralLoadSingleForceWarping::declaration() const { return *IfcStructuralLoadSingleForceWarping_type; }
const IfcParse::entity& IfcStructuralLoadSingleForceWarping::Class() { return *IfcStructuralLoadSingleForceWarping_type; }
IfcStructuralLoadSingleForceWarping::IfcStructuralLoadSingleForceWarping(IfcEntityInstanceData* e) : IfcStructuralLoadSingleForce((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadSingleForceWarping_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadSingleForceWarping::IfcStructuralLoadSingleForceWarping(boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ, boost::optional< double > v8_WarpingMoment) : IfcStructuralLoadSingleForce((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadSingleForceWarping_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ForceX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_ForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ForceY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ForceZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MomentX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MomentX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_MomentY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MomentY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_MomentZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_MomentZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_WarpingMoment) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WarpingMoment));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcStructuralLoadStatic


const IfcParse::entity& IfcStructuralLoadStatic::declaration() const { return *IfcStructuralLoadStatic_type; }
const IfcParse::entity& IfcStructuralLoadStatic::Class() { return *IfcStructuralLoadStatic_type; }
IfcStructuralLoadStatic::IfcStructuralLoadStatic(IfcEntityInstanceData* e) : IfcStructuralLoadOrResult((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadStatic_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadStatic::IfcStructuralLoadStatic(boost::optional< std::string > v1_Name) : IfcStructuralLoadOrResult((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadStatic_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcStructuralLoadTemperature
bool IfcStructuralLoadTemperature::hasDeltaTConstant() const { return !data_->getArgument(1)->isNull(); }
double IfcStructuralLoadTemperature::DeltaTConstant() const { return *data_->getArgument(1); }
void IfcStructuralLoadTemperature::setDeltaTConstant(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcStructuralLoadTemperature::hasDeltaTY() const { return !data_->getArgument(2)->isNull(); }
double IfcStructuralLoadTemperature::DeltaTY() const { return *data_->getArgument(2); }
void IfcStructuralLoadTemperature::setDeltaTY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcStructuralLoadTemperature::hasDeltaTZ() const { return !data_->getArgument(3)->isNull(); }
double IfcStructuralLoadTemperature::DeltaTZ() const { return *data_->getArgument(3); }
void IfcStructuralLoadTemperature::setDeltaTZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcStructuralLoadTemperature::declaration() const { return *IfcStructuralLoadTemperature_type; }
const IfcParse::entity& IfcStructuralLoadTemperature::Class() { return *IfcStructuralLoadTemperature_type; }
IfcStructuralLoadTemperature::IfcStructuralLoadTemperature(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralLoadTemperature_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralLoadTemperature::IfcStructuralLoadTemperature(boost::optional< std::string > v1_Name, boost::optional< double > v2_DeltaTConstant, boost::optional< double > v3_DeltaTY, boost::optional< double > v4_DeltaTZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralLoadTemperature_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DeltaTConstant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DeltaTConstant));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_DeltaTY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DeltaTY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DeltaTZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DeltaTZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcStructuralMember

IfcRelConnectsStructuralMember::list::ptr IfcStructuralMember::ConnectedBy() const { return data_->getInverse(IfcRelConnectsStructuralMember_type, 4)->as<IfcRelConnectsStructuralMember>(); }

const IfcParse::entity& IfcStructuralMember::declaration() const { return *IfcStructuralMember_type; }
const IfcParse::entity& IfcStructuralMember::Class() { return *IfcStructuralMember_type; }
IfcStructuralMember::IfcStructuralMember(IfcEntityInstanceData* e) : IfcStructuralItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralMember_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralMember::IfcStructuralMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcStructuralItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcStructuralPlanarAction


const IfcParse::entity& IfcStructuralPlanarAction::declaration() const { return *IfcStructuralPlanarAction_type; }
const IfcParse::entity& IfcStructuralPlanarAction::Class() { return *IfcStructuralPlanarAction_type; }
IfcStructuralPlanarAction::IfcStructuralPlanarAction(IfcEntityInstanceData* e) : IfcStructuralSurfaceAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralPlanarAction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralPlanarAction::IfcStructuralPlanarAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v12_PredefinedType) : IfcStructuralSurfaceAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralPlanarAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} if (v10_DestabilizingLoad) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_DestabilizingLoad));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_ProjectedOrTrue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(*v11_ProjectedOrTrue))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcStructuralSurfaceActivityTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcStructuralPointAction


const IfcParse::entity& IfcStructuralPointAction::declaration() const { return *IfcStructuralPointAction_type; }
const IfcParse::entity& IfcStructuralPointAction::Class() { return *IfcStructuralPointAction_type; }
IfcStructuralPointAction::IfcStructuralPointAction(IfcEntityInstanceData* e) : IfcStructuralAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralPointAction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralPointAction::IfcStructuralPointAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad) : IfcStructuralAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralPointAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} if (v10_DestabilizingLoad) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_DestabilizingLoad));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcStructuralPointConnection
bool IfcStructuralPointConnection::hasConditionCoordinateSystem() const { return !data_->getArgument(8)->isNull(); }
IfcAxis2Placement3D* IfcStructuralPointConnection::ConditionCoordinateSystem() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcStructuralPointConnection::setConditionCoordinateSystem(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcStructuralPointConnection::declaration() const { return *IfcStructuralPointConnection_type; }
const IfcParse::entity& IfcStructuralPointConnection::Class() { return *IfcStructuralPointConnection_type; }
IfcStructuralPointConnection::IfcStructuralPointConnection(IfcEntityInstanceData* e) : IfcStructuralConnection((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralPointConnection_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralPointConnection::IfcStructuralPointConnection(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition, IfcAxis2Placement3D* v9_ConditionCoordinateSystem) : IfcStructuralConnection((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralPointConnection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ConditionCoordinateSystem));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralPointReaction


const IfcParse::entity& IfcStructuralPointReaction::declaration() const { return *IfcStructuralPointReaction_type; }
const IfcParse::entity& IfcStructuralPointReaction::Class() { return *IfcStructuralPointReaction_type; }
IfcStructuralPointReaction::IfcStructuralPointReaction(IfcEntityInstanceData* e) : IfcStructuralReaction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralPointReaction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralPointReaction::IfcStructuralPointReaction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal) : IfcStructuralReaction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralPointReaction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralReaction


const IfcParse::entity& IfcStructuralReaction::declaration() const { return *IfcStructuralReaction_type; }
const IfcParse::entity& IfcStructuralReaction::Class() { return *IfcStructuralReaction_type; }
IfcStructuralReaction::IfcStructuralReaction(IfcEntityInstanceData* e) : IfcStructuralActivity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralReaction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralReaction::IfcStructuralReaction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal) : IfcStructuralActivity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralReaction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralResultGroup
IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum IfcStructuralResultGroup::TheoryType() const { return IfcAnalysisTheoryTypeEnum::FromString(*data_->getArgument(5)); }
void IfcStructuralResultGroup::setTheoryType(IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAnalysisTheoryTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
bool IfcStructuralResultGroup::hasResultForLoadGroup() const { return !data_->getArgument(6)->isNull(); }
IfcStructuralLoadGroup* IfcStructuralResultGroup::ResultForLoadGroup() const { return (IfcStructuralLoadGroup*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcStructuralResultGroup::setResultForLoadGroup(IfcStructuralLoadGroup* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcStructuralResultGroup::IsLinear() const { return *data_->getArgument(7); }
void IfcStructuralResultGroup::setIsLinear(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }

IfcStructuralAnalysisModel::list::ptr IfcStructuralResultGroup::ResultGroupFor() const { return data_->getInverse(IfcStructuralAnalysisModel_type, 8)->as<IfcStructuralAnalysisModel>(); }

const IfcParse::entity& IfcStructuralResultGroup::declaration() const { return *IfcStructuralResultGroup_type; }
const IfcParse::entity& IfcStructuralResultGroup::Class() { return *IfcStructuralResultGroup_type; }
IfcStructuralResultGroup::IfcStructuralResultGroup(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralResultGroup_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralResultGroup::IfcStructuralResultGroup(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v6_TheoryType, IfcStructuralLoadGroup* v7_ResultForLoadGroup, bool v8_IsLinear) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralResultGroup_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_TheoryType,IfcAnalysisTheoryTypeEnum::ToString(v6_TheoryType))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ResultForLoadGroup));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_IsLinear));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralSurfaceAction
bool IfcStructuralSurfaceAction::hasProjectedOrTrue() const { return !data_->getArgument(10)->isNull(); }
IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum IfcStructuralSurfaceAction::ProjectedOrTrue() const { return IfcProjectedOrTrueLengthEnum::FromString(*data_->getArgument(10)); }
void IfcStructuralSurfaceAction::setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProjectedOrTrueLengthEnum::ToString(v)));data_->setArgument(10,attr);} }
IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum IfcStructuralSurfaceAction::PredefinedType() const { return IfcStructuralSurfaceActivityTypeEnum::FromString(*data_->getArgument(11)); }
void IfcStructuralSurfaceAction::setPredefinedType(IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStructuralSurfaceActivityTypeEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcStructuralSurfaceAction::declaration() const { return *IfcStructuralSurfaceAction_type; }
const IfcParse::entity& IfcStructuralSurfaceAction::Class() { return *IfcStructuralSurfaceAction_type; }
IfcStructuralSurfaceAction::IfcStructuralSurfaceAction(IfcEntityInstanceData* e) : IfcStructuralAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralSurfaceAction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralSurfaceAction::IfcStructuralSurfaceAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v12_PredefinedType) : IfcStructuralAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralSurfaceAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} if (v10_DestabilizingLoad) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_DestabilizingLoad));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_ProjectedOrTrue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(*v11_ProjectedOrTrue))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcStructuralSurfaceActivityTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcStructuralSurfaceConnection


const IfcParse::entity& IfcStructuralSurfaceConnection::declaration() const { return *IfcStructuralSurfaceConnection_type; }
const IfcParse::entity& IfcStructuralSurfaceConnection::Class() { return *IfcStructuralSurfaceConnection_type; }
IfcStructuralSurfaceConnection::IfcStructuralSurfaceConnection(IfcEntityInstanceData* e) : IfcStructuralConnection((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralSurfaceConnection_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralSurfaceConnection::IfcStructuralSurfaceConnection(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralConnection((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralSurfaceConnection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralSurfaceMember
IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum IfcStructuralSurfaceMember::PredefinedType() const { return IfcStructuralSurfaceMemberTypeEnum::FromString(*data_->getArgument(7)); }
void IfcStructuralSurfaceMember::setPredefinedType(IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStructuralSurfaceMemberTypeEnum::ToString(v)));data_->setArgument(7,attr);} }
bool IfcStructuralSurfaceMember::hasThickness() const { return !data_->getArgument(8)->isNull(); }
double IfcStructuralSurfaceMember::Thickness() const { return *data_->getArgument(8); }
void IfcStructuralSurfaceMember::setThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcStructuralSurfaceMember::declaration() const { return *IfcStructuralSurfaceMember_type; }
const IfcParse::entity& IfcStructuralSurfaceMember::Class() { return *IfcStructuralSurfaceMember_type; }
IfcStructuralSurfaceMember::IfcStructuralSurfaceMember(IfcEntityInstanceData* e) : IfcStructuralMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralSurfaceMember_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralSurfaceMember::IfcStructuralSurfaceMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum v8_PredefinedType, boost::optional< double > v9_Thickness) : IfcStructuralMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralSurfaceMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,IfcStructuralSurfaceMemberTypeEnum::ToString(v8_PredefinedType))));data_->setArgument(7,attr);} if (v9_Thickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Thickness));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcStructuralSurfaceMemberVarying


const IfcParse::entity& IfcStructuralSurfaceMemberVarying::declaration() const { return *IfcStructuralSurfaceMemberVarying_type; }
const IfcParse::entity& IfcStructuralSurfaceMemberVarying::Class() { return *IfcStructuralSurfaceMemberVarying_type; }
IfcStructuralSurfaceMemberVarying::IfcStructuralSurfaceMemberVarying(IfcEntityInstanceData* e) : IfcStructuralSurfaceMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralSurfaceMemberVarying_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralSurfaceMemberVarying::IfcStructuralSurfaceMemberVarying(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum v8_PredefinedType, boost::optional< double > v9_Thickness) : IfcStructuralSurfaceMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralSurfaceMemberVarying_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,IfcStructuralSurfaceMemberTypeEnum::ToString(v8_PredefinedType))));data_->setArgument(7,attr);} if (v9_Thickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Thickness));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcStructuralSurfaceReaction
IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum IfcStructuralSurfaceReaction::PredefinedType() const { return IfcStructuralSurfaceActivityTypeEnum::FromString(*data_->getArgument(9)); }
void IfcStructuralSurfaceReaction::setPredefinedType(IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStructuralSurfaceActivityTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcStructuralSurfaceReaction::declaration() const { return *IfcStructuralSurfaceReaction_type; }
const IfcParse::entity& IfcStructuralSurfaceReaction::Class() { return *IfcStructuralSurfaceReaction_type; }
IfcStructuralSurfaceReaction::IfcStructuralSurfaceReaction(IfcEntityInstanceData* e) : IfcStructuralReaction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStructuralSurfaceReaction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStructuralSurfaceReaction::IfcStructuralSurfaceReaction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v10_PredefinedType) : IfcStructuralReaction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStructuralSurfaceReaction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcStructuralSurfaceActivityTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcStyleModel


const IfcParse::entity& IfcStyleModel::declaration() const { return *IfcStyleModel_type; }
const IfcParse::entity& IfcStyleModel::Class() { return *IfcStyleModel_type; }
IfcStyleModel::IfcStyleModel(IfcEntityInstanceData* e) : IfcRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStyleModel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStyleModel::IfcStyleModel(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcRepresentation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStyleModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcStyledItem
bool IfcStyledItem::hasItem() const { return !data_->getArgument(0)->isNull(); }
IfcRepresentationItem* IfcStyledItem::Item() const { return (IfcRepresentationItem*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcStyledItem::setItem(IfcRepresentationItem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcEntityList::ptr IfcStyledItem::Styles() const { return *data_->getArgument(1); }
void IfcStyledItem::setStyles(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcStyledItem::hasName() const { return !data_->getArgument(2)->isNull(); }
std::string IfcStyledItem::Name() const { return *data_->getArgument(2); }
void IfcStyledItem::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcStyledItem::declaration() const { return *IfcStyledItem_type; }
const IfcParse::entity& IfcStyledItem::Class() { return *IfcStyledItem_type; }
IfcStyledItem::IfcStyledItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStyledItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStyledItem::IfcStyledItem(IfcRepresentationItem* v1_Item, IfcEntityList::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStyledItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcStyledRepresentation


const IfcParse::entity& IfcStyledRepresentation::declaration() const { return *IfcStyledRepresentation_type; }
const IfcParse::entity& IfcStyledRepresentation::Class() { return *IfcStyledRepresentation_type; }
IfcStyledRepresentation::IfcStyledRepresentation(IfcEntityInstanceData* e) : IfcStyleModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcStyledRepresentation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcStyledRepresentation::IfcStyledRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcStyleModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcStyledRepresentation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcSubContractResource
bool IfcSubContractResource::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum IfcSubContractResource::PredefinedType() const { return IfcSubContractResourceTypeEnum::FromString(*data_->getArgument(10)); }
void IfcSubContractResource::setPredefinedType(IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSubContractResourceTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& IfcSubContractResource::declaration() const { return *IfcSubContractResource_type; }
const IfcParse::entity& IfcSubContractResource::Class() { return *IfcSubContractResource_type; }
IfcSubContractResource::IfcSubContractResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSubContractResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSubContractResource::IfcSubContractResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSubContractResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Usage));data_->setArgument(7,attr);} if (v9_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_BaseCosts)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_BaseQuantity));data_->setArgument(9,attr);} if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcSubContractResourceTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcSubContractResourceType
IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum IfcSubContractResourceType::PredefinedType() const { return IfcSubContractResourceTypeEnum::FromString(*data_->getArgument(11)); }
void IfcSubContractResourceType::setPredefinedType(IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSubContractResourceTypeEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& IfcSubContractResourceType::declaration() const { return *IfcSubContractResourceType_type; }
const IfcParse::entity& IfcSubContractResourceType::Class() { return *IfcSubContractResourceType_type; }
IfcSubContractResourceType::IfcSubContractResourceType(IfcEntityInstanceData* e) : IfcConstructionResourceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSubContractResourceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSubContractResourceType::IfcSubContractResourceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSubContractResourceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ResourceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ResourceType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_BaseCosts) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_BaseCosts)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseQuantity));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_PredefinedType,IfcSubContractResourceTypeEnum::ToString(v12_PredefinedType))));data_->setArgument(11,attr);} }

// Function implementations for IfcSubedge
IfcEdge* IfcSubedge::ParentEdge() const { return (IfcEdge*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcSubedge::setParentEdge(IfcEdge* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcSubedge::declaration() const { return *IfcSubedge_type; }
const IfcParse::entity& IfcSubedge::Class() { return *IfcSubedge_type; }
IfcSubedge::IfcSubedge(IfcEntityInstanceData* e) : IfcEdge((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSubedge_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSubedge::IfcSubedge(IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcEdge* v3_ParentEdge) : IfcEdge((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSubedge_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeStart));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EdgeEnd));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentEdge));data_->setArgument(2,attr);} }

// Function implementations for IfcSurface


const IfcParse::entity& IfcSurface::declaration() const { return *IfcSurface_type; }
const IfcParse::entity& IfcSurface::Class() { return *IfcSurface_type; }
IfcSurface::IfcSurface(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurface::IfcSurface() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurface_type);  }

// Function implementations for IfcSurfaceCurveSweptAreaSolid
IfcCurve* IfcSurfaceCurveSweptAreaSolid::Directrix() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcSurfaceCurveSweptAreaSolid::setDirectrix(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcSurfaceCurveSweptAreaSolid::hasStartParam() const { return !data_->getArgument(3)->isNull(); }
double IfcSurfaceCurveSweptAreaSolid::StartParam() const { return *data_->getArgument(3); }
void IfcSurfaceCurveSweptAreaSolid::setStartParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcSurfaceCurveSweptAreaSolid::hasEndParam() const { return !data_->getArgument(4)->isNull(); }
double IfcSurfaceCurveSweptAreaSolid::EndParam() const { return *data_->getArgument(4); }
void IfcSurfaceCurveSweptAreaSolid::setEndParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcSurface* IfcSurfaceCurveSweptAreaSolid::ReferenceSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcSurfaceCurveSweptAreaSolid::setReferenceSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcSurfaceCurveSweptAreaSolid::declaration() const { return *IfcSurfaceCurveSweptAreaSolid_type; }
const IfcParse::entity& IfcSurfaceCurveSweptAreaSolid::Class() { return *IfcSurfaceCurveSweptAreaSolid_type; }
IfcSurfaceCurveSweptAreaSolid::IfcSurfaceCurveSweptAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceCurveSweptAreaSolid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceCurveSweptAreaSolid::IfcSurfaceCurveSweptAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcCurve* v3_Directrix, boost::optional< double > v4_StartParam, boost::optional< double > v5_EndParam, IfcSurface* v6_ReferenceSurface) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceCurveSweptAreaSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Directrix));data_->setArgument(2,attr);} if (v4_StartParam) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_StartParam));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_EndParam) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_EndParam));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReferenceSurface));data_->setArgument(5,attr);} }

// Function implementations for IfcSurfaceFeature
bool IfcSurfaceFeature::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum IfcSurfaceFeature::PredefinedType() const { return IfcSurfaceFeatureTypeEnum::FromString(*data_->getArgument(8)); }
void IfcSurfaceFeature::setPredefinedType(IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSurfaceFeatureTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSurfaceFeature::declaration() const { return *IfcSurfaceFeature_type; }
const IfcParse::entity& IfcSurfaceFeature::Class() { return *IfcSurfaceFeature_type; }
IfcSurfaceFeature::IfcSurfaceFeature(IfcEntityInstanceData* e) : IfcFeatureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceFeature_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceFeature::IfcSurfaceFeature(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum > v9_PredefinedType) : IfcFeatureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceFeature_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSurfaceFeatureTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSurfaceOfLinearExtrusion
IfcDirection* IfcSurfaceOfLinearExtrusion::ExtrudedDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcSurfaceOfLinearExtrusion::setExtrudedDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double IfcSurfaceOfLinearExtrusion::Depth() const { return *data_->getArgument(3); }
void IfcSurfaceOfLinearExtrusion::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcSurfaceOfLinearExtrusion::declaration() const { return *IfcSurfaceOfLinearExtrusion_type; }
const IfcParse::entity& IfcSurfaceOfLinearExtrusion::Class() { return *IfcSurfaceOfLinearExtrusion_type; }
IfcSurfaceOfLinearExtrusion::IfcSurfaceOfLinearExtrusion(IfcEntityInstanceData* e) : IfcSweptSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceOfLinearExtrusion_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceOfLinearExtrusion::IfcSurfaceOfLinearExtrusion(IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth) : IfcSweptSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceOfLinearExtrusion_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ExtrudedDirection));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);} }

// Function implementations for IfcSurfaceOfRevolution
IfcAxis1Placement* IfcSurfaceOfRevolution::AxisPosition() const { return (IfcAxis1Placement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcSurfaceOfRevolution::setAxisPosition(IfcAxis1Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcSurfaceOfRevolution::declaration() const { return *IfcSurfaceOfRevolution_type; }
const IfcParse::entity& IfcSurfaceOfRevolution::Class() { return *IfcSurfaceOfRevolution_type; }
IfcSurfaceOfRevolution::IfcSurfaceOfRevolution(IfcEntityInstanceData* e) : IfcSweptSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceOfRevolution_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceOfRevolution::IfcSurfaceOfRevolution(IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_AxisPosition) : IfcSweptSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceOfRevolution_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AxisPosition));data_->setArgument(2,attr);} }

// Function implementations for IfcSurfaceReinforcementArea
bool IfcSurfaceReinforcementArea::hasSurfaceReinforcement1() const { return !data_->getArgument(1)->isNull(); }
std::vector< double > /*[2:3]*/ IfcSurfaceReinforcementArea::SurfaceReinforcement1() const { return *data_->getArgument(1); }
void IfcSurfaceReinforcementArea::setSurfaceReinforcement1(std::vector< double > /*[2:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcSurfaceReinforcementArea::hasSurfaceReinforcement2() const { return !data_->getArgument(2)->isNull(); }
std::vector< double > /*[2:3]*/ IfcSurfaceReinforcementArea::SurfaceReinforcement2() const { return *data_->getArgument(2); }
void IfcSurfaceReinforcementArea::setSurfaceReinforcement2(std::vector< double > /*[2:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcSurfaceReinforcementArea::hasShearReinforcement() const { return !data_->getArgument(3)->isNull(); }
double IfcSurfaceReinforcementArea::ShearReinforcement() const { return *data_->getArgument(3); }
void IfcSurfaceReinforcementArea::setShearReinforcement(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcSurfaceReinforcementArea::declaration() const { return *IfcSurfaceReinforcementArea_type; }
const IfcParse::entity& IfcSurfaceReinforcementArea::Class() { return *IfcSurfaceReinforcementArea_type; }
IfcSurfaceReinforcementArea::IfcSurfaceReinforcementArea(IfcEntityInstanceData* e) : IfcStructuralLoadOrResult((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceReinforcementArea_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceReinforcementArea::IfcSurfaceReinforcementArea(boost::optional< std::string > v1_Name, boost::optional< std::vector< double > /*[2:3]*/ > v2_SurfaceReinforcement1, boost::optional< std::vector< double > /*[2:3]*/ > v3_SurfaceReinforcement2, boost::optional< double > v4_ShearReinforcement) : IfcStructuralLoadOrResult((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceReinforcementArea_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_SurfaceReinforcement1) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_SurfaceReinforcement1));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_SurfaceReinforcement2) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_SurfaceReinforcement2));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ShearReinforcement) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ShearReinforcement));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcSurfaceStyle
IfcSurfaceSide::IfcSurfaceSide IfcSurfaceStyle::Side() const { return IfcSurfaceSide::FromString(*data_->getArgument(1)); }
void IfcSurfaceStyle::setSide(IfcSurfaceSide::IfcSurfaceSide v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSurfaceSide::ToString(v)));data_->setArgument(1,attr);} }
IfcEntityList::ptr IfcSurfaceStyle::Styles() const { return *data_->getArgument(2); }
void IfcSurfaceStyle::setStyles(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcSurfaceStyle::declaration() const { return *IfcSurfaceStyle_type; }
const IfcParse::entity& IfcSurfaceStyle::Class() { return *IfcSurfaceStyle_type; }
IfcSurfaceStyle::IfcSurfaceStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceStyle::IfcSurfaceStyle(boost::optional< std::string > v1_Name, IfcSurfaceSide::IfcSurfaceSide v2_Side, IfcEntityList::ptr v3_Styles) : IfcPresentationStyle((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_Side,IfcSurfaceSide::ToString(v2_Side))));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Styles));data_->setArgument(2,attr);} }

// Function implementations for IfcSurfaceStyleLighting
IfcColourRgb* IfcSurfaceStyleLighting::DiffuseTransmissionColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcSurfaceStyleLighting::setDiffuseTransmissionColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcColourRgb* IfcSurfaceStyleLighting::DiffuseReflectionColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcSurfaceStyleLighting::setDiffuseReflectionColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcColourRgb* IfcSurfaceStyleLighting::TransmissionColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcSurfaceStyleLighting::setTransmissionColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcColourRgb* IfcSurfaceStyleLighting::ReflectanceColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcSurfaceStyleLighting::setReflectanceColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& IfcSurfaceStyleLighting::declaration() const { return *IfcSurfaceStyleLighting_type; }
const IfcParse::entity& IfcSurfaceStyleLighting::Class() { return *IfcSurfaceStyleLighting_type; }
IfcSurfaceStyleLighting::IfcSurfaceStyleLighting(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceStyleLighting_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceStyleLighting::IfcSurfaceStyleLighting(IfcColourRgb* v1_DiffuseTransmissionColour, IfcColourRgb* v2_DiffuseReflectionColour, IfcColourRgb* v3_TransmissionColour, IfcColourRgb* v4_ReflectanceColour) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceStyleLighting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DiffuseTransmissionColour));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_DiffuseReflectionColour));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TransmissionColour));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ReflectanceColour));data_->setArgument(3,attr);} }

// Function implementations for IfcSurfaceStyleRefraction
bool IfcSurfaceStyleRefraction::hasRefractionIndex() const { return !data_->getArgument(0)->isNull(); }
double IfcSurfaceStyleRefraction::RefractionIndex() const { return *data_->getArgument(0); }
void IfcSurfaceStyleRefraction::setRefractionIndex(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcSurfaceStyleRefraction::hasDispersionFactor() const { return !data_->getArgument(1)->isNull(); }
double IfcSurfaceStyleRefraction::DispersionFactor() const { return *data_->getArgument(1); }
void IfcSurfaceStyleRefraction::setDispersionFactor(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcSurfaceStyleRefraction::declaration() const { return *IfcSurfaceStyleRefraction_type; }
const IfcParse::entity& IfcSurfaceStyleRefraction::Class() { return *IfcSurfaceStyleRefraction_type; }
IfcSurfaceStyleRefraction::IfcSurfaceStyleRefraction(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceStyleRefraction_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceStyleRefraction::IfcSurfaceStyleRefraction(boost::optional< double > v1_RefractionIndex, boost::optional< double > v2_DispersionFactor) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceStyleRefraction_type);  if (v1_RefractionIndex) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_RefractionIndex));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DispersionFactor) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DispersionFactor));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcSurfaceStyleRendering
bool IfcSurfaceStyleRendering::hasDiffuseColour() const { return !data_->getArgument(2)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::DiffuseColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcSurfaceStyleRendering::setDiffuseColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcSurfaceStyleRendering::hasTransmissionColour() const { return !data_->getArgument(3)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::TransmissionColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcSurfaceStyleRendering::setTransmissionColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcSurfaceStyleRendering::hasDiffuseTransmissionColour() const { return !data_->getArgument(4)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::DiffuseTransmissionColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcSurfaceStyleRendering::setDiffuseTransmissionColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcSurfaceStyleRendering::hasReflectionColour() const { return !data_->getArgument(5)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::ReflectionColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcSurfaceStyleRendering::setReflectionColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcSurfaceStyleRendering::hasSpecularColour() const { return !data_->getArgument(6)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::SpecularColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcSurfaceStyleRendering::setSpecularColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcSurfaceStyleRendering::hasSpecularHighlight() const { return !data_->getArgument(7)->isNull(); }
IfcSpecularHighlightSelect* IfcSurfaceStyleRendering::SpecularHighlight() const { return (IfcSpecularHighlightSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcSurfaceStyleRendering::setSpecularHighlight(IfcSpecularHighlightSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
IfcReflectanceMethodEnum::IfcReflectanceMethodEnum IfcSurfaceStyleRendering::ReflectanceMethod() const { return IfcReflectanceMethodEnum::FromString(*data_->getArgument(8)); }
void IfcSurfaceStyleRendering::setReflectanceMethod(IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReflectanceMethodEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSurfaceStyleRendering::declaration() const { return *IfcSurfaceStyleRendering_type; }
const IfcParse::entity& IfcSurfaceStyleRendering::Class() { return *IfcSurfaceStyleRendering_type; }
IfcSurfaceStyleRendering::IfcSurfaceStyleRendering(IfcEntityInstanceData* e) : IfcSurfaceStyleShading((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceStyleRendering_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceStyleRendering::IfcSurfaceStyleRendering(IfcColourRgb* v1_SurfaceColour, boost::optional< double > v2_Transparency, IfcColourOrFactor* v3_DiffuseColour, IfcColourOrFactor* v4_TransmissionColour, IfcColourOrFactor* v5_DiffuseTransmissionColour, IfcColourOrFactor* v6_ReflectionColour, IfcColourOrFactor* v7_SpecularColour, IfcSpecularHighlightSelect* v8_SpecularHighlight, IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v9_ReflectanceMethod) : IfcSurfaceStyleShading((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceStyleRendering_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SurfaceColour));data_->setArgument(0,attr);} if (v2_Transparency) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Transparency));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_DiffuseColour));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TransmissionColour));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_DiffuseTransmissionColour));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReflectionColour));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SpecularColour));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_SpecularHighlight));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ReflectanceMethod,IfcReflectanceMethodEnum::ToString(v9_ReflectanceMethod))));data_->setArgument(8,attr);} }

// Function implementations for IfcSurfaceStyleShading
IfcColourRgb* IfcSurfaceStyleShading::SurfaceColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcSurfaceStyleShading::setSurfaceColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcSurfaceStyleShading::hasTransparency() const { return !data_->getArgument(1)->isNull(); }
double IfcSurfaceStyleShading::Transparency() const { return *data_->getArgument(1); }
void IfcSurfaceStyleShading::setTransparency(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcSurfaceStyleShading::declaration() const { return *IfcSurfaceStyleShading_type; }
const IfcParse::entity& IfcSurfaceStyleShading::Class() { return *IfcSurfaceStyleShading_type; }
IfcSurfaceStyleShading::IfcSurfaceStyleShading(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceStyleShading_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceStyleShading::IfcSurfaceStyleShading(IfcColourRgb* v1_SurfaceColour, boost::optional< double > v2_Transparency) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceStyleShading_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SurfaceColour));data_->setArgument(0,attr);} if (v2_Transparency) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Transparency));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcSurfaceStyleWithTextures
IfcTemplatedEntityList< IfcSurfaceTexture >::ptr IfcSurfaceStyleWithTextures::Textures() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcSurfaceTexture>(); }
void IfcSurfaceStyleWithTextures::setTextures(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& IfcSurfaceStyleWithTextures::declaration() const { return *IfcSurfaceStyleWithTextures_type; }
const IfcParse::entity& IfcSurfaceStyleWithTextures::Class() { return *IfcSurfaceStyleWithTextures_type; }
IfcSurfaceStyleWithTextures::IfcSurfaceStyleWithTextures(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceStyleWithTextures_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceStyleWithTextures::IfcSurfaceStyleWithTextures(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Textures) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceStyleWithTextures_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Textures)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcSurfaceTexture
bool IfcSurfaceTexture::RepeatS() const { return *data_->getArgument(0); }
void IfcSurfaceTexture::setRepeatS(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcSurfaceTexture::RepeatT() const { return *data_->getArgument(1); }
void IfcSurfaceTexture::setRepeatT(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcSurfaceTexture::hasMode() const { return !data_->getArgument(2)->isNull(); }
std::string IfcSurfaceTexture::Mode() const { return *data_->getArgument(2); }
void IfcSurfaceTexture::setMode(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcSurfaceTexture::hasTextureTransform() const { return !data_->getArgument(3)->isNull(); }
IfcCartesianTransformationOperator2D* IfcSurfaceTexture::TextureTransform() const { return (IfcCartesianTransformationOperator2D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcSurfaceTexture::setTextureTransform(IfcCartesianTransformationOperator2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcSurfaceTexture::hasParameter() const { return !data_->getArgument(4)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcSurfaceTexture::Parameter() const { return *data_->getArgument(4); }
void IfcSurfaceTexture::setParameter(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }

IfcTextureCoordinate::list::ptr IfcSurfaceTexture::IsMappedBy() const { return data_->getInverse(IfcTextureCoordinate_type, 0)->as<IfcTextureCoordinate>(); }
IfcSurfaceStyleWithTextures::list::ptr IfcSurfaceTexture::UsedInStyles() const { return data_->getInverse(IfcSurfaceStyleWithTextures_type, 0)->as<IfcSurfaceStyleWithTextures>(); }

const IfcParse::entity& IfcSurfaceTexture::declaration() const { return *IfcSurfaceTexture_type; }
const IfcParse::entity& IfcSurfaceTexture::Class() { return *IfcSurfaceTexture_type; }
IfcSurfaceTexture::IfcSurfaceTexture(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSurfaceTexture_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSurfaceTexture::IfcSurfaceTexture(bool v1_RepeatS, bool v2_RepeatT, boost::optional< std::string > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_Parameter) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSurfaceTexture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));data_->setArgument(1,attr);} if (v3_Mode) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Mode));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));data_->setArgument(3,attr);} if (v5_Parameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Parameter));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcSweptAreaSolid
IfcProfileDef* IfcSweptAreaSolid::SweptArea() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcSweptAreaSolid::setSweptArea(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcSweptAreaSolid::hasPosition() const { return !data_->getArgument(1)->isNull(); }
IfcAxis2Placement3D* IfcSweptAreaSolid::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcSweptAreaSolid::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcSweptAreaSolid::declaration() const { return *IfcSweptAreaSolid_type; }
const IfcParse::entity& IfcSweptAreaSolid::Class() { return *IfcSweptAreaSolid_type; }
IfcSweptAreaSolid::IfcSweptAreaSolid(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSweptAreaSolid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSweptAreaSolid::IfcSweptAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position) : IfcSolidModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSweptAreaSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);} }

// Function implementations for IfcSweptDiskSolid
IfcCurve* IfcSweptDiskSolid::Directrix() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcSweptDiskSolid::setDirectrix(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcSweptDiskSolid::Radius() const { return *data_->getArgument(1); }
void IfcSweptDiskSolid::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcSweptDiskSolid::hasInnerRadius() const { return !data_->getArgument(2)->isNull(); }
double IfcSweptDiskSolid::InnerRadius() const { return *data_->getArgument(2); }
void IfcSweptDiskSolid::setInnerRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcSweptDiskSolid::hasStartParam() const { return !data_->getArgument(3)->isNull(); }
double IfcSweptDiskSolid::StartParam() const { return *data_->getArgument(3); }
void IfcSweptDiskSolid::setStartParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcSweptDiskSolid::hasEndParam() const { return !data_->getArgument(4)->isNull(); }
double IfcSweptDiskSolid::EndParam() const { return *data_->getArgument(4); }
void IfcSweptDiskSolid::setEndParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcSweptDiskSolid::declaration() const { return *IfcSweptDiskSolid_type; }
const IfcParse::entity& IfcSweptDiskSolid::Class() { return *IfcSweptDiskSolid_type; }
IfcSweptDiskSolid::IfcSweptDiskSolid(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSweptDiskSolid_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSweptDiskSolid::IfcSweptDiskSolid(IfcCurve* v1_Directrix, double v2_Radius, boost::optional< double > v3_InnerRadius, boost::optional< double > v4_StartParam, boost::optional< double > v5_EndParam) : IfcSolidModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSweptDiskSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Directrix));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));data_->setArgument(1,attr);} if (v3_InnerRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_InnerRadius));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_StartParam) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_StartParam));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_EndParam) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_EndParam));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcSweptDiskSolidPolygonal
bool IfcSweptDiskSolidPolygonal::hasFilletRadius() const { return !data_->getArgument(5)->isNull(); }
double IfcSweptDiskSolidPolygonal::FilletRadius() const { return *data_->getArgument(5); }
void IfcSweptDiskSolidPolygonal::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcSweptDiskSolidPolygonal::declaration() const { return *IfcSweptDiskSolidPolygonal_type; }
const IfcParse::entity& IfcSweptDiskSolidPolygonal::Class() { return *IfcSweptDiskSolidPolygonal_type; }
IfcSweptDiskSolidPolygonal::IfcSweptDiskSolidPolygonal(IfcEntityInstanceData* e) : IfcSweptDiskSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSweptDiskSolidPolygonal_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSweptDiskSolidPolygonal::IfcSweptDiskSolidPolygonal(IfcCurve* v1_Directrix, double v2_Radius, boost::optional< double > v3_InnerRadius, boost::optional< double > v4_StartParam, boost::optional< double > v5_EndParam, boost::optional< double > v6_FilletRadius) : IfcSweptDiskSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSweptDiskSolidPolygonal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Directrix));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));data_->setArgument(1,attr);} if (v3_InnerRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_InnerRadius));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_StartParam) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_StartParam));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_EndParam) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_EndParam));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_FilletRadius));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcSweptSurface
IfcProfileDef* IfcSweptSurface::SweptCurve() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcSweptSurface::setSweptCurve(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcSweptSurface::hasPosition() const { return !data_->getArgument(1)->isNull(); }
IfcAxis2Placement3D* IfcSweptSurface::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcSweptSurface::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcSweptSurface::declaration() const { return *IfcSweptSurface_type; }
const IfcParse::entity& IfcSweptSurface::Class() { return *IfcSweptSurface_type; }
IfcSweptSurface::IfcSweptSurface(IfcEntityInstanceData* e) : IfcSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSweptSurface_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSweptSurface::IfcSweptSurface(IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position) : IfcSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSweptSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);} }

// Function implementations for IfcSwitchingDevice
bool IfcSwitchingDevice::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum IfcSwitchingDevice::PredefinedType() const { return IfcSwitchingDeviceTypeEnum::FromString(*data_->getArgument(8)); }
void IfcSwitchingDevice::setPredefinedType(IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSwitchingDeviceTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSwitchingDevice::declaration() const { return *IfcSwitchingDevice_type; }
const IfcParse::entity& IfcSwitchingDevice::Class() { return *IfcSwitchingDevice_type; }
IfcSwitchingDevice::IfcSwitchingDevice(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSwitchingDevice_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSwitchingDevice::IfcSwitchingDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum > v9_PredefinedType) : IfcFlowController((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSwitchingDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSwitchingDeviceTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSwitchingDeviceType
IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum IfcSwitchingDeviceType::PredefinedType() const { return IfcSwitchingDeviceTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSwitchingDeviceType::setPredefinedType(IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSwitchingDeviceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcSwitchingDeviceType::declaration() const { return *IfcSwitchingDeviceType_type; }
const IfcParse::entity& IfcSwitchingDeviceType::Class() { return *IfcSwitchingDeviceType_type; }
IfcSwitchingDeviceType::IfcSwitchingDeviceType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSwitchingDeviceType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSwitchingDeviceType::IfcSwitchingDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSwitchingDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSwitchingDeviceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcSystem

IfcRelServicesBuildings::list::ptr IfcSystem::ServicesBuildings() const { return data_->getInverse(IfcRelServicesBuildings_type, 4)->as<IfcRelServicesBuildings>(); }

const IfcParse::entity& IfcSystem::declaration() const { return *IfcSystem_type; }
const IfcParse::entity& IfcSystem::Class() { return *IfcSystem_type; }
IfcSystem::IfcSystem(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSystem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSystem::IfcSystem(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSystem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcSystemFurnitureElement
bool IfcSystemFurnitureElement::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum IfcSystemFurnitureElement::PredefinedType() const { return IfcSystemFurnitureElementTypeEnum::FromString(*data_->getArgument(8)); }
void IfcSystemFurnitureElement::setPredefinedType(IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSystemFurnitureElementTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcSystemFurnitureElement::declaration() const { return *IfcSystemFurnitureElement_type; }
const IfcParse::entity& IfcSystemFurnitureElement::Class() { return *IfcSystemFurnitureElement_type; }
IfcSystemFurnitureElement::IfcSystemFurnitureElement(IfcEntityInstanceData* e) : IfcFurnishingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSystemFurnitureElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSystemFurnitureElement::IfcSystemFurnitureElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum > v9_PredefinedType) : IfcFurnishingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSystemFurnitureElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSystemFurnitureElementTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSystemFurnitureElementType
bool IfcSystemFurnitureElementType::hasPredefinedType() const { return !data_->getArgument(9)->isNull(); }
IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum IfcSystemFurnitureElementType::PredefinedType() const { return IfcSystemFurnitureElementTypeEnum::FromString(*data_->getArgument(9)); }
void IfcSystemFurnitureElementType::setPredefinedType(IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSystemFurnitureElementTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcSystemFurnitureElementType::declaration() const { return *IfcSystemFurnitureElementType_type; }
const IfcParse::entity& IfcSystemFurnitureElementType::Class() { return *IfcSystemFurnitureElementType_type; }
IfcSystemFurnitureElementType::IfcSystemFurnitureElementType(IfcEntityInstanceData* e) : IfcFurnishingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcSystemFurnitureElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcSystemFurnitureElementType::IfcSystemFurnitureElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, boost::optional< IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum > v10_PredefinedType) : IfcFurnishingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcSystemFurnitureElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v10_PredefinedType,IfcSystemFurnitureElementTypeEnum::ToString(*v10_PredefinedType))));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcTShapeProfileDef
double IfcTShapeProfileDef::Depth() const { return *data_->getArgument(3); }
void IfcTShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcTShapeProfileDef::FlangeWidth() const { return *data_->getArgument(4); }
void IfcTShapeProfileDef::setFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double IfcTShapeProfileDef::WebThickness() const { return *data_->getArgument(5); }
void IfcTShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double IfcTShapeProfileDef::FlangeThickness() const { return *data_->getArgument(6); }
void IfcTShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcTShapeProfileDef::hasFilletRadius() const { return !data_->getArgument(7)->isNull(); }
double IfcTShapeProfileDef::FilletRadius() const { return *data_->getArgument(7); }
void IfcTShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcTShapeProfileDef::hasFlangeEdgeRadius() const { return !data_->getArgument(8)->isNull(); }
double IfcTShapeProfileDef::FlangeEdgeRadius() const { return *data_->getArgument(8); }
void IfcTShapeProfileDef::setFlangeEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcTShapeProfileDef::hasWebEdgeRadius() const { return !data_->getArgument(9)->isNull(); }
double IfcTShapeProfileDef::WebEdgeRadius() const { return *data_->getArgument(9); }
void IfcTShapeProfileDef::setWebEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcTShapeProfileDef::hasWebSlope() const { return !data_->getArgument(10)->isNull(); }
double IfcTShapeProfileDef::WebSlope() const { return *data_->getArgument(10); }
void IfcTShapeProfileDef::setWebSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcTShapeProfileDef::hasFlangeSlope() const { return !data_->getArgument(11)->isNull(); }
double IfcTShapeProfileDef::FlangeSlope() const { return *data_->getArgument(11); }
void IfcTShapeProfileDef::setFlangeSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }


const IfcParse::entity& IfcTShapeProfileDef::declaration() const { return *IfcTShapeProfileDef_type; }
const IfcParse::entity& IfcTShapeProfileDef::Class() { return *IfcTShapeProfileDef_type; }
IfcTShapeProfileDef::IfcTShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTShapeProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTShapeProfileDef::IfcTShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_FlangeEdgeRadius, boost::optional< double > v10_WebEdgeRadius, boost::optional< double > v11_WebSlope, boost::optional< double > v12_FlangeSlope) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_FlangeWidth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));data_->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_FlangeEdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FlangeEdgeRadius));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_WebEdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_WebEdgeRadius));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_WebSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_WebSlope));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_FlangeSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_FlangeSlope));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } }

// Function implementations for IfcTable
bool IfcTable::hasName() const { return !data_->getArgument(0)->isNull(); }
std::string IfcTable::Name() const { return *data_->getArgument(0); }
void IfcTable::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcTable::hasRows() const { return !data_->getArgument(1)->isNull(); }
IfcTemplatedEntityList< IfcTableRow >::ptr IfcTable::Rows() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcTableRow>(); }
void IfcTable::setRows(IfcTemplatedEntityList< IfcTableRow >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }
bool IfcTable::hasColumns() const { return !data_->getArgument(2)->isNull(); }
IfcTemplatedEntityList< IfcTableColumn >::ptr IfcTable::Columns() const { IfcEntityList::ptr es = *data_->getArgument(2); return es->as<IfcTableColumn>(); }
void IfcTable::setColumns(IfcTemplatedEntityList< IfcTableColumn >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& IfcTable::declaration() const { return *IfcTable_type; }
const IfcParse::entity& IfcTable::Class() { return *IfcTable_type; }
IfcTable::IfcTable(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcTable_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTable::IfcTable(boost::optional< std::string > v1_Name, boost::optional< IfcTemplatedEntityList< IfcTableRow >::ptr > v2_Rows, boost::optional< IfcTemplatedEntityList< IfcTableColumn >::ptr > v3_Columns) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcTable_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Rows) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Rows)->generalize());data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Columns) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Columns)->generalize());data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcTableColumn
bool IfcTableColumn::hasIdentifier() const { return !data_->getArgument(0)->isNull(); }
std::string IfcTableColumn::Identifier() const { return *data_->getArgument(0); }
void IfcTableColumn::setIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcTableColumn::hasName() const { return !data_->getArgument(1)->isNull(); }
std::string IfcTableColumn::Name() const { return *data_->getArgument(1); }
void IfcTableColumn::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcTableColumn::hasDescription() const { return !data_->getArgument(2)->isNull(); }
std::string IfcTableColumn::Description() const { return *data_->getArgument(2); }
void IfcTableColumn::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcTableColumn::hasUnit() const { return !data_->getArgument(3)->isNull(); }
IfcUnit* IfcTableColumn::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcTableColumn::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcTableColumn::hasReferencePath() const { return !data_->getArgument(4)->isNull(); }
IfcReference* IfcTableColumn::ReferencePath() const { return (IfcReference*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcTableColumn::setReferencePath(IfcReference* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcTableColumn::declaration() const { return *IfcTableColumn_type; }
const IfcParse::entity& IfcTableColumn::Class() { return *IfcTableColumn_type; }
IfcTableColumn::IfcTableColumn(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcTableColumn_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTableColumn::IfcTableColumn(boost::optional< std::string > v1_Identifier, boost::optional< std::string > v2_Name, boost::optional< std::string > v3_Description, IfcUnit* v4_Unit, IfcReference* v5_ReferencePath) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcTableColumn_type);  if (v1_Identifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Identifier));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Name));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Unit));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ReferencePath));data_->setArgument(4,attr);} }

// Function implementations for IfcTableRow
bool IfcTableRow::hasRowCells() const { return !data_->getArgument(0)->isNull(); }
IfcEntityList::ptr IfcTableRow::RowCells() const { return *data_->getArgument(0); }
void IfcTableRow::setRowCells(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcTableRow::hasIsHeading() const { return !data_->getArgument(1)->isNull(); }
bool IfcTableRow::IsHeading() const { return *data_->getArgument(1); }
void IfcTableRow::setIsHeading(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcTableRow::declaration() const { return *IfcTableRow_type; }
const IfcParse::entity& IfcTableRow::Class() { return *IfcTableRow_type; }
IfcTableRow::IfcTableRow(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcTableRow_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTableRow::IfcTableRow(boost::optional< IfcEntityList::ptr > v1_RowCells, boost::optional< bool > v2_IsHeading) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcTableRow_type);  if (v1_RowCells) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_RowCells));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_IsHeading) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_IsHeading));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcTank
bool IfcTank::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcTankTypeEnum::IfcTankTypeEnum IfcTank::PredefinedType() const { return IfcTankTypeEnum::FromString(*data_->getArgument(8)); }
void IfcTank::setPredefinedType(IfcTankTypeEnum::IfcTankTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTankTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcTank::declaration() const { return *IfcTank_type; }
const IfcParse::entity& IfcTank::Class() { return *IfcTank_type; }
IfcTank::IfcTank(IfcEntityInstanceData* e) : IfcFlowStorageDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTank_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTank::IfcTank(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTankTypeEnum::IfcTankTypeEnum > v9_PredefinedType) : IfcFlowStorageDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTank_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcTankTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcTankType
IfcTankTypeEnum::IfcTankTypeEnum IfcTankType::PredefinedType() const { return IfcTankTypeEnum::FromString(*data_->getArgument(9)); }
void IfcTankType::setPredefinedType(IfcTankTypeEnum::IfcTankTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTankTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcTankType::declaration() const { return *IfcTankType_type; }
const IfcParse::entity& IfcTankType::Class() { return *IfcTankType_type; }
IfcTankType::IfcTankType(IfcEntityInstanceData* e) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTankType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTankType::IfcTankType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTankTypeEnum::IfcTankTypeEnum v10_PredefinedType) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTankType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTankTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcTask
bool IfcTask::hasStatus() const { return !data_->getArgument(7)->isNull(); }
std::string IfcTask::Status() const { return *data_->getArgument(7); }
void IfcTask::setStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcTask::hasWorkMethod() const { return !data_->getArgument(8)->isNull(); }
std::string IfcTask::WorkMethod() const { return *data_->getArgument(8); }
void IfcTask::setWorkMethod(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcTask::IsMilestone() const { return *data_->getArgument(9); }
void IfcTask::setIsMilestone(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcTask::hasPriority() const { return !data_->getArgument(10)->isNull(); }
int IfcTask::Priority() const { return *data_->getArgument(10); }
void IfcTask::setPriority(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcTask::hasTaskTime() const { return !data_->getArgument(11)->isNull(); }
IfcTaskTime* IfcTask::TaskTime() const { return (IfcTaskTime*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(11))); }
void IfcTask::setTaskTime(IfcTaskTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcTask::hasPredefinedType() const { return !data_->getArgument(12)->isNull(); }
IfcTaskTypeEnum::IfcTaskTypeEnum IfcTask::PredefinedType() const { return IfcTaskTypeEnum::FromString(*data_->getArgument(12)); }
void IfcTask::setPredefinedType(IfcTaskTypeEnum::IfcTaskTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTaskTypeEnum::ToString(v)));data_->setArgument(12,attr);} }


const IfcParse::entity& IfcTask::declaration() const { return *IfcTask_type; }
const IfcParse::entity& IfcTask::Class() { return *IfcTask_type; }
IfcTask::IfcTask(IfcEntityInstanceData* e) : IfcProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTask_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTask::IfcTask(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_WorkMethod, bool v10_IsMilestone, boost::optional< int > v11_Priority, IfcTaskTime* v12_TaskTime, boost::optional< IfcTaskTypeEnum::IfcTaskTypeEnum > v13_PredefinedType) : IfcProcess((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTask_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LongDescription));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Status));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_WorkMethod) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_WorkMethod));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_IsMilestone));data_->setArgument(9,attr);} if (v11_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_Priority));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_TaskTime));data_->setArgument(11,attr);} if (v13_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v13_PredefinedType,IfcTaskTypeEnum::ToString(*v13_PredefinedType))));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcTaskTime
bool IfcTaskTime::hasDurationType() const { return !data_->getArgument(3)->isNull(); }
IfcTaskDurationEnum::IfcTaskDurationEnum IfcTaskTime::DurationType() const { return IfcTaskDurationEnum::FromString(*data_->getArgument(3)); }
void IfcTaskTime::setDurationType(IfcTaskDurationEnum::IfcTaskDurationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTaskDurationEnum::ToString(v)));data_->setArgument(3,attr);} }
bool IfcTaskTime::hasScheduleDuration() const { return !data_->getArgument(4)->isNull(); }
std::string IfcTaskTime::ScheduleDuration() const { return *data_->getArgument(4); }
void IfcTaskTime::setScheduleDuration(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcTaskTime::hasScheduleStart() const { return !data_->getArgument(5)->isNull(); }
std::string IfcTaskTime::ScheduleStart() const { return *data_->getArgument(5); }
void IfcTaskTime::setScheduleStart(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcTaskTime::hasScheduleFinish() const { return !data_->getArgument(6)->isNull(); }
std::string IfcTaskTime::ScheduleFinish() const { return *data_->getArgument(6); }
void IfcTaskTime::setScheduleFinish(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcTaskTime::hasEarlyStart() const { return !data_->getArgument(7)->isNull(); }
std::string IfcTaskTime::EarlyStart() const { return *data_->getArgument(7); }
void IfcTaskTime::setEarlyStart(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcTaskTime::hasEarlyFinish() const { return !data_->getArgument(8)->isNull(); }
std::string IfcTaskTime::EarlyFinish() const { return *data_->getArgument(8); }
void IfcTaskTime::setEarlyFinish(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcTaskTime::hasLateStart() const { return !data_->getArgument(9)->isNull(); }
std::string IfcTaskTime::LateStart() const { return *data_->getArgument(9); }
void IfcTaskTime::setLateStart(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcTaskTime::hasLateFinish() const { return !data_->getArgument(10)->isNull(); }
std::string IfcTaskTime::LateFinish() const { return *data_->getArgument(10); }
void IfcTaskTime::setLateFinish(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcTaskTime::hasFreeFloat() const { return !data_->getArgument(11)->isNull(); }
std::string IfcTaskTime::FreeFloat() const { return *data_->getArgument(11); }
void IfcTaskTime::setFreeFloat(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcTaskTime::hasTotalFloat() const { return !data_->getArgument(12)->isNull(); }
std::string IfcTaskTime::TotalFloat() const { return *data_->getArgument(12); }
void IfcTaskTime::setTotalFloat(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcTaskTime::hasIsCritical() const { return !data_->getArgument(13)->isNull(); }
bool IfcTaskTime::IsCritical() const { return *data_->getArgument(13); }
void IfcTaskTime::setIsCritical(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
bool IfcTaskTime::hasStatusTime() const { return !data_->getArgument(14)->isNull(); }
std::string IfcTaskTime::StatusTime() const { return *data_->getArgument(14); }
void IfcTaskTime::setStatusTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
bool IfcTaskTime::hasActualDuration() const { return !data_->getArgument(15)->isNull(); }
std::string IfcTaskTime::ActualDuration() const { return *data_->getArgument(15); }
void IfcTaskTime::setActualDuration(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }
bool IfcTaskTime::hasActualStart() const { return !data_->getArgument(16)->isNull(); }
std::string IfcTaskTime::ActualStart() const { return *data_->getArgument(16); }
void IfcTaskTime::setActualStart(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(16,attr);} }
bool IfcTaskTime::hasActualFinish() const { return !data_->getArgument(17)->isNull(); }
std::string IfcTaskTime::ActualFinish() const { return *data_->getArgument(17); }
void IfcTaskTime::setActualFinish(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(17,attr);} }
bool IfcTaskTime::hasRemainingTime() const { return !data_->getArgument(18)->isNull(); }
std::string IfcTaskTime::RemainingTime() const { return *data_->getArgument(18); }
void IfcTaskTime::setRemainingTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(18,attr);} }
bool IfcTaskTime::hasCompletion() const { return !data_->getArgument(19)->isNull(); }
double IfcTaskTime::Completion() const { return *data_->getArgument(19); }
void IfcTaskTime::setCompletion(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(19,attr);} }


const IfcParse::entity& IfcTaskTime::declaration() const { return *IfcTaskTime_type; }
const IfcParse::entity& IfcTaskTime::Class() { return *IfcTaskTime_type; }
IfcTaskTime::IfcTaskTime(IfcEntityInstanceData* e) : IfcSchedulingTime((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTaskTime_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTaskTime::IfcTaskTime(boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, boost::optional< IfcTaskDurationEnum::IfcTaskDurationEnum > v4_DurationType, boost::optional< std::string > v5_ScheduleDuration, boost::optional< std::string > v6_ScheduleStart, boost::optional< std::string > v7_ScheduleFinish, boost::optional< std::string > v8_EarlyStart, boost::optional< std::string > v9_EarlyFinish, boost::optional< std::string > v10_LateStart, boost::optional< std::string > v11_LateFinish, boost::optional< std::string > v12_FreeFloat, boost::optional< std::string > v13_TotalFloat, boost::optional< bool > v14_IsCritical, boost::optional< std::string > v15_StatusTime, boost::optional< std::string > v16_ActualDuration, boost::optional< std::string > v17_ActualStart, boost::optional< std::string > v18_ActualFinish, boost::optional< std::string > v19_RemainingTime, boost::optional< double > v20_Completion) : IfcSchedulingTime((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTaskTime_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin))));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedDataOrigin));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DurationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v4_DurationType,IfcTaskDurationEnum::ToString(*v4_DurationType))));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ScheduleDuration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ScheduleDuration));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ScheduleStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ScheduleStart));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ScheduleFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ScheduleFinish));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_EarlyStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_EarlyStart));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_EarlyFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_EarlyFinish));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_LateStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_LateStart));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_LateFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_LateFinish));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_FreeFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_FreeFloat));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_TotalFloat));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_IsCritical) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_IsCritical));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_StatusTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_StatusTime));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_ActualDuration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_ActualDuration));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_ActualStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_ActualStart));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } if (v18_ActualFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_ActualFinish));data_->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(17, attr); } if (v19_RemainingTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_RemainingTime));data_->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(18, attr); } if (v20_Completion) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v20_Completion));data_->setArgument(19,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(19, attr); } }

// Function implementations for IfcTaskTimeRecurring
IfcRecurrencePattern* IfcTaskTimeRecurring::Recurrence() const { return (IfcRecurrencePattern*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(20))); }
void IfcTaskTimeRecurring::setRecurrence(IfcRecurrencePattern* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(20,attr);} }


const IfcParse::entity& IfcTaskTimeRecurring::declaration() const { return *IfcTaskTimeRecurring_type; }
const IfcParse::entity& IfcTaskTimeRecurring::Class() { return *IfcTaskTimeRecurring_type; }
IfcTaskTimeRecurring::IfcTaskTimeRecurring(IfcEntityInstanceData* e) : IfcTaskTime((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTaskTimeRecurring_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTaskTimeRecurring::IfcTaskTimeRecurring(boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, boost::optional< IfcTaskDurationEnum::IfcTaskDurationEnum > v4_DurationType, boost::optional< std::string > v5_ScheduleDuration, boost::optional< std::string > v6_ScheduleStart, boost::optional< std::string > v7_ScheduleFinish, boost::optional< std::string > v8_EarlyStart, boost::optional< std::string > v9_EarlyFinish, boost::optional< std::string > v10_LateStart, boost::optional< std::string > v11_LateFinish, boost::optional< std::string > v12_FreeFloat, boost::optional< std::string > v13_TotalFloat, boost::optional< bool > v14_IsCritical, boost::optional< std::string > v15_StatusTime, boost::optional< std::string > v16_ActualDuration, boost::optional< std::string > v17_ActualStart, boost::optional< std::string > v18_ActualFinish, boost::optional< std::string > v19_RemainingTime, boost::optional< double > v20_Completion, IfcRecurrencePattern* v21_Recurrence) : IfcTaskTime((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTaskTimeRecurring_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin))));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedDataOrigin));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DurationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v4_DurationType,IfcTaskDurationEnum::ToString(*v4_DurationType))));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ScheduleDuration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ScheduleDuration));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ScheduleStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ScheduleStart));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ScheduleFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ScheduleFinish));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_EarlyStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_EarlyStart));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_EarlyFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_EarlyFinish));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_LateStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_LateStart));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_LateFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_LateFinish));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_FreeFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_FreeFloat));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_TotalFloat));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_IsCritical) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_IsCritical));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_StatusTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_StatusTime));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_ActualDuration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_ActualDuration));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_ActualStart) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_ActualStart));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } if (v18_ActualFinish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_ActualFinish));data_->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(17, attr); } if (v19_RemainingTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_RemainingTime));data_->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(18, attr); } if (v20_Completion) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v20_Completion));data_->setArgument(19,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(19, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v21_Recurrence));data_->setArgument(20,attr);} }

// Function implementations for IfcTaskType
IfcTaskTypeEnum::IfcTaskTypeEnum IfcTaskType::PredefinedType() const { return IfcTaskTypeEnum::FromString(*data_->getArgument(9)); }
void IfcTaskType::setPredefinedType(IfcTaskTypeEnum::IfcTaskTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTaskTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcTaskType::hasWorkMethod() const { return !data_->getArgument(10)->isNull(); }
std::string IfcTaskType::WorkMethod() const { return *data_->getArgument(10); }
void IfcTaskType::setWorkMethod(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& IfcTaskType::declaration() const { return *IfcTaskType_type; }
const IfcParse::entity& IfcTaskType::Class() { return *IfcTaskType_type; }
IfcTaskType::IfcTaskType(IfcEntityInstanceData* e) : IfcTypeProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTaskType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTaskType::IfcTaskType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ProcessType, IfcTaskTypeEnum::IfcTaskTypeEnum v10_PredefinedType, boost::optional< std::string > v11_WorkMethod) : IfcTypeProcess((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTaskType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ProcessType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ProcessType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTaskTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} if (v11_WorkMethod) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_WorkMethod));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcTelecomAddress
bool IfcTelecomAddress::hasTelephoneNumbers() const { return !data_->getArgument(3)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcTelecomAddress::TelephoneNumbers() const { return *data_->getArgument(3); }
void IfcTelecomAddress::setTelephoneNumbers(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcTelecomAddress::hasFacsimileNumbers() const { return !data_->getArgument(4)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcTelecomAddress::FacsimileNumbers() const { return *data_->getArgument(4); }
void IfcTelecomAddress::setFacsimileNumbers(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcTelecomAddress::hasPagerNumber() const { return !data_->getArgument(5)->isNull(); }
std::string IfcTelecomAddress::PagerNumber() const { return *data_->getArgument(5); }
void IfcTelecomAddress::setPagerNumber(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcTelecomAddress::hasElectronicMailAddresses() const { return !data_->getArgument(6)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcTelecomAddress::ElectronicMailAddresses() const { return *data_->getArgument(6); }
void IfcTelecomAddress::setElectronicMailAddresses(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcTelecomAddress::hasWWWHomePageURL() const { return !data_->getArgument(7)->isNull(); }
std::string IfcTelecomAddress::WWWHomePageURL() const { return *data_->getArgument(7); }
void IfcTelecomAddress::setWWWHomePageURL(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcTelecomAddress::hasMessagingIDs() const { return !data_->getArgument(8)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcTelecomAddress::MessagingIDs() const { return *data_->getArgument(8); }
void IfcTelecomAddress::setMessagingIDs(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcTelecomAddress::declaration() const { return *IfcTelecomAddress_type; }
const IfcParse::entity& IfcTelecomAddress::Class() { return *IfcTelecomAddress_type; }
IfcTelecomAddress::IfcTelecomAddress(IfcEntityInstanceData* e) : IfcAddress((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTelecomAddress_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTelecomAddress::IfcTelecomAddress(boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_TelephoneNumbers, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_FacsimileNumbers, boost::optional< std::string > v6_PagerNumber, boost::optional< std::vector< std::string > /*[1:?]*/ > v7_ElectronicMailAddresses, boost::optional< std::string > v8_WWWHomePageURL, boost::optional< std::vector< std::string > /*[1:?]*/ > v9_MessagingIDs) : IfcAddress((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTelecomAddress_type);  if (v1_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v1_Purpose,IfcAddressTypeEnum::ToString(*v1_Purpose))));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedPurpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedPurpose));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_TelephoneNumbers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_TelephoneNumbers));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_FacsimileNumbers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_FacsimileNumbers));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_PagerNumber) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_PagerNumber));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ElectronicMailAddresses) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ElectronicMailAddresses));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_WWWHomePageURL) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WWWHomePageURL));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_MessagingIDs) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_MessagingIDs));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcTendon
bool IfcTendon::hasPredefinedType() const { return !data_->getArgument(9)->isNull(); }
IfcTendonTypeEnum::IfcTendonTypeEnum IfcTendon::PredefinedType() const { return IfcTendonTypeEnum::FromString(*data_->getArgument(9)); }
void IfcTendon::setPredefinedType(IfcTendonTypeEnum::IfcTendonTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTendonTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcTendon::hasNominalDiameter() const { return !data_->getArgument(10)->isNull(); }
double IfcTendon::NominalDiameter() const { return *data_->getArgument(10); }
void IfcTendon::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcTendon::hasCrossSectionArea() const { return !data_->getArgument(11)->isNull(); }
double IfcTendon::CrossSectionArea() const { return *data_->getArgument(11); }
void IfcTendon::setCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcTendon::hasTensionForce() const { return !data_->getArgument(12)->isNull(); }
double IfcTendon::TensionForce() const { return *data_->getArgument(12); }
void IfcTendon::setTensionForce(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcTendon::hasPreStress() const { return !data_->getArgument(13)->isNull(); }
double IfcTendon::PreStress() const { return *data_->getArgument(13); }
void IfcTendon::setPreStress(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
bool IfcTendon::hasFrictionCoefficient() const { return !data_->getArgument(14)->isNull(); }
double IfcTendon::FrictionCoefficient() const { return *data_->getArgument(14); }
void IfcTendon::setFrictionCoefficient(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
bool IfcTendon::hasAnchorageSlip() const { return !data_->getArgument(15)->isNull(); }
double IfcTendon::AnchorageSlip() const { return *data_->getArgument(15); }
void IfcTendon::setAnchorageSlip(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }
bool IfcTendon::hasMinCurvatureRadius() const { return !data_->getArgument(16)->isNull(); }
double IfcTendon::MinCurvatureRadius() const { return *data_->getArgument(16); }
void IfcTendon::setMinCurvatureRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(16,attr);} }


const IfcParse::entity& IfcTendon::declaration() const { return *IfcTendon_type; }
const IfcParse::entity& IfcTendon::Class() { return *IfcTendon_type; }
IfcTendon::IfcTendon(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTendon_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTendon::IfcTendon(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< IfcTendonTypeEnum::IfcTendonTypeEnum > v10_PredefinedType, boost::optional< double > v11_NominalDiameter, boost::optional< double > v12_CrossSectionArea, boost::optional< double > v13_TensionForce, boost::optional< double > v14_PreStress, boost::optional< double > v15_FrictionCoefficient, boost::optional< double > v16_AnchorageSlip, boost::optional< double > v17_MinCurvatureRadius) : IfcReinforcingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTendon_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v10_PredefinedType,IfcTendonTypeEnum::ToString(*v10_PredefinedType))));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_NominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_NominalDiameter));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_CrossSectionArea));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_TensionForce) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_TensionForce));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_PreStress) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_PreStress));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_FrictionCoefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_FrictionCoefficient));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_AnchorageSlip) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_AnchorageSlip));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_MinCurvatureRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_MinCurvatureRadius));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } }

// Function implementations for IfcTendonAnchor
bool IfcTendonAnchor::hasPredefinedType() const { return !data_->getArgument(9)->isNull(); }
IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum IfcTendonAnchor::PredefinedType() const { return IfcTendonAnchorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcTendonAnchor::setPredefinedType(IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTendonAnchorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcTendonAnchor::declaration() const { return *IfcTendonAnchor_type; }
const IfcParse::entity& IfcTendonAnchor::Class() { return *IfcTendonAnchor_type; }
IfcTendonAnchor::IfcTendonAnchor(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTendonAnchor_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTendonAnchor::IfcTendonAnchor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum > v10_PredefinedType) : IfcReinforcingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTendonAnchor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v10_PredefinedType,IfcTendonAnchorTypeEnum::ToString(*v10_PredefinedType))));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcTendonAnchorType
IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum IfcTendonAnchorType::PredefinedType() const { return IfcTendonAnchorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcTendonAnchorType::setPredefinedType(IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTendonAnchorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcTendonAnchorType::declaration() const { return *IfcTendonAnchorType_type; }
const IfcParse::entity& IfcTendonAnchorType::Class() { return *IfcTendonAnchorType_type; }
IfcTendonAnchorType::IfcTendonAnchorType(IfcEntityInstanceData* e) : IfcReinforcingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTendonAnchorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTendonAnchorType::IfcTendonAnchorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum v10_PredefinedType) : IfcReinforcingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTendonAnchorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTendonAnchorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcTendonType
IfcTendonTypeEnum::IfcTendonTypeEnum IfcTendonType::PredefinedType() const { return IfcTendonTypeEnum::FromString(*data_->getArgument(9)); }
void IfcTendonType::setPredefinedType(IfcTendonTypeEnum::IfcTendonTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTendonTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcTendonType::hasNominalDiameter() const { return !data_->getArgument(10)->isNull(); }
double IfcTendonType::NominalDiameter() const { return *data_->getArgument(10); }
void IfcTendonType::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcTendonType::hasCrossSectionArea() const { return !data_->getArgument(11)->isNull(); }
double IfcTendonType::CrossSectionArea() const { return *data_->getArgument(11); }
void IfcTendonType::setCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcTendonType::hasSheethDiameter() const { return !data_->getArgument(12)->isNull(); }
double IfcTendonType::SheethDiameter() const { return *data_->getArgument(12); }
void IfcTendonType::setSheethDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& IfcTendonType::declaration() const { return *IfcTendonType_type; }
const IfcParse::entity& IfcTendonType::Class() { return *IfcTendonType_type; }
IfcTendonType::IfcTendonType(IfcEntityInstanceData* e) : IfcReinforcingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTendonType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTendonType::IfcTendonType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTendonTypeEnum::IfcTendonTypeEnum v10_PredefinedType, boost::optional< double > v11_NominalDiameter, boost::optional< double > v12_CrossSectionArea, boost::optional< double > v13_SheethDiameter) : IfcReinforcingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTendonType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTendonTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} if (v11_NominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_NominalDiameter));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_CrossSectionArea));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_SheethDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_SheethDiameter));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcTessellatedFaceSet
IfcCartesianPointList3D* IfcTessellatedFaceSet::Coordinates() const { return (IfcCartesianPointList3D*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcTessellatedFaceSet::setCoordinates(IfcCartesianPointList3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcTessellatedFaceSet::hasNormals() const { return !data_->getArgument(1)->isNull(); }
std::vector< std::vector< double > > IfcTessellatedFaceSet::Normals() const { return *data_->getArgument(1); }
void IfcTessellatedFaceSet::setNormals(std::vector< std::vector< double > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcTessellatedFaceSet::hasClosed() const { return !data_->getArgument(2)->isNull(); }
bool IfcTessellatedFaceSet::Closed() const { return *data_->getArgument(2); }
void IfcTessellatedFaceSet::setClosed(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

IfcIndexedColourMap::list::ptr IfcTessellatedFaceSet::HasColours() const { return data_->getInverse(IfcIndexedColourMap_type, 0)->as<IfcIndexedColourMap>(); }
IfcIndexedTextureMap::list::ptr IfcTessellatedFaceSet::HasTextures() const { return data_->getInverse(IfcIndexedTextureMap_type, 1)->as<IfcIndexedTextureMap>(); }

const IfcParse::entity& IfcTessellatedFaceSet::declaration() const { return *IfcTessellatedFaceSet_type; }
const IfcParse::entity& IfcTessellatedFaceSet::Class() { return *IfcTessellatedFaceSet_type; }
IfcTessellatedFaceSet::IfcTessellatedFaceSet(IfcEntityInstanceData* e) : IfcTessellatedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTessellatedFaceSet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTessellatedFaceSet::IfcTessellatedFaceSet(IfcCartesianPointList3D* v1_Coordinates, boost::optional< std::vector< std::vector< double > > > v2_Normals, boost::optional< bool > v3_Closed) : IfcTessellatedItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTessellatedFaceSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Coordinates));data_->setArgument(0,attr);} if (v2_Normals) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Normals));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Closed) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Closed));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcTessellatedItem


const IfcParse::entity& IfcTessellatedItem::declaration() const { return *IfcTessellatedItem_type; }
const IfcParse::entity& IfcTessellatedItem::Class() { return *IfcTessellatedItem_type; }
IfcTessellatedItem::IfcTessellatedItem(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTessellatedItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTessellatedItem::IfcTessellatedItem() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTessellatedItem_type);  }

// Function implementations for IfcTextLiteral
std::string IfcTextLiteral::Literal() const { return *data_->getArgument(0); }
void IfcTextLiteral::setLiteral(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcAxis2Placement* IfcTextLiteral::Placement() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcTextLiteral::setPlacement(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcTextPath::IfcTextPath IfcTextLiteral::Path() const { return IfcTextPath::FromString(*data_->getArgument(2)); }
void IfcTextLiteral::setPath(IfcTextPath::IfcTextPath v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTextPath::ToString(v)));data_->setArgument(2,attr);} }


const IfcParse::entity& IfcTextLiteral::declaration() const { return *IfcTextLiteral_type; }
const IfcParse::entity& IfcTextLiteral::Class() { return *IfcTextLiteral_type; }
IfcTextLiteral::IfcTextLiteral(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextLiteral_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextLiteral::IfcTextLiteral(std::string v1_Literal, IfcAxis2Placement* v2_Placement, IfcTextPath::IfcTextPath v3_Path) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextLiteral_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Literal));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Placement));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_Path,IfcTextPath::ToString(v3_Path))));data_->setArgument(2,attr);} }

// Function implementations for IfcTextLiteralWithExtent
IfcPlanarExtent* IfcTextLiteralWithExtent::Extent() const { return (IfcPlanarExtent*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcTextLiteralWithExtent::setExtent(IfcPlanarExtent* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
std::string IfcTextLiteralWithExtent::BoxAlignment() const { return *data_->getArgument(4); }
void IfcTextLiteralWithExtent::setBoxAlignment(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcTextLiteralWithExtent::declaration() const { return *IfcTextLiteralWithExtent_type; }
const IfcParse::entity& IfcTextLiteralWithExtent::Class() { return *IfcTextLiteralWithExtent_type; }
IfcTextLiteralWithExtent::IfcTextLiteralWithExtent(IfcEntityInstanceData* e) : IfcTextLiteral((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextLiteralWithExtent_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextLiteralWithExtent::IfcTextLiteralWithExtent(std::string v1_Literal, IfcAxis2Placement* v2_Placement, IfcTextPath::IfcTextPath v3_Path, IfcPlanarExtent* v4_Extent, std::string v5_BoxAlignment) : IfcTextLiteral((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextLiteralWithExtent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Literal));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Placement));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_Path,IfcTextPath::ToString(v3_Path))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Extent));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_BoxAlignment));data_->setArgument(4,attr);} }

// Function implementations for IfcTextStyle
bool IfcTextStyle::hasTextCharacterAppearance() const { return !data_->getArgument(1)->isNull(); }
IfcTextStyleForDefinedFont* IfcTextStyle::TextCharacterAppearance() const { return (IfcTextStyleForDefinedFont*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcTextStyle::setTextCharacterAppearance(IfcTextStyleForDefinedFont* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcTextStyle::hasTextStyle() const { return !data_->getArgument(2)->isNull(); }
IfcTextStyleTextModel* IfcTextStyle::TextStyle() const { return (IfcTextStyleTextModel*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcTextStyle::setTextStyle(IfcTextStyleTextModel* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
IfcTextFontSelect* IfcTextStyle::TextFontStyle() const { return (IfcTextFontSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcTextStyle::setTextFontStyle(IfcTextFontSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcTextStyle::hasModelOrDraughting() const { return !data_->getArgument(4)->isNull(); }
bool IfcTextStyle::ModelOrDraughting() const { return *data_->getArgument(4); }
void IfcTextStyle::setModelOrDraughting(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcTextStyle::declaration() const { return *IfcTextStyle_type; }
const IfcParse::entity& IfcTextStyle::Class() { return *IfcTextStyle_type; }
IfcTextStyle::IfcTextStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextStyle::IfcTextStyle(boost::optional< std::string > v1_Name, IfcTextStyleForDefinedFont* v2_TextCharacterAppearance, IfcTextStyleTextModel* v3_TextStyle, IfcTextFontSelect* v4_TextFontStyle, boost::optional< bool > v5_ModelOrDraughting) : IfcPresentationStyle((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TextCharacterAppearance));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TextStyle));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextFontStyle));data_->setArgument(3,attr);} if (v5_ModelOrDraughting) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ModelOrDraughting));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcTextStyleFontModel
std::vector< std::string > /*[1:?]*/ IfcTextStyleFontModel::FontFamily() const { return *data_->getArgument(1); }
void IfcTextStyleFontModel::setFontFamily(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcTextStyleFontModel::hasFontStyle() const { return !data_->getArgument(2)->isNull(); }
std::string IfcTextStyleFontModel::FontStyle() const { return *data_->getArgument(2); }
void IfcTextStyleFontModel::setFontStyle(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcTextStyleFontModel::hasFontVariant() const { return !data_->getArgument(3)->isNull(); }
std::string IfcTextStyleFontModel::FontVariant() const { return *data_->getArgument(3); }
void IfcTextStyleFontModel::setFontVariant(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcTextStyleFontModel::hasFontWeight() const { return !data_->getArgument(4)->isNull(); }
std::string IfcTextStyleFontModel::FontWeight() const { return *data_->getArgument(4); }
void IfcTextStyleFontModel::setFontWeight(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
IfcSizeSelect* IfcTextStyleFontModel::FontSize() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(5))); }
void IfcTextStyleFontModel::setFontSize(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcTextStyleFontModel::declaration() const { return *IfcTextStyleFontModel_type; }
const IfcParse::entity& IfcTextStyleFontModel::Class() { return *IfcTextStyleFontModel_type; }
IfcTextStyleFontModel::IfcTextStyleFontModel(IfcEntityInstanceData* e) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextStyleFontModel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextStyleFontModel::IfcTextStyleFontModel(std::string v1_Name, std::vector< std::string > /*[1:?]*/ v2_FontFamily, boost::optional< std::string > v3_FontStyle, boost::optional< std::string > v4_FontVariant, boost::optional< std::string > v5_FontWeight, IfcSizeSelect* v6_FontSize) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextStyleFontModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FontFamily));data_->setArgument(1,attr);} if (v3_FontStyle) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_FontStyle));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_FontVariant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_FontVariant));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_FontWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_FontWeight));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FontSize));data_->setArgument(5,attr);} }

// Function implementations for IfcTextStyleForDefinedFont
IfcColour* IfcTextStyleForDefinedFont::Colour() const { return (IfcColour*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcTextStyleForDefinedFont::setColour(IfcColour* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcTextStyleForDefinedFont::hasBackgroundColour() const { return !data_->getArgument(1)->isNull(); }
IfcColour* IfcTextStyleForDefinedFont::BackgroundColour() const { return (IfcColour*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(1))); }
void IfcTextStyleForDefinedFont::setBackgroundColour(IfcColour* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcTextStyleForDefinedFont::declaration() const { return *IfcTextStyleForDefinedFont_type; }
const IfcParse::entity& IfcTextStyleForDefinedFont::Class() { return *IfcTextStyleForDefinedFont_type; }
IfcTextStyleForDefinedFont::IfcTextStyleForDefinedFont(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextStyleForDefinedFont_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextStyleForDefinedFont::IfcTextStyleForDefinedFont(IfcColour* v1_Colour, IfcColour* v2_BackgroundColour) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextStyleForDefinedFont_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Colour));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_BackgroundColour));data_->setArgument(1,attr);} }

// Function implementations for IfcTextStyleTextModel
bool IfcTextStyleTextModel::hasTextIndent() const { return !data_->getArgument(0)->isNull(); }
IfcSizeSelect* IfcTextStyleTextModel::TextIndent() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcTextStyleTextModel::setTextIndent(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcTextStyleTextModel::hasTextAlign() const { return !data_->getArgument(1)->isNull(); }
std::string IfcTextStyleTextModel::TextAlign() const { return *data_->getArgument(1); }
void IfcTextStyleTextModel::setTextAlign(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcTextStyleTextModel::hasTextDecoration() const { return !data_->getArgument(2)->isNull(); }
std::string IfcTextStyleTextModel::TextDecoration() const { return *data_->getArgument(2); }
void IfcTextStyleTextModel::setTextDecoration(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcTextStyleTextModel::hasLetterSpacing() const { return !data_->getArgument(3)->isNull(); }
IfcSizeSelect* IfcTextStyleTextModel::LetterSpacing() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcTextStyleTextModel::setLetterSpacing(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcTextStyleTextModel::hasWordSpacing() const { return !data_->getArgument(4)->isNull(); }
IfcSizeSelect* IfcTextStyleTextModel::WordSpacing() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(4))); }
void IfcTextStyleTextModel::setWordSpacing(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcTextStyleTextModel::hasTextTransform() const { return !data_->getArgument(5)->isNull(); }
std::string IfcTextStyleTextModel::TextTransform() const { return *data_->getArgument(5); }
void IfcTextStyleTextModel::setTextTransform(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcTextStyleTextModel::hasLineHeight() const { return !data_->getArgument(6)->isNull(); }
IfcSizeSelect* IfcTextStyleTextModel::LineHeight() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(6))); }
void IfcTextStyleTextModel::setLineHeight(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcTextStyleTextModel::declaration() const { return *IfcTextStyleTextModel_type; }
const IfcParse::entity& IfcTextStyleTextModel::Class() { return *IfcTextStyleTextModel_type; }
IfcTextStyleTextModel::IfcTextStyleTextModel(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextStyleTextModel_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextStyleTextModel::IfcTextStyleTextModel(IfcSizeSelect* v1_TextIndent, boost::optional< std::string > v2_TextAlign, boost::optional< std::string > v3_TextDecoration, IfcSizeSelect* v4_LetterSpacing, IfcSizeSelect* v5_WordSpacing, boost::optional< std::string > v6_TextTransform, IfcSizeSelect* v7_LineHeight) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextStyleTextModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TextIndent));data_->setArgument(0,attr);} if (v2_TextAlign) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_TextAlign));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_TextDecoration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_TextDecoration));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LetterSpacing));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_WordSpacing));data_->setArgument(4,attr);} if (v6_TextTransform) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_TextTransform));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LineHeight));data_->setArgument(6,attr);} }

// Function implementations for IfcTextureCoordinate
IfcTemplatedEntityList< IfcSurfaceTexture >::ptr IfcTextureCoordinate::Maps() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcSurfaceTexture>(); }
void IfcTextureCoordinate::setMaps(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& IfcTextureCoordinate::declaration() const { return *IfcTextureCoordinate_type; }
const IfcParse::entity& IfcTextureCoordinate::Class() { return *IfcTextureCoordinate_type; }
IfcTextureCoordinate::IfcTextureCoordinate(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextureCoordinate_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextureCoordinate::IfcTextureCoordinate(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextureCoordinate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Maps)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcTextureCoordinateGenerator
std::string IfcTextureCoordinateGenerator::Mode() const { return *data_->getArgument(1); }
void IfcTextureCoordinateGenerator::setMode(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool IfcTextureCoordinateGenerator::hasParameter() const { return !data_->getArgument(2)->isNull(); }
std::vector< double > /*[1:?]*/ IfcTextureCoordinateGenerator::Parameter() const { return *data_->getArgument(2); }
void IfcTextureCoordinateGenerator::setParameter(std::vector< double > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcTextureCoordinateGenerator::declaration() const { return *IfcTextureCoordinateGenerator_type; }
const IfcParse::entity& IfcTextureCoordinateGenerator::Class() { return *IfcTextureCoordinateGenerator_type; }
IfcTextureCoordinateGenerator::IfcTextureCoordinateGenerator(IfcEntityInstanceData* e) : IfcTextureCoordinate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextureCoordinateGenerator_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextureCoordinateGenerator::IfcTextureCoordinateGenerator(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps, std::string v2_Mode, boost::optional< std::vector< double > /*[1:?]*/ > v3_Parameter) : IfcTextureCoordinate((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextureCoordinateGenerator_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Maps)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Mode));data_->setArgument(1,attr);} if (v3_Parameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Parameter));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcTextureMap
IfcTemplatedEntityList< IfcTextureVertex >::ptr IfcTextureMap::Vertices() const { IfcEntityList::ptr es = *data_->getArgument(1); return es->as<IfcTextureVertex>(); }
void IfcTextureMap::setVertices(IfcTemplatedEntityList< IfcTextureVertex >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(1,attr);} }
IfcFace* IfcTextureMap::MappedTo() const { return (IfcFace*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(2))); }
void IfcTextureMap::setMappedTo(IfcFace* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& IfcTextureMap::declaration() const { return *IfcTextureMap_type; }
const IfcParse::entity& IfcTextureMap::Class() { return *IfcTextureMap_type; }
IfcTextureMap::IfcTextureMap(IfcEntityInstanceData* e) : IfcTextureCoordinate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextureMap_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextureMap::IfcTextureMap(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps, IfcTemplatedEntityList< IfcTextureVertex >::ptr v2_Vertices, IfcFace* v3_MappedTo) : IfcTextureCoordinate((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextureMap_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Maps)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Vertices)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_MappedTo));data_->setArgument(2,attr);} }

// Function implementations for IfcTextureVertex
std::vector< double > /*[2:2]*/ IfcTextureVertex::Coordinates() const { return *data_->getArgument(0); }
void IfcTextureVertex::setCoordinates(std::vector< double > /*[2:2]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcTextureVertex::declaration() const { return *IfcTextureVertex_type; }
const IfcParse::entity& IfcTextureVertex::Class() { return *IfcTextureVertex_type; }
IfcTextureVertex::IfcTextureVertex(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextureVertex_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextureVertex::IfcTextureVertex(std::vector< double > /*[2:2]*/ v1_Coordinates) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextureVertex_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Coordinates));data_->setArgument(0,attr);} }

// Function implementations for IfcTextureVertexList
std::vector< std::vector< double > > IfcTextureVertexList::TexCoordsList() const { return *data_->getArgument(0); }
void IfcTextureVertexList::setTexCoordsList(std::vector< std::vector< double > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcTextureVertexList::declaration() const { return *IfcTextureVertexList_type; }
const IfcParse::entity& IfcTextureVertexList::Class() { return *IfcTextureVertexList_type; }
IfcTextureVertexList::IfcTextureVertexList(IfcEntityInstanceData* e) : IfcPresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTextureVertexList_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTextureVertexList::IfcTextureVertexList(std::vector< std::vector< double > > v1_TexCoordsList) : IfcPresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTextureVertexList_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TexCoordsList));data_->setArgument(0,attr);} }

// Function implementations for IfcTimePeriod
std::string IfcTimePeriod::StartTime() const { return *data_->getArgument(0); }
void IfcTimePeriod::setStartTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::string IfcTimePeriod::EndTime() const { return *data_->getArgument(1); }
void IfcTimePeriod::setEndTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcTimePeriod::declaration() const { return *IfcTimePeriod_type; }
const IfcParse::entity& IfcTimePeriod::Class() { return *IfcTimePeriod_type; }
IfcTimePeriod::IfcTimePeriod(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcTimePeriod_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTimePeriod::IfcTimePeriod(std::string v1_StartTime, std::string v2_EndTime) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcTimePeriod_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_StartTime));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EndTime));data_->setArgument(1,attr);} }

// Function implementations for IfcTimeSeries
std::string IfcTimeSeries::Name() const { return *data_->getArgument(0); }
void IfcTimeSeries::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool IfcTimeSeries::hasDescription() const { return !data_->getArgument(1)->isNull(); }
std::string IfcTimeSeries::Description() const { return *data_->getArgument(1); }
void IfcTimeSeries::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
std::string IfcTimeSeries::StartTime() const { return *data_->getArgument(2); }
void IfcTimeSeries::setStartTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
std::string IfcTimeSeries::EndTime() const { return *data_->getArgument(3); }
void IfcTimeSeries::setEndTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum IfcTimeSeries::TimeSeriesDataType() const { return IfcTimeSeriesDataTypeEnum::FromString(*data_->getArgument(4)); }
void IfcTimeSeries::setTimeSeriesDataType(IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTimeSeriesDataTypeEnum::ToString(v)));data_->setArgument(4,attr);} }
IfcDataOriginEnum::IfcDataOriginEnum IfcTimeSeries::DataOrigin() const { return IfcDataOriginEnum::FromString(*data_->getArgument(5)); }
void IfcTimeSeries::setDataOrigin(IfcDataOriginEnum::IfcDataOriginEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDataOriginEnum::ToString(v)));data_->setArgument(5,attr);} }
bool IfcTimeSeries::hasUserDefinedDataOrigin() const { return !data_->getArgument(6)->isNull(); }
std::string IfcTimeSeries::UserDefinedDataOrigin() const { return *data_->getArgument(6); }
void IfcTimeSeries::setUserDefinedDataOrigin(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcTimeSeries::hasUnit() const { return !data_->getArgument(7)->isNull(); }
IfcUnit* IfcTimeSeries::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(7))); }
void IfcTimeSeries::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }

IfcExternalReferenceRelationship::list::ptr IfcTimeSeries::HasExternalReference() const { return data_->getInverse(IfcExternalReferenceRelationship_type, 3)->as<IfcExternalReferenceRelationship>(); }

const IfcParse::entity& IfcTimeSeries::declaration() const { return *IfcTimeSeries_type; }
const IfcParse::entity& IfcTimeSeries::Class() { return *IfcTimeSeries_type; }
IfcTimeSeries::IfcTimeSeries(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcTimeSeries_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTimeSeries::IfcTimeSeries(std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_StartTime, std::string v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcTimeSeries_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_StartTime));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EndTime));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_TimeSeriesDataType,IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_DataOrigin,IfcDataOriginEnum::ToString(v6_DataOrigin))));data_->setArgument(5,attr);} if (v7_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedDataOrigin));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Unit));data_->setArgument(7,attr);} }

// Function implementations for IfcTimeSeriesValue
IfcEntityList::ptr IfcTimeSeriesValue::ListValues() const { return *data_->getArgument(0); }
void IfcTimeSeriesValue::setListValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcTimeSeriesValue::declaration() const { return *IfcTimeSeriesValue_type; }
const IfcParse::entity& IfcTimeSeriesValue::Class() { return *IfcTimeSeriesValue_type; }
IfcTimeSeriesValue::IfcTimeSeriesValue(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcTimeSeriesValue_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTimeSeriesValue::IfcTimeSeriesValue(IfcEntityList::ptr v1_ListValues) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcTimeSeriesValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ListValues));data_->setArgument(0,attr);} }

// Function implementations for IfcTopologicalRepresentationItem


const IfcParse::entity& IfcTopologicalRepresentationItem::declaration() const { return *IfcTopologicalRepresentationItem_type; }
const IfcParse::entity& IfcTopologicalRepresentationItem::Class() { return *IfcTopologicalRepresentationItem_type; }
IfcTopologicalRepresentationItem::IfcTopologicalRepresentationItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTopologicalRepresentationItem_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTopologicalRepresentationItem::IfcTopologicalRepresentationItem() : IfcRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTopologicalRepresentationItem_type);  }

// Function implementations for IfcTopologyRepresentation


const IfcParse::entity& IfcTopologyRepresentation::declaration() const { return *IfcTopologyRepresentation_type; }
const IfcParse::entity& IfcTopologyRepresentation::Class() { return *IfcTopologyRepresentation_type; }
IfcTopologyRepresentation::IfcTopologyRepresentation(IfcEntityInstanceData* e) : IfcShapeModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTopologyRepresentation_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTopologyRepresentation::IfcTopologyRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcShapeModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTopologyRepresentation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcTransformer
bool IfcTransformer::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcTransformerTypeEnum::IfcTransformerTypeEnum IfcTransformer::PredefinedType() const { return IfcTransformerTypeEnum::FromString(*data_->getArgument(8)); }
void IfcTransformer::setPredefinedType(IfcTransformerTypeEnum::IfcTransformerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTransformerTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcTransformer::declaration() const { return *IfcTransformer_type; }
const IfcParse::entity& IfcTransformer::Class() { return *IfcTransformer_type; }
IfcTransformer::IfcTransformer(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTransformer_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTransformer::IfcTransformer(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTransformerTypeEnum::IfcTransformerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTransformer_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcTransformerTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcTransformerType
IfcTransformerTypeEnum::IfcTransformerTypeEnum IfcTransformerType::PredefinedType() const { return IfcTransformerTypeEnum::FromString(*data_->getArgument(9)); }
void IfcTransformerType::setPredefinedType(IfcTransformerTypeEnum::IfcTransformerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTransformerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcTransformerType::declaration() const { return *IfcTransformerType_type; }
const IfcParse::entity& IfcTransformerType::Class() { return *IfcTransformerType_type; }
IfcTransformerType::IfcTransformerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTransformerType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTransformerType::IfcTransformerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTransformerTypeEnum::IfcTransformerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTransformerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTransformerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcTransportElement
bool IfcTransportElement::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcTransportElementTypeEnum::IfcTransportElementTypeEnum IfcTransportElement::PredefinedType() const { return IfcTransportElementTypeEnum::FromString(*data_->getArgument(8)); }
void IfcTransportElement::setPredefinedType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTransportElementTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcTransportElement::declaration() const { return *IfcTransportElement_type; }
const IfcParse::entity& IfcTransportElement::Class() { return *IfcTransportElement_type; }
IfcTransportElement::IfcTransportElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTransportElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTransportElement::IfcTransportElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTransportElementTypeEnum::IfcTransportElementTypeEnum > v9_PredefinedType) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTransportElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcTransportElementTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcTransportElementType
IfcTransportElementTypeEnum::IfcTransportElementTypeEnum IfcTransportElementType::PredefinedType() const { return IfcTransportElementTypeEnum::FromString(*data_->getArgument(9)); }
void IfcTransportElementType::setPredefinedType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTransportElementTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcTransportElementType::declaration() const { return *IfcTransportElementType_type; }
const IfcParse::entity& IfcTransportElementType::Class() { return *IfcTransportElementType_type; }
IfcTransportElementType::IfcTransportElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTransportElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTransportElementType::IfcTransportElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v10_PredefinedType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTransportElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTransportElementTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcTrapeziumProfileDef
double IfcTrapeziumProfileDef::BottomXDim() const { return *data_->getArgument(3); }
void IfcTrapeziumProfileDef::setBottomXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcTrapeziumProfileDef::TopXDim() const { return *data_->getArgument(4); }
void IfcTrapeziumProfileDef::setTopXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double IfcTrapeziumProfileDef::YDim() const { return *data_->getArgument(5); }
void IfcTrapeziumProfileDef::setYDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double IfcTrapeziumProfileDef::TopXOffset() const { return *data_->getArgument(6); }
void IfcTrapeziumProfileDef::setTopXOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& IfcTrapeziumProfileDef::declaration() const { return *IfcTrapeziumProfileDef_type; }
const IfcParse::entity& IfcTrapeziumProfileDef::Class() { return *IfcTrapeziumProfileDef_type; }
IfcTrapeziumProfileDef::IfcTrapeziumProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTrapeziumProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTrapeziumProfileDef::IfcTrapeziumProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_BottomXDim, double v5_TopXDim, double v6_YDim, double v7_TopXOffset) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTrapeziumProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_BottomXDim));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_TopXDim));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_YDim));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_TopXOffset));data_->setArgument(6,attr);} }

// Function implementations for IfcTriangulatedFaceSet
std::vector< std::vector< int > > IfcTriangulatedFaceSet::CoordIndex() const { return *data_->getArgument(3); }
void IfcTriangulatedFaceSet::setCoordIndex(std::vector< std::vector< int > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcTriangulatedFaceSet::hasNormalIndex() const { return !data_->getArgument(4)->isNull(); }
std::vector< std::vector< int > > IfcTriangulatedFaceSet::NormalIndex() const { return *data_->getArgument(4); }
void IfcTriangulatedFaceSet::setNormalIndex(std::vector< std::vector< int > > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& IfcTriangulatedFaceSet::declaration() const { return *IfcTriangulatedFaceSet_type; }
const IfcParse::entity& IfcTriangulatedFaceSet::Class() { return *IfcTriangulatedFaceSet_type; }
IfcTriangulatedFaceSet::IfcTriangulatedFaceSet(IfcEntityInstanceData* e) : IfcTessellatedFaceSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTriangulatedFaceSet_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTriangulatedFaceSet::IfcTriangulatedFaceSet(IfcCartesianPointList3D* v1_Coordinates, boost::optional< std::vector< std::vector< double > > > v2_Normals, boost::optional< bool > v3_Closed, std::vector< std::vector< int > > v4_CoordIndex, boost::optional< std::vector< std::vector< int > > > v5_NormalIndex) : IfcTessellatedFaceSet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTriangulatedFaceSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Coordinates));data_->setArgument(0,attr);} if (v2_Normals) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Normals));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Closed) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Closed));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_CoordIndex));data_->setArgument(3,attr);} if (v5_NormalIndex) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_NormalIndex));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcTrimmedCurve
IfcCurve* IfcTrimmedCurve::BasisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcTrimmedCurve::setBasisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
IfcEntityList::ptr IfcTrimmedCurve::Trim1() const { return *data_->getArgument(1); }
void IfcTrimmedCurve::setTrim1(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
IfcEntityList::ptr IfcTrimmedCurve::Trim2() const { return *data_->getArgument(2); }
void IfcTrimmedCurve::setTrim2(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool IfcTrimmedCurve::SenseAgreement() const { return *data_->getArgument(3); }
void IfcTrimmedCurve::setSenseAgreement(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
IfcTrimmingPreference::IfcTrimmingPreference IfcTrimmedCurve::MasterRepresentation() const { return IfcTrimmingPreference::FromString(*data_->getArgument(4)); }
void IfcTrimmedCurve::setMasterRepresentation(IfcTrimmingPreference::IfcTrimmingPreference v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTrimmingPreference::ToString(v)));data_->setArgument(4,attr);} }


const IfcParse::entity& IfcTrimmedCurve::declaration() const { return *IfcTrimmedCurve_type; }
const IfcParse::entity& IfcTrimmedCurve::Class() { return *IfcTrimmedCurve_type; }
IfcTrimmedCurve::IfcTrimmedCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTrimmedCurve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTrimmedCurve::IfcTrimmedCurve(IfcCurve* v1_BasisCurve, IfcEntityList::ptr v2_Trim1, IfcEntityList::ptr v3_Trim2, bool v4_SenseAgreement, IfcTrimmingPreference::IfcTrimmingPreference v5_MasterRepresentation) : IfcBoundedCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTrimmedCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Trim1));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Trim2));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_SenseAgreement));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_MasterRepresentation,IfcTrimmingPreference::ToString(v5_MasterRepresentation))));data_->setArgument(4,attr);} }

// Function implementations for IfcTubeBundle
bool IfcTubeBundle::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum IfcTubeBundle::PredefinedType() const { return IfcTubeBundleTypeEnum::FromString(*data_->getArgument(8)); }
void IfcTubeBundle::setPredefinedType(IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTubeBundleTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcTubeBundle::declaration() const { return *IfcTubeBundle_type; }
const IfcParse::entity& IfcTubeBundle::Class() { return *IfcTubeBundle_type; }
IfcTubeBundle::IfcTubeBundle(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTubeBundle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTubeBundle::IfcTubeBundle(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTubeBundle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcTubeBundleTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcTubeBundleType
IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum IfcTubeBundleType::PredefinedType() const { return IfcTubeBundleTypeEnum::FromString(*data_->getArgument(9)); }
void IfcTubeBundleType::setPredefinedType(IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTubeBundleTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcTubeBundleType::declaration() const { return *IfcTubeBundleType_type; }
const IfcParse::entity& IfcTubeBundleType::Class() { return *IfcTubeBundleType_type; }
IfcTubeBundleType::IfcTubeBundleType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTubeBundleType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTubeBundleType::IfcTubeBundleType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTubeBundleType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTubeBundleTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcTypeObject
bool IfcTypeObject::hasApplicableOccurrence() const { return !data_->getArgument(4)->isNull(); }
std::string IfcTypeObject::ApplicableOccurrence() const { return *data_->getArgument(4); }
void IfcTypeObject::setApplicableOccurrence(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcTypeObject::hasHasPropertySets() const { return !data_->getArgument(5)->isNull(); }
IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr IfcTypeObject::HasPropertySets() const { IfcEntityList::ptr es = *data_->getArgument(5); return es->as<IfcPropertySetDefinition>(); }
void IfcTypeObject::setHasPropertySets(IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(5,attr);} }

IfcRelDefinesByType::list::ptr IfcTypeObject::Types() const { return data_->getInverse(IfcRelDefinesByType_type, 5)->as<IfcRelDefinesByType>(); }

const IfcParse::entity& IfcTypeObject::declaration() const { return *IfcTypeObject_type; }
const IfcParse::entity& IfcTypeObject::Class() { return *IfcTypeObject_type; }
IfcTypeObject::IfcTypeObject(IfcEntityInstanceData* e) : IfcObjectDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTypeObject_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTypeObject::IfcTypeObject(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets) : IfcObjectDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTypeObject_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcTypeProcess
bool IfcTypeProcess::hasIdentification() const { return !data_->getArgument(6)->isNull(); }
std::string IfcTypeProcess::Identification() const { return *data_->getArgument(6); }
void IfcTypeProcess::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcTypeProcess::hasLongDescription() const { return !data_->getArgument(7)->isNull(); }
std::string IfcTypeProcess::LongDescription() const { return *data_->getArgument(7); }
void IfcTypeProcess::setLongDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcTypeProcess::hasProcessType() const { return !data_->getArgument(8)->isNull(); }
std::string IfcTypeProcess::ProcessType() const { return *data_->getArgument(8); }
void IfcTypeProcess::setProcessType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }

IfcRelAssignsToProcess::list::ptr IfcTypeProcess::OperatesOn() const { return data_->getInverse(IfcRelAssignsToProcess_type, 6)->as<IfcRelAssignsToProcess>(); }

const IfcParse::entity& IfcTypeProcess::declaration() const { return *IfcTypeProcess_type; }
const IfcParse::entity& IfcTypeProcess::Class() { return *IfcTypeProcess_type; }
IfcTypeProcess::IfcTypeProcess(IfcEntityInstanceData* e) : IfcTypeObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTypeProcess_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTypeProcess::IfcTypeProcess(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ProcessType) : IfcTypeObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTypeProcess_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ProcessType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ProcessType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcTypeProduct
bool IfcTypeProduct::hasRepresentationMaps() const { return !data_->getArgument(6)->isNull(); }
IfcTemplatedEntityList< IfcRepresentationMap >::ptr IfcTypeProduct::RepresentationMaps() const { IfcEntityList::ptr es = *data_->getArgument(6); return es->as<IfcRepresentationMap>(); }
void IfcTypeProduct::setRepresentationMaps(IfcTemplatedEntityList< IfcRepresentationMap >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(6,attr);} }
bool IfcTypeProduct::hasTag() const { return !data_->getArgument(7)->isNull(); }
std::string IfcTypeProduct::Tag() const { return *data_->getArgument(7); }
void IfcTypeProduct::setTag(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }

IfcRelAssignsToProduct::list::ptr IfcTypeProduct::ReferencedBy() const { return data_->getInverse(IfcRelAssignsToProduct_type, 6)->as<IfcRelAssignsToProduct>(); }

const IfcParse::entity& IfcTypeProduct::declaration() const { return *IfcTypeProduct_type; }
const IfcParse::entity& IfcTypeProduct::Class() { return *IfcTypeProduct_type; }
IfcTypeProduct::IfcTypeProduct(IfcEntityInstanceData* e) : IfcTypeObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTypeProduct_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTypeProduct::IfcTypeProduct(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag) : IfcTypeObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTypeProduct_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcTypeResource
bool IfcTypeResource::hasIdentification() const { return !data_->getArgument(6)->isNull(); }
std::string IfcTypeResource::Identification() const { return *data_->getArgument(6); }
void IfcTypeResource::setIdentification(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcTypeResource::hasLongDescription() const { return !data_->getArgument(7)->isNull(); }
std::string IfcTypeResource::LongDescription() const { return *data_->getArgument(7); }
void IfcTypeResource::setLongDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcTypeResource::hasResourceType() const { return !data_->getArgument(8)->isNull(); }
std::string IfcTypeResource::ResourceType() const { return *data_->getArgument(8); }
void IfcTypeResource::setResourceType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }

IfcRelAssignsToResource::list::ptr IfcTypeResource::ResourceOf() const { return data_->getInverse(IfcRelAssignsToResource_type, 6)->as<IfcRelAssignsToResource>(); }

const IfcParse::entity& IfcTypeResource::declaration() const { return *IfcTypeResource_type; }
const IfcParse::entity& IfcTypeResource::Class() { return *IfcTypeResource_type; }
IfcTypeResource::IfcTypeResource(IfcEntityInstanceData* e) : IfcTypeObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcTypeResource_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcTypeResource::IfcTypeResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType) : IfcTypeObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcTypeResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Identification));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_LongDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ResourceType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ResourceType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcUShapeProfileDef
double IfcUShapeProfileDef::Depth() const { return *data_->getArgument(3); }
void IfcUShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcUShapeProfileDef::FlangeWidth() const { return *data_->getArgument(4); }
void IfcUShapeProfileDef::setFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double IfcUShapeProfileDef::WebThickness() const { return *data_->getArgument(5); }
void IfcUShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double IfcUShapeProfileDef::FlangeThickness() const { return *data_->getArgument(6); }
void IfcUShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcUShapeProfileDef::hasFilletRadius() const { return !data_->getArgument(7)->isNull(); }
double IfcUShapeProfileDef::FilletRadius() const { return *data_->getArgument(7); }
void IfcUShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcUShapeProfileDef::hasEdgeRadius() const { return !data_->getArgument(8)->isNull(); }
double IfcUShapeProfileDef::EdgeRadius() const { return *data_->getArgument(8); }
void IfcUShapeProfileDef::setEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcUShapeProfileDef::hasFlangeSlope() const { return !data_->getArgument(9)->isNull(); }
double IfcUShapeProfileDef::FlangeSlope() const { return *data_->getArgument(9); }
void IfcUShapeProfileDef::setFlangeSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& IfcUShapeProfileDef::declaration() const { return *IfcUShapeProfileDef_type; }
const IfcParse::entity& IfcUShapeProfileDef::Class() { return *IfcUShapeProfileDef_type; }
IfcUShapeProfileDef::IfcUShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcUShapeProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcUShapeProfileDef::IfcUShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius, boost::optional< double > v10_FlangeSlope) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcUShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_FlangeWidth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));data_->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_EdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_EdgeRadius));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_FlangeSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_FlangeSlope));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcUnitAssignment
IfcEntityList::ptr IfcUnitAssignment::Units() const { return *data_->getArgument(0); }
void IfcUnitAssignment::setUnits(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcUnitAssignment::declaration() const { return *IfcUnitAssignment_type; }
const IfcParse::entity& IfcUnitAssignment::Class() { return *IfcUnitAssignment_type; }
IfcUnitAssignment::IfcUnitAssignment(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcUnitAssignment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcUnitAssignment::IfcUnitAssignment(IfcEntityList::ptr v1_Units) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcUnitAssignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Units));data_->setArgument(0,attr);} }

// Function implementations for IfcUnitaryControlElement
bool IfcUnitaryControlElement::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum IfcUnitaryControlElement::PredefinedType() const { return IfcUnitaryControlElementTypeEnum::FromString(*data_->getArgument(8)); }
void IfcUnitaryControlElement::setPredefinedType(IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcUnitaryControlElementTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcUnitaryControlElement::declaration() const { return *IfcUnitaryControlElement_type; }
const IfcParse::entity& IfcUnitaryControlElement::Class() { return *IfcUnitaryControlElement_type; }
IfcUnitaryControlElement::IfcUnitaryControlElement(IfcEntityInstanceData* e) : IfcDistributionControlElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcUnitaryControlElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcUnitaryControlElement::IfcUnitaryControlElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcUnitaryControlElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcUnitaryControlElementTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcUnitaryControlElementType
IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum IfcUnitaryControlElementType::PredefinedType() const { return IfcUnitaryControlElementTypeEnum::FromString(*data_->getArgument(9)); }
void IfcUnitaryControlElementType::setPredefinedType(IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcUnitaryControlElementTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcUnitaryControlElementType::declaration() const { return *IfcUnitaryControlElementType_type; }
const IfcParse::entity& IfcUnitaryControlElementType::Class() { return *IfcUnitaryControlElementType_type; }
IfcUnitaryControlElementType::IfcUnitaryControlElementType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcUnitaryControlElementType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcUnitaryControlElementType::IfcUnitaryControlElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcUnitaryControlElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcUnitaryControlElementTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcUnitaryEquipment
bool IfcUnitaryEquipment::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum IfcUnitaryEquipment::PredefinedType() const { return IfcUnitaryEquipmentTypeEnum::FromString(*data_->getArgument(8)); }
void IfcUnitaryEquipment::setPredefinedType(IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcUnitaryEquipmentTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcUnitaryEquipment::declaration() const { return *IfcUnitaryEquipment_type; }
const IfcParse::entity& IfcUnitaryEquipment::Class() { return *IfcUnitaryEquipment_type; }
IfcUnitaryEquipment::IfcUnitaryEquipment(IfcEntityInstanceData* e) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcUnitaryEquipment_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcUnitaryEquipment::IfcUnitaryEquipment(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcUnitaryEquipment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcUnitaryEquipmentTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcUnitaryEquipmentType
IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum IfcUnitaryEquipmentType::PredefinedType() const { return IfcUnitaryEquipmentTypeEnum::FromString(*data_->getArgument(9)); }
void IfcUnitaryEquipmentType::setPredefinedType(IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcUnitaryEquipmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcUnitaryEquipmentType::declaration() const { return *IfcUnitaryEquipmentType_type; }
const IfcParse::entity& IfcUnitaryEquipmentType::Class() { return *IfcUnitaryEquipmentType_type; }
IfcUnitaryEquipmentType::IfcUnitaryEquipmentType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcUnitaryEquipmentType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcUnitaryEquipmentType::IfcUnitaryEquipmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcUnitaryEquipmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcUnitaryEquipmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcValve
bool IfcValve::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcValveTypeEnum::IfcValveTypeEnum IfcValve::PredefinedType() const { return IfcValveTypeEnum::FromString(*data_->getArgument(8)); }
void IfcValve::setPredefinedType(IfcValveTypeEnum::IfcValveTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcValveTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcValve::declaration() const { return *IfcValve_type; }
const IfcParse::entity& IfcValve::Class() { return *IfcValve_type; }
IfcValve::IfcValve(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcValve_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcValve::IfcValve(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcValveTypeEnum::IfcValveTypeEnum > v9_PredefinedType) : IfcFlowController((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcValve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcValveTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcValveType
IfcValveTypeEnum::IfcValveTypeEnum IfcValveType::PredefinedType() const { return IfcValveTypeEnum::FromString(*data_->getArgument(9)); }
void IfcValveType::setPredefinedType(IfcValveTypeEnum::IfcValveTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcValveTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcValveType::declaration() const { return *IfcValveType_type; }
const IfcParse::entity& IfcValveType::Class() { return *IfcValveType_type; }
IfcValveType::IfcValveType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcValveType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcValveType::IfcValveType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcValveTypeEnum::IfcValveTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcValveType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcValveTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcVector
IfcDirection* IfcVector::Orientation() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcVector::setOrientation(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double IfcVector::Magnitude() const { return *data_->getArgument(1); }
void IfcVector::setMagnitude(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcVector::declaration() const { return *IfcVector_type; }
const IfcParse::entity& IfcVector::Class() { return *IfcVector_type; }
IfcVector::IfcVector(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcVector_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcVector::IfcVector(IfcDirection* v1_Orientation, double v2_Magnitude) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcVector_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Orientation));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Magnitude));data_->setArgument(1,attr);} }

// Function implementations for IfcVertex


const IfcParse::entity& IfcVertex::declaration() const { return *IfcVertex_type; }
const IfcParse::entity& IfcVertex::Class() { return *IfcVertex_type; }
IfcVertex::IfcVertex(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcVertex_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcVertex::IfcVertex() : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcVertex_type);  }

// Function implementations for IfcVertexLoop
IfcVertex* IfcVertexLoop::LoopVertex() const { return (IfcVertex*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcVertexLoop::setLoopVertex(IfcVertex* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcVertexLoop::declaration() const { return *IfcVertexLoop_type; }
const IfcParse::entity& IfcVertexLoop::Class() { return *IfcVertexLoop_type; }
IfcVertexLoop::IfcVertexLoop(IfcEntityInstanceData* e) : IfcLoop((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcVertexLoop_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcVertexLoop::IfcVertexLoop(IfcVertex* v1_LoopVertex) : IfcLoop((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcVertexLoop_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LoopVertex));data_->setArgument(0,attr);} }

// Function implementations for IfcVertexPoint
IfcPoint* IfcVertexPoint::VertexGeometry() const { return (IfcPoint*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(0))); }
void IfcVertexPoint::setVertexGeometry(IfcPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& IfcVertexPoint::declaration() const { return *IfcVertexPoint_type; }
const IfcParse::entity& IfcVertexPoint::Class() { return *IfcVertexPoint_type; }
IfcVertexPoint::IfcVertexPoint(IfcEntityInstanceData* e) : IfcVertex((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcVertexPoint_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcVertexPoint::IfcVertexPoint(IfcPoint* v1_VertexGeometry) : IfcVertex((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcVertexPoint_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_VertexGeometry));data_->setArgument(0,attr);} }

// Function implementations for IfcVibrationIsolator
bool IfcVibrationIsolator::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum IfcVibrationIsolator::PredefinedType() const { return IfcVibrationIsolatorTypeEnum::FromString(*data_->getArgument(8)); }
void IfcVibrationIsolator::setPredefinedType(IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcVibrationIsolatorTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcVibrationIsolator::declaration() const { return *IfcVibrationIsolator_type; }
const IfcParse::entity& IfcVibrationIsolator::Class() { return *IfcVibrationIsolator_type; }
IfcVibrationIsolator::IfcVibrationIsolator(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcVibrationIsolator_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcVibrationIsolator::IfcVibrationIsolator(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum > v9_PredefinedType) : IfcElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcVibrationIsolator_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcVibrationIsolatorTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcVibrationIsolatorType
IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum IfcVibrationIsolatorType::PredefinedType() const { return IfcVibrationIsolatorTypeEnum::FromString(*data_->getArgument(9)); }
void IfcVibrationIsolatorType::setPredefinedType(IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcVibrationIsolatorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcVibrationIsolatorType::declaration() const { return *IfcVibrationIsolatorType_type; }
const IfcParse::entity& IfcVibrationIsolatorType::Class() { return *IfcVibrationIsolatorType_type; }
IfcVibrationIsolatorType::IfcVibrationIsolatorType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcVibrationIsolatorType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcVibrationIsolatorType::IfcVibrationIsolatorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v10_PredefinedType) : IfcElementComponentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcVibrationIsolatorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcVibrationIsolatorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcVirtualElement


const IfcParse::entity& IfcVirtualElement::declaration() const { return *IfcVirtualElement_type; }
const IfcParse::entity& IfcVirtualElement::Class() { return *IfcVirtualElement_type; }
IfcVirtualElement::IfcVirtualElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcVirtualElement_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcVirtualElement::IfcVirtualElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcVirtualElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcVirtualGridIntersection
IfcTemplatedEntityList< IfcGridAxis >::ptr IfcVirtualGridIntersection::IntersectingAxes() const { IfcEntityList::ptr es = *data_->getArgument(0); return es->as<IfcGridAxis>(); }
void IfcVirtualGridIntersection::setIntersectingAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(0,attr);} }
std::vector< double > /*[2:3]*/ IfcVirtualGridIntersection::OffsetDistances() const { return *data_->getArgument(1); }
void IfcVirtualGridIntersection::setOffsetDistances(std::vector< double > /*[2:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& IfcVirtualGridIntersection::declaration() const { return *IfcVirtualGridIntersection_type; }
const IfcParse::entity& IfcVirtualGridIntersection::Class() { return *IfcVirtualGridIntersection_type; }
IfcVirtualGridIntersection::IfcVirtualGridIntersection(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IfcVirtualGridIntersection_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcVirtualGridIntersection::IfcVirtualGridIntersection(IfcTemplatedEntityList< IfcGridAxis >::ptr v1_IntersectingAxes, std::vector< double > /*[2:3]*/ v2_OffsetDistances) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IfcVirtualGridIntersection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_IntersectingAxes)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OffsetDistances));data_->setArgument(1,attr);} }

// Function implementations for IfcVoidingFeature
bool IfcVoidingFeature::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum IfcVoidingFeature::PredefinedType() const { return IfcVoidingFeatureTypeEnum::FromString(*data_->getArgument(8)); }
void IfcVoidingFeature::setPredefinedType(IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcVoidingFeatureTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcVoidingFeature::declaration() const { return *IfcVoidingFeature_type; }
const IfcParse::entity& IfcVoidingFeature::Class() { return *IfcVoidingFeature_type; }
IfcVoidingFeature::IfcVoidingFeature(IfcEntityInstanceData* e) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcVoidingFeature_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcVoidingFeature::IfcVoidingFeature(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum > v9_PredefinedType) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcVoidingFeature_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcVoidingFeatureTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcWall
bool IfcWall::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcWallTypeEnum::IfcWallTypeEnum IfcWall::PredefinedType() const { return IfcWallTypeEnum::FromString(*data_->getArgument(8)); }
void IfcWall::setPredefinedType(IfcWallTypeEnum::IfcWallTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWallTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcWall::declaration() const { return *IfcWall_type; }
const IfcParse::entity& IfcWall::Class() { return *IfcWall_type; }
IfcWall::IfcWall(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWall_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWall::IfcWall(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcWallTypeEnum::IfcWallTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWall_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcWallTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcWallElementedCase


const IfcParse::entity& IfcWallElementedCase::declaration() const { return *IfcWallElementedCase_type; }
const IfcParse::entity& IfcWallElementedCase::Class() { return *IfcWallElementedCase_type; }
IfcWallElementedCase::IfcWallElementedCase(IfcEntityInstanceData* e) : IfcWall((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWallElementedCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWallElementedCase::IfcWallElementedCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcWallTypeEnum::IfcWallTypeEnum > v9_PredefinedType) : IfcWall((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWallElementedCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcWallTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcWallStandardCase


const IfcParse::entity& IfcWallStandardCase::declaration() const { return *IfcWallStandardCase_type; }
const IfcParse::entity& IfcWallStandardCase::Class() { return *IfcWallStandardCase_type; }
IfcWallStandardCase::IfcWallStandardCase(IfcEntityInstanceData* e) : IfcWall((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWallStandardCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWallStandardCase::IfcWallStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcWallTypeEnum::IfcWallTypeEnum > v9_PredefinedType) : IfcWall((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWallStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcWallTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcWallType
IfcWallTypeEnum::IfcWallTypeEnum IfcWallType::PredefinedType() const { return IfcWallTypeEnum::FromString(*data_->getArgument(9)); }
void IfcWallType::setPredefinedType(IfcWallTypeEnum::IfcWallTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWallTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcWallType::declaration() const { return *IfcWallType_type; }
const IfcParse::entity& IfcWallType::Class() { return *IfcWallType_type; }
IfcWallType::IfcWallType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWallType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWallType::IfcWallType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWallTypeEnum::IfcWallTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWallType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcWallTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcWasteTerminal
bool IfcWasteTerminal::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum IfcWasteTerminal::PredefinedType() const { return IfcWasteTerminalTypeEnum::FromString(*data_->getArgument(8)); }
void IfcWasteTerminal::setPredefinedType(IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWasteTerminalTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcWasteTerminal::declaration() const { return *IfcWasteTerminal_type; }
const IfcParse::entity& IfcWasteTerminal::Class() { return *IfcWasteTerminal_type; }
IfcWasteTerminal::IfcWasteTerminal(IfcEntityInstanceData* e) : IfcFlowTerminal((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWasteTerminal_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWasteTerminal::IfcWasteTerminal(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWasteTerminal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcWasteTerminalTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcWasteTerminalType
IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum IfcWasteTerminalType::PredefinedType() const { return IfcWasteTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void IfcWasteTerminalType::setPredefinedType(IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWasteTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& IfcWasteTerminalType::declaration() const { return *IfcWasteTerminalType_type; }
const IfcParse::entity& IfcWasteTerminalType::Class() { return *IfcWasteTerminalType_type; }
IfcWasteTerminalType::IfcWasteTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWasteTerminalType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWasteTerminalType::IfcWasteTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWasteTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcWasteTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcWindow
bool IfcWindow::hasOverallHeight() const { return !data_->getArgument(8)->isNull(); }
double IfcWindow::OverallHeight() const { return *data_->getArgument(8); }
void IfcWindow::setOverallHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcWindow::hasOverallWidth() const { return !data_->getArgument(9)->isNull(); }
double IfcWindow::OverallWidth() const { return *data_->getArgument(9); }
void IfcWindow::setOverallWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcWindow::hasPredefinedType() const { return !data_->getArgument(10)->isNull(); }
IfcWindowTypeEnum::IfcWindowTypeEnum IfcWindow::PredefinedType() const { return IfcWindowTypeEnum::FromString(*data_->getArgument(10)); }
void IfcWindow::setPredefinedType(IfcWindowTypeEnum::IfcWindowTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowTypeEnum::ToString(v)));data_->setArgument(10,attr);} }
bool IfcWindow::hasPartitioningType() const { return !data_->getArgument(11)->isNull(); }
IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum IfcWindow::PartitioningType() const { return IfcWindowTypePartitioningEnum::FromString(*data_->getArgument(11)); }
void IfcWindow::setPartitioningType(IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowTypePartitioningEnum::ToString(v)));data_->setArgument(11,attr);} }
bool IfcWindow::hasUserDefinedPartitioningType() const { return !data_->getArgument(12)->isNull(); }
std::string IfcWindow::UserDefinedPartitioningType() const { return *data_->getArgument(12); }
void IfcWindow::setUserDefinedPartitioningType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& IfcWindow::declaration() const { return *IfcWindow_type; }
const IfcParse::entity& IfcWindow::Class() { return *IfcWindow_type; }
IfcWindow::IfcWindow(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWindow_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWindow::IfcWindow(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth, boost::optional< IfcWindowTypeEnum::IfcWindowTypeEnum > v11_PredefinedType, boost::optional< IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum > v12_PartitioningType, boost::optional< std::string > v13_UserDefinedPartitioningType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWindow_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_OverallHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_OverallHeight));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_OverallWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_OverallWidth));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcWindowTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_PartitioningType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v12_PartitioningType,IfcWindowTypePartitioningEnum::ToString(*v12_PartitioningType))));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_UserDefinedPartitioningType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_UserDefinedPartitioningType));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcWindowLiningProperties
bool IfcWindowLiningProperties::hasLiningDepth() const { return !data_->getArgument(4)->isNull(); }
double IfcWindowLiningProperties::LiningDepth() const { return *data_->getArgument(4); }
void IfcWindowLiningProperties::setLiningDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcWindowLiningProperties::hasLiningThickness() const { return !data_->getArgument(5)->isNull(); }
double IfcWindowLiningProperties::LiningThickness() const { return *data_->getArgument(5); }
void IfcWindowLiningProperties::setLiningThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool IfcWindowLiningProperties::hasTransomThickness() const { return !data_->getArgument(6)->isNull(); }
double IfcWindowLiningProperties::TransomThickness() const { return *data_->getArgument(6); }
void IfcWindowLiningProperties::setTransomThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcWindowLiningProperties::hasMullionThickness() const { return !data_->getArgument(7)->isNull(); }
double IfcWindowLiningProperties::MullionThickness() const { return *data_->getArgument(7); }
void IfcWindowLiningProperties::setMullionThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcWindowLiningProperties::hasFirstTransomOffset() const { return !data_->getArgument(8)->isNull(); }
double IfcWindowLiningProperties::FirstTransomOffset() const { return *data_->getArgument(8); }
void IfcWindowLiningProperties::setFirstTransomOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcWindowLiningProperties::hasSecondTransomOffset() const { return !data_->getArgument(9)->isNull(); }
double IfcWindowLiningProperties::SecondTransomOffset() const { return *data_->getArgument(9); }
void IfcWindowLiningProperties::setSecondTransomOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcWindowLiningProperties::hasFirstMullionOffset() const { return !data_->getArgument(10)->isNull(); }
double IfcWindowLiningProperties::FirstMullionOffset() const { return *data_->getArgument(10); }
void IfcWindowLiningProperties::setFirstMullionOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcWindowLiningProperties::hasSecondMullionOffset() const { return !data_->getArgument(11)->isNull(); }
double IfcWindowLiningProperties::SecondMullionOffset() const { return *data_->getArgument(11); }
void IfcWindowLiningProperties::setSecondMullionOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcWindowLiningProperties::hasShapeAspectStyle() const { return !data_->getArgument(12)->isNull(); }
IfcShapeAspect* IfcWindowLiningProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(12))); }
void IfcWindowLiningProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
bool IfcWindowLiningProperties::hasLiningOffset() const { return !data_->getArgument(13)->isNull(); }
double IfcWindowLiningProperties::LiningOffset() const { return *data_->getArgument(13); }
void IfcWindowLiningProperties::setLiningOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
bool IfcWindowLiningProperties::hasLiningToPanelOffsetX() const { return !data_->getArgument(14)->isNull(); }
double IfcWindowLiningProperties::LiningToPanelOffsetX() const { return *data_->getArgument(14); }
void IfcWindowLiningProperties::setLiningToPanelOffsetX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
bool IfcWindowLiningProperties::hasLiningToPanelOffsetY() const { return !data_->getArgument(15)->isNull(); }
double IfcWindowLiningProperties::LiningToPanelOffsetY() const { return *data_->getArgument(15); }
void IfcWindowLiningProperties::setLiningToPanelOffsetY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }


const IfcParse::entity& IfcWindowLiningProperties::declaration() const { return *IfcWindowLiningProperties_type; }
const IfcParse::entity& IfcWindowLiningProperties::Class() { return *IfcWindowLiningProperties_type; }
IfcWindowLiningProperties::IfcWindowLiningProperties(IfcEntityInstanceData* e) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWindowLiningProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWindowLiningProperties::IfcWindowLiningProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_TransomThickness, boost::optional< double > v8_MullionThickness, boost::optional< double > v9_FirstTransomOffset, boost::optional< double > v10_SecondTransomOffset, boost::optional< double > v11_FirstMullionOffset, boost::optional< double > v12_SecondMullionOffset, IfcShapeAspect* v13_ShapeAspectStyle, boost::optional< double > v14_LiningOffset, boost::optional< double > v15_LiningToPanelOffsetX, boost::optional< double > v16_LiningToPanelOffsetY) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWindowLiningProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_LiningDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LiningDepth));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LiningThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LiningThickness));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_TransomThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_TransomThickness));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_MullionThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_MullionThickness));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_FirstTransomOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FirstTransomOffset));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_SecondTransomOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_SecondTransomOffset));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_FirstMullionOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_FirstMullionOffset));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_SecondMullionOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_SecondMullionOffset));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_ShapeAspectStyle));data_->setArgument(12,attr);} if (v14_LiningOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_LiningOffset));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_LiningToPanelOffsetX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_LiningToPanelOffsetX));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_LiningToPanelOffsetY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_LiningToPanelOffsetY));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } }

// Function implementations for IfcWindowPanelProperties
IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum IfcWindowPanelProperties::OperationType() const { return IfcWindowPanelOperationEnum::FromString(*data_->getArgument(4)); }
void IfcWindowPanelProperties::setOperationType(IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowPanelOperationEnum::ToString(v)));data_->setArgument(4,attr);} }
IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum IfcWindowPanelProperties::PanelPosition() const { return IfcWindowPanelPositionEnum::FromString(*data_->getArgument(5)); }
void IfcWindowPanelProperties::setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowPanelPositionEnum::ToString(v)));data_->setArgument(5,attr);} }
bool IfcWindowPanelProperties::hasFrameDepth() const { return !data_->getArgument(6)->isNull(); }
double IfcWindowPanelProperties::FrameDepth() const { return *data_->getArgument(6); }
void IfcWindowPanelProperties::setFrameDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcWindowPanelProperties::hasFrameThickness() const { return !data_->getArgument(7)->isNull(); }
double IfcWindowPanelProperties::FrameThickness() const { return *data_->getArgument(7); }
void IfcWindowPanelProperties::setFrameThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcWindowPanelProperties::hasShapeAspectStyle() const { return !data_->getArgument(8)->isNull(); }
IfcShapeAspect* IfcWindowPanelProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(8))); }
void IfcWindowPanelProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcWindowPanelProperties::declaration() const { return *IfcWindowPanelProperties_type; }
const IfcParse::entity& IfcWindowPanelProperties::Class() { return *IfcWindowPanelProperties_type; }
IfcWindowPanelProperties::IfcWindowPanelProperties(IfcEntityInstanceData* e) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWindowPanelProperties_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWindowPanelProperties::IfcWindowPanelProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle) : IfcPreDefinedPropertySet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWindowPanelProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_OperationType,IfcWindowPanelOperationEnum::ToString(v5_OperationType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PanelPosition,IfcWindowPanelPositionEnum::ToString(v6_PanelPosition))));data_->setArgument(5,attr);} if (v7_FrameDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_FrameDepth));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_FrameThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FrameThickness));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ShapeAspectStyle));data_->setArgument(8,attr);} }

// Function implementations for IfcWindowStandardCase


const IfcParse::entity& IfcWindowStandardCase::declaration() const { return *IfcWindowStandardCase_type; }
const IfcParse::entity& IfcWindowStandardCase::Class() { return *IfcWindowStandardCase_type; }
IfcWindowStandardCase::IfcWindowStandardCase(IfcEntityInstanceData* e) : IfcWindow((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWindowStandardCase_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWindowStandardCase::IfcWindowStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth, boost::optional< IfcWindowTypeEnum::IfcWindowTypeEnum > v11_PredefinedType, boost::optional< IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum > v12_PartitioningType, boost::optional< std::string > v13_UserDefinedPartitioningType) : IfcWindow((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWindowStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_OverallHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_OverallHeight));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_OverallWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_OverallWidth));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v11_PredefinedType,IfcWindowTypeEnum::ToString(*v11_PredefinedType))));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_PartitioningType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v12_PartitioningType,IfcWindowTypePartitioningEnum::ToString(*v12_PartitioningType))));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_UserDefinedPartitioningType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_UserDefinedPartitioningType));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcWindowStyle
IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum IfcWindowStyle::ConstructionType() const { return IfcWindowStyleConstructionEnum::FromString(*data_->getArgument(8)); }
void IfcWindowStyle::setConstructionType(IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowStyleConstructionEnum::ToString(v)));data_->setArgument(8,attr);} }
IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum IfcWindowStyle::OperationType() const { return IfcWindowStyleOperationEnum::FromString(*data_->getArgument(9)); }
void IfcWindowStyle::setOperationType(IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowStyleOperationEnum::ToString(v)));data_->setArgument(9,attr);} }
bool IfcWindowStyle::ParameterTakesPrecedence() const { return *data_->getArgument(10); }
void IfcWindowStyle::setParameterTakesPrecedence(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool IfcWindowStyle::Sizeable() const { return *data_->getArgument(11); }
void IfcWindowStyle::setSizeable(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }


const IfcParse::entity& IfcWindowStyle::declaration() const { return *IfcWindowStyle_type; }
const IfcParse::entity& IfcWindowStyle::Class() { return *IfcWindowStyle_type; }
IfcWindowStyle::IfcWindowStyle(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWindowStyle_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWindowStyle::IfcWindowStyle(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v9_ConstructionType, IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v10_OperationType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable) : IfcTypeProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWindowStyle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ConstructionType,IfcWindowStyleConstructionEnum::ToString(v9_ConstructionType))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_OperationType,IfcWindowStyleOperationEnum::ToString(v10_OperationType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ParameterTakesPrecedence));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_Sizeable));data_->setArgument(11,attr);} }

// Function implementations for IfcWindowType
IfcWindowTypeEnum::IfcWindowTypeEnum IfcWindowType::PredefinedType() const { return IfcWindowTypeEnum::FromString(*data_->getArgument(9)); }
void IfcWindowType::setPredefinedType(IfcWindowTypeEnum::IfcWindowTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum IfcWindowType::PartitioningType() const { return IfcWindowTypePartitioningEnum::FromString(*data_->getArgument(10)); }
void IfcWindowType::setPartitioningType(IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowTypePartitioningEnum::ToString(v)));data_->setArgument(10,attr);} }
bool IfcWindowType::hasParameterTakesPrecedence() const { return !data_->getArgument(11)->isNull(); }
bool IfcWindowType::ParameterTakesPrecedence() const { return *data_->getArgument(11); }
void IfcWindowType::setParameterTakesPrecedence(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcWindowType::hasUserDefinedPartitioningType() const { return !data_->getArgument(12)->isNull(); }
std::string IfcWindowType::UserDefinedPartitioningType() const { return *data_->getArgument(12); }
void IfcWindowType::setUserDefinedPartitioningType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& IfcWindowType::declaration() const { return *IfcWindowType_type; }
const IfcParse::entity& IfcWindowType::Class() { return *IfcWindowType_type; }
IfcWindowType::IfcWindowType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWindowType_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWindowType::IfcWindowType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWindowTypeEnum::IfcWindowTypeEnum v10_PredefinedType, IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum v11_PartitioningType, boost::optional< bool > v12_ParameterTakesPrecedence, boost::optional< std::string > v13_UserDefinedPartitioningType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWindowType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcWindowTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v11_PartitioningType,IfcWindowTypePartitioningEnum::ToString(v11_PartitioningType))));data_->setArgument(10,attr);} if (v12_ParameterTakesPrecedence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_ParameterTakesPrecedence));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_UserDefinedPartitioningType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_UserDefinedPartitioningType));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcWorkCalendar
bool IfcWorkCalendar::hasWorkingTimes() const { return !data_->getArgument(6)->isNull(); }
IfcTemplatedEntityList< IfcWorkTime >::ptr IfcWorkCalendar::WorkingTimes() const { IfcEntityList::ptr es = *data_->getArgument(6); return es->as<IfcWorkTime>(); }
void IfcWorkCalendar::setWorkingTimes(IfcTemplatedEntityList< IfcWorkTime >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(6,attr);} }
bool IfcWorkCalendar::hasExceptionTimes() const { return !data_->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcWorkTime >::ptr IfcWorkCalendar::ExceptionTimes() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcWorkTime>(); }
void IfcWorkCalendar::setExceptionTimes(IfcTemplatedEntityList< IfcWorkTime >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }
bool IfcWorkCalendar::hasPredefinedType() const { return !data_->getArgument(8)->isNull(); }
IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum IfcWorkCalendar::PredefinedType() const { return IfcWorkCalendarTypeEnum::FromString(*data_->getArgument(8)); }
void IfcWorkCalendar::setPredefinedType(IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWorkCalendarTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& IfcWorkCalendar::declaration() const { return *IfcWorkCalendar_type; }
const IfcParse::entity& IfcWorkCalendar::Class() { return *IfcWorkCalendar_type; }
IfcWorkCalendar::IfcWorkCalendar(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWorkCalendar_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWorkCalendar::IfcWorkCalendar(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcTemplatedEntityList< IfcWorkTime >::ptr > v7_WorkingTimes, boost::optional< IfcTemplatedEntityList< IfcWorkTime >::ptr > v8_ExceptionTimes, boost::optional< IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum > v9_PredefinedType) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWorkCalendar_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_WorkingTimes) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_WorkingTimes)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ExceptionTimes) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_ExceptionTimes)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcWorkCalendarTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcWorkControl
std::string IfcWorkControl::CreationDate() const { return *data_->getArgument(6); }
void IfcWorkControl::setCreationDate(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcWorkControl::hasCreators() const { return !data_->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcPerson >::ptr IfcWorkControl::Creators() const { IfcEntityList::ptr es = *data_->getArgument(7); return es->as<IfcPerson>(); }
void IfcWorkControl::setCreators(IfcTemplatedEntityList< IfcPerson >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());data_->setArgument(7,attr);} }
bool IfcWorkControl::hasPurpose() const { return !data_->getArgument(8)->isNull(); }
std::string IfcWorkControl::Purpose() const { return *data_->getArgument(8); }
void IfcWorkControl::setPurpose(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
bool IfcWorkControl::hasDuration() const { return !data_->getArgument(9)->isNull(); }
std::string IfcWorkControl::Duration() const { return *data_->getArgument(9); }
void IfcWorkControl::setDuration(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
bool IfcWorkControl::hasTotalFloat() const { return !data_->getArgument(10)->isNull(); }
std::string IfcWorkControl::TotalFloat() const { return *data_->getArgument(10); }
void IfcWorkControl::setTotalFloat(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
std::string IfcWorkControl::StartTime() const { return *data_->getArgument(11); }
void IfcWorkControl::setStartTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
bool IfcWorkControl::hasFinishTime() const { return !data_->getArgument(12)->isNull(); }
std::string IfcWorkControl::FinishTime() const { return *data_->getArgument(12); }
void IfcWorkControl::setFinishTime(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& IfcWorkControl::declaration() const { return *IfcWorkControl_type; }
const IfcParse::entity& IfcWorkControl::Class() { return *IfcWorkControl_type; }
IfcWorkControl::IfcWorkControl(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWorkControl_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWorkControl::IfcWorkControl(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, std::string v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< std::string > v10_Duration, boost::optional< std::string > v11_TotalFloat, std::string v12_StartTime, boost::optional< std::string > v13_FinishTime) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWorkControl_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CreationDate));data_->setArgument(6,attr);} if (v8_Creators) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Creators)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Purpose));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Duration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Duration));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TotalFloat));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_StartTime));data_->setArgument(11,attr);} if (v13_FinishTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_FinishTime));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcWorkPlan
bool IfcWorkPlan::hasPredefinedType() const { return !data_->getArgument(13)->isNull(); }
IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum IfcWorkPlan::PredefinedType() const { return IfcWorkPlanTypeEnum::FromString(*data_->getArgument(13)); }
void IfcWorkPlan::setPredefinedType(IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWorkPlanTypeEnum::ToString(v)));data_->setArgument(13,attr);} }


const IfcParse::entity& IfcWorkPlan::declaration() const { return *IfcWorkPlan_type; }
const IfcParse::entity& IfcWorkPlan::Class() { return *IfcWorkPlan_type; }
IfcWorkPlan::IfcWorkPlan(IfcEntityInstanceData* e) : IfcWorkControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWorkPlan_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWorkPlan::IfcWorkPlan(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, std::string v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< std::string > v10_Duration, boost::optional< std::string > v11_TotalFloat, std::string v12_StartTime, boost::optional< std::string > v13_FinishTime, boost::optional< IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum > v14_PredefinedType) : IfcWorkControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWorkPlan_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CreationDate));data_->setArgument(6,attr);} if (v8_Creators) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Creators)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Purpose));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Duration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Duration));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TotalFloat));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_StartTime));data_->setArgument(11,attr);} if (v13_FinishTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_FinishTime));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_PredefinedType,IfcWorkPlanTypeEnum::ToString(*v14_PredefinedType))));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } }

// Function implementations for IfcWorkSchedule
bool IfcWorkSchedule::hasPredefinedType() const { return !data_->getArgument(13)->isNull(); }
IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum IfcWorkSchedule::PredefinedType() const { return IfcWorkScheduleTypeEnum::FromString(*data_->getArgument(13)); }
void IfcWorkSchedule::setPredefinedType(IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWorkScheduleTypeEnum::ToString(v)));data_->setArgument(13,attr);} }


const IfcParse::entity& IfcWorkSchedule::declaration() const { return *IfcWorkSchedule_type; }
const IfcParse::entity& IfcWorkSchedule::Class() { return *IfcWorkSchedule_type; }
IfcWorkSchedule::IfcWorkSchedule(IfcEntityInstanceData* e) : IfcWorkControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWorkSchedule_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWorkSchedule::IfcWorkSchedule(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, std::string v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< std::string > v10_Duration, boost::optional< std::string > v11_TotalFloat, std::string v12_StartTime, boost::optional< std::string > v13_FinishTime, boost::optional< IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum > v14_PredefinedType) : IfcWorkControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWorkSchedule_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Identification) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Identification));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CreationDate));data_->setArgument(6,attr);} if (v8_Creators) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Creators)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Purpose));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Duration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Duration));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TotalFloat));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_StartTime));data_->setArgument(11,attr);} if (v13_FinishTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_FinishTime));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_PredefinedType,IfcWorkScheduleTypeEnum::ToString(*v14_PredefinedType))));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } }

// Function implementations for IfcWorkTime
bool IfcWorkTime::hasRecurrencePattern() const { return !data_->getArgument(3)->isNull(); }
IfcRecurrencePattern* IfcWorkTime::RecurrencePattern() const { return (IfcRecurrencePattern*)((IfcUtil::IfcBaseClass*)(*data_->getArgument(3))); }
void IfcWorkTime::setRecurrencePattern(IfcRecurrencePattern* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
bool IfcWorkTime::hasStart() const { return !data_->getArgument(4)->isNull(); }
std::string IfcWorkTime::Start() const { return *data_->getArgument(4); }
void IfcWorkTime::setStart(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool IfcWorkTime::hasFinish() const { return !data_->getArgument(5)->isNull(); }
std::string IfcWorkTime::Finish() const { return *data_->getArgument(5); }
void IfcWorkTime::setFinish(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcWorkTime::declaration() const { return *IfcWorkTime_type; }
const IfcParse::entity& IfcWorkTime::Class() { return *IfcWorkTime_type; }
IfcWorkTime::IfcWorkTime(IfcEntityInstanceData* e) : IfcSchedulingTime((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcWorkTime_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcWorkTime::IfcWorkTime(boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, IfcRecurrencePattern* v4_RecurrencePattern, boost::optional< std::string > v5_Start, boost::optional< std::string > v6_Finish) : IfcSchedulingTime((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcWorkTime_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin))));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedDataOrigin));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RecurrencePattern));data_->setArgument(3,attr);} if (v5_Start) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Start));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Finish) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Finish));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcZShapeProfileDef
double IfcZShapeProfileDef::Depth() const { return *data_->getArgument(3); }
void IfcZShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double IfcZShapeProfileDef::FlangeWidth() const { return *data_->getArgument(4); }
void IfcZShapeProfileDef::setFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double IfcZShapeProfileDef::WebThickness() const { return *data_->getArgument(5); }
void IfcZShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double IfcZShapeProfileDef::FlangeThickness() const { return *data_->getArgument(6); }
void IfcZShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool IfcZShapeProfileDef::hasFilletRadius() const { return !data_->getArgument(7)->isNull(); }
double IfcZShapeProfileDef::FilletRadius() const { return *data_->getArgument(7); }
void IfcZShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
bool IfcZShapeProfileDef::hasEdgeRadius() const { return !data_->getArgument(8)->isNull(); }
double IfcZShapeProfileDef::EdgeRadius() const { return *data_->getArgument(8); }
void IfcZShapeProfileDef::setEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& IfcZShapeProfileDef::declaration() const { return *IfcZShapeProfileDef_type; }
const IfcParse::entity& IfcZShapeProfileDef::Class() { return *IfcZShapeProfileDef_type; }
IfcZShapeProfileDef::IfcZShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcZShapeProfileDef_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcZShapeProfileDef::IfcZShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcZShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_FlangeWidth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));data_->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_EdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_EdgeRadius));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcZone
bool IfcZone::hasLongName() const { return !data_->getArgument(5)->isNull(); }
std::string IfcZone::LongName() const { return *data_->getArgument(5); }
void IfcZone::setLongName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& IfcZone::declaration() const { return *IfcZone_type; }
const IfcParse::entity& IfcZone::Class() { return *IfcZone_type; }
IfcZone::IfcZone(IfcEntityInstanceData* e) : IfcSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IfcZone_type) throw IfcException("Unable to find find keyword in schema"); data_ = e; }
IfcZone::IfcZone(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName) : IfcSystem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IfcZone_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LongName));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

#endif
